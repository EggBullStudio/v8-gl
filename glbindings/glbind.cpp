#include "glbind.h"



Handle<Value> GetGL_VERSION_1_1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERSION_1_1);
}




Handle<Value> GetGL_VERSION_1_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERSION_1_2);
}




Handle<Value> GetGL_VERSION_1_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERSION_1_3);
}




Handle<Value> GetGL_ARB_imaging(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ARB_imaging);
}




Handle<Value> GetGL_FALSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FALSE);
}




Handle<Value> GetGL_TRUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRUE);
}




Handle<Value> GetGL_BYTE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BYTE);
}




Handle<Value> GetGL_UNSIGNED_BYTE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_BYTE);
}




Handle<Value> GetGL_SHORT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SHORT);
}




Handle<Value> GetGL_UNSIGNED_SHORT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT);
}




Handle<Value> GetGL_INT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INT);
}




Handle<Value> GetGL_UNSIGNED_INT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT);
}




Handle<Value> GetGL_FLOAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FLOAT);
}




Handle<Value> GetGL_2_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_2_BYTES);
}




Handle<Value> GetGL_3_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_3_BYTES);
}




Handle<Value> GetGL_4_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_4_BYTES);
}




Handle<Value> GetGL_DOUBLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOUBLE);
}




Handle<Value> GetGL_POINTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINTS);
}




Handle<Value> GetGL_LINES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINES);
}




Handle<Value> GetGL_LINE_LOOP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_LOOP);
}




Handle<Value> GetGL_LINE_STRIP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_STRIP);
}




Handle<Value> GetGL_TRIANGLES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRIANGLES);
}




Handle<Value> GetGL_TRIANGLE_STRIP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRIANGLE_STRIP);
}




Handle<Value> GetGL_TRIANGLE_FAN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRIANGLE_FAN);
}




Handle<Value> GetGL_QUADS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_QUADS);
}




Handle<Value> GetGL_QUAD_STRIP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_QUAD_STRIP);
}




Handle<Value> GetGL_POLYGON(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON);
}




Handle<Value> GetGL_VERTEX_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY);
}




Handle<Value> GetGL_NORMAL_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_ARRAY);
}




Handle<Value> GetGL_COLOR_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY);
}




Handle<Value> GetGL_INDEX_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_ARRAY);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY);
}




Handle<Value> GetGL_EDGE_FLAG_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EDGE_FLAG_ARRAY);
}




Handle<Value> GetGL_VERTEX_ARRAY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY_SIZE);
}




Handle<Value> GetGL_VERTEX_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY_TYPE);
}




Handle<Value> GetGL_VERTEX_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY_STRIDE);
}




Handle<Value> GetGL_NORMAL_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_ARRAY_TYPE);
}




Handle<Value> GetGL_NORMAL_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_ARRAY_STRIDE);
}




Handle<Value> GetGL_COLOR_ARRAY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY_SIZE);
}




Handle<Value> GetGL_COLOR_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY_TYPE);
}




Handle<Value> GetGL_COLOR_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY_STRIDE);
}




Handle<Value> GetGL_INDEX_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_ARRAY_TYPE);
}




Handle<Value> GetGL_INDEX_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_ARRAY_STRIDE);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY_SIZE);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY_TYPE);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY_STRIDE);
}




Handle<Value> GetGL_EDGE_FLAG_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EDGE_FLAG_ARRAY_STRIDE);
}




Handle<Value> GetGL_VERTEX_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY_POINTER);
}




Handle<Value> GetGL_NORMAL_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_ARRAY_POINTER);
}




Handle<Value> GetGL_COLOR_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY_POINTER);
}




Handle<Value> GetGL_INDEX_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_ARRAY_POINTER);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY_POINTER);
}




Handle<Value> GetGL_EDGE_FLAG_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EDGE_FLAG_ARRAY_POINTER);
}




Handle<Value> GetGL_V2F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_V2F);
}




Handle<Value> GetGL_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_V3F);
}




Handle<Value> GetGL_C4UB_V2F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_C4UB_V2F);
}




Handle<Value> GetGL_C4UB_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_C4UB_V3F);
}




Handle<Value> GetGL_C3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_C3F_V3F);
}




Handle<Value> GetGL_N3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_N3F_V3F);
}




Handle<Value> GetGL_C4F_N3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_C4F_N3F_V3F);
}




Handle<Value> GetGL_T2F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_V3F);
}




Handle<Value> GetGL_T4F_V4F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T4F_V4F);
}




Handle<Value> GetGL_T2F_C4UB_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_C4UB_V3F);
}




Handle<Value> GetGL_T2F_C3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_C3F_V3F);
}




Handle<Value> GetGL_T2F_N3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_N3F_V3F);
}




Handle<Value> GetGL_T2F_C4F_N3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_C4F_N3F_V3F);
}




Handle<Value> GetGL_T4F_C4F_N3F_V4F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T4F_C4F_N3F_V4F);
}




Handle<Value> GetGL_MATRIX_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MATRIX_MODE);
}




Handle<Value> GetGL_MODELVIEW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MODELVIEW);
}




Handle<Value> GetGL_PROJECTION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROJECTION);
}




Handle<Value> GetGL_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE);
}




Handle<Value> GetGL_POINT_SMOOTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SMOOTH);
}




Handle<Value> GetGL_POINT_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SIZE);
}




Handle<Value> GetGL_POINT_SIZE_GRANULARITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SIZE_GRANULARITY);
}




Handle<Value> GetGL_POINT_SIZE_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SIZE_RANGE);
}




Handle<Value> GetGL_LINE_SMOOTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_SMOOTH);
}




Handle<Value> GetGL_LINE_STIPPLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_STIPPLE);
}




Handle<Value> GetGL_LINE_STIPPLE_PATTERN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_STIPPLE_PATTERN);
}




Handle<Value> GetGL_LINE_STIPPLE_REPEAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_STIPPLE_REPEAT);
}




Handle<Value> GetGL_LINE_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_WIDTH);
}




Handle<Value> GetGL_LINE_WIDTH_GRANULARITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_WIDTH_GRANULARITY);
}




Handle<Value> GetGL_LINE_WIDTH_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_WIDTH_RANGE);
}




Handle<Value> GetGL_POINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT);
}




Handle<Value> GetGL_LINE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE);
}




Handle<Value> GetGL_FILL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FILL);
}




Handle<Value> GetGL_CW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CW);
}




Handle<Value> GetGL_CCW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CCW);
}




Handle<Value> GetGL_FRONT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT);
}




Handle<Value> GetGL_BACK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BACK);
}




Handle<Value> GetGL_POLYGON_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_MODE);
}




Handle<Value> GetGL_POLYGON_SMOOTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_SMOOTH);
}




Handle<Value> GetGL_POLYGON_STIPPLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_STIPPLE);
}




Handle<Value> GetGL_EDGE_FLAG(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EDGE_FLAG);
}




Handle<Value> GetGL_CULL_FACE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CULL_FACE);
}




Handle<Value> GetGL_CULL_FACE_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CULL_FACE_MODE);
}




Handle<Value> GetGL_FRONT_FACE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT_FACE);
}




Handle<Value> GetGL_POLYGON_OFFSET_FACTOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_FACTOR);
}




Handle<Value> GetGL_POLYGON_OFFSET_UNITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_UNITS);
}




Handle<Value> GetGL_POLYGON_OFFSET_POINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_POINT);
}




Handle<Value> GetGL_POLYGON_OFFSET_LINE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_LINE);
}




Handle<Value> GetGL_POLYGON_OFFSET_FILL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_FILL);
}




Handle<Value> GetGL_COMPILE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPILE);
}




Handle<Value> GetGL_COMPILE_AND_EXECUTE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPILE_AND_EXECUTE);
}




Handle<Value> GetGL_LIST_BASE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIST_BASE);
}




Handle<Value> GetGL_LIST_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIST_INDEX);
}




Handle<Value> GetGL_LIST_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIST_MODE);
}




Handle<Value> GetGL_NEVER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NEVER);
}




Handle<Value> GetGL_LESS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LESS);
}




Handle<Value> GetGL_EQUAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EQUAL);
}




Handle<Value> GetGL_LEQUAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LEQUAL);
}




Handle<Value> GetGL_GREATER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREATER);
}




Handle<Value> GetGL_NOTEQUAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NOTEQUAL);
}




Handle<Value> GetGL_GEQUAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GEQUAL);
}




Handle<Value> GetGL_ALWAYS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALWAYS);
}




Handle<Value> GetGL_DEPTH_TEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_TEST);
}




Handle<Value> GetGL_DEPTH_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_BITS);
}




Handle<Value> GetGL_DEPTH_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_CLEAR_VALUE);
}




Handle<Value> GetGL_DEPTH_FUNC(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_FUNC);
}




Handle<Value> GetGL_DEPTH_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_RANGE);
}




Handle<Value> GetGL_DEPTH_WRITEMASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_WRITEMASK);
}




Handle<Value> GetGL_DEPTH_COMPONENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_COMPONENT);
}




Handle<Value> GetGL_LIGHTING(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHTING);
}




Handle<Value> GetGL_LIGHT0(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT0);
}




Handle<Value> GetGL_LIGHT1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT1);
}




Handle<Value> GetGL_LIGHT2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT2);
}




Handle<Value> GetGL_LIGHT3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT3);
}




Handle<Value> GetGL_LIGHT4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT4);
}




Handle<Value> GetGL_LIGHT5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT5);
}




Handle<Value> GetGL_LIGHT6(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT6);
}




Handle<Value> GetGL_LIGHT7(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT7);
}




Handle<Value> GetGL_SPOT_EXPONENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPOT_EXPONENT);
}




Handle<Value> GetGL_SPOT_CUTOFF(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPOT_CUTOFF);
}




Handle<Value> GetGL_AMBIENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AMBIENT);
}




Handle<Value> GetGL_DIFFUSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DIFFUSE);
}




Handle<Value> GetGL_SPECULAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPECULAR);
}




Handle<Value> GetGL_SHININESS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SHININESS);
}




Handle<Value> GetGL_EMISSION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EMISSION);
}




Handle<Value> GetGL_POSITION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POSITION);
}




Handle<Value> GetGL_SPOT_DIRECTION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPOT_DIRECTION);
}




Handle<Value> GetGL_AMBIENT_AND_DIFFUSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AMBIENT_AND_DIFFUSE);
}




Handle<Value> GetGL_COLOR_INDEXES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_INDEXES);
}




Handle<Value> GetGL_LIGHT_MODEL_TWO_SIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT_MODEL_TWO_SIDE);
}




Handle<Value> GetGL_LIGHT_MODEL_LOCAL_VIEWER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT_MODEL_LOCAL_VIEWER);
}




Handle<Value> GetGL_LIGHT_MODEL_AMBIENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT_MODEL_AMBIENT);
}




Handle<Value> GetGL_FRONT_AND_BACK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT_AND_BACK);
}




Handle<Value> GetGL_SHADE_MODEL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SHADE_MODEL);
}




Handle<Value> GetGL_FLAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FLAT);
}




Handle<Value> GetGL_SMOOTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH);
}




Handle<Value> GetGL_COLOR_MATERIAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATERIAL);
}




Handle<Value> GetGL_COLOR_MATERIAL_FACE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATERIAL_FACE);
}




Handle<Value> GetGL_COLOR_MATERIAL_PARAMETER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATERIAL_PARAMETER);
}




Handle<Value> GetGL_NORMALIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMALIZE);
}




Handle<Value> GetGL_CLIP_PLANE0(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE0);
}




Handle<Value> GetGL_CLIP_PLANE1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE1);
}




Handle<Value> GetGL_CLIP_PLANE2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE2);
}




Handle<Value> GetGL_CLIP_PLANE3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE3);
}




Handle<Value> GetGL_CLIP_PLANE4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE4);
}




Handle<Value> GetGL_CLIP_PLANE5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE5);
}




Handle<Value> GetGL_ACCUM_RED_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_RED_BITS);
}




Handle<Value> GetGL_ACCUM_GREEN_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_GREEN_BITS);
}




Handle<Value> GetGL_ACCUM_BLUE_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_BLUE_BITS);
}




Handle<Value> GetGL_ACCUM_ALPHA_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_ALPHA_BITS);
}




Handle<Value> GetGL_ACCUM_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_CLEAR_VALUE);
}




Handle<Value> GetGL_ACCUM(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM);
}




Handle<Value> GetGL_ADD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ADD);
}




Handle<Value> GetGL_LOAD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LOAD);
}




Handle<Value> GetGL_MULT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MULT);
}




Handle<Value> GetGL_RETURN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RETURN);
}




Handle<Value> GetGL_ALPHA_TEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_TEST);
}




Handle<Value> GetGL_ALPHA_TEST_REF(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_TEST_REF);
}




Handle<Value> GetGL_ALPHA_TEST_FUNC(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_TEST_FUNC);
}




Handle<Value> GetGL_BLEND(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND);
}




Handle<Value> GetGL_BLEND_SRC(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND_SRC);
}




Handle<Value> GetGL_BLEND_DST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND_DST);
}




Handle<Value> GetGL_ZERO(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ZERO);
}




Handle<Value> GetGL_ONE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE);
}




Handle<Value> GetGL_SRC_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SRC_COLOR);
}




Handle<Value> GetGL_ONE_MINUS_SRC_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_SRC_COLOR);
}




Handle<Value> GetGL_SRC_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SRC_ALPHA);
}




Handle<Value> GetGL_ONE_MINUS_SRC_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_SRC_ALPHA);
}




Handle<Value> GetGL_DST_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DST_ALPHA);
}




Handle<Value> GetGL_ONE_MINUS_DST_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_DST_ALPHA);
}




Handle<Value> GetGL_DST_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DST_COLOR);
}




Handle<Value> GetGL_ONE_MINUS_DST_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_DST_COLOR);
}




Handle<Value> GetGL_SRC_ALPHA_SATURATE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SRC_ALPHA_SATURATE);
}




Handle<Value> GetGL_FEEDBACK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FEEDBACK);
}




Handle<Value> GetGL_RENDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RENDER);
}




Handle<Value> GetGL_SELECT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SELECT);
}




Handle<Value> GetGL_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_2D);
}




Handle<Value> GetGL_3D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_3D);
}




Handle<Value> GetGL_3D_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_3D_COLOR);
}




Handle<Value> GetGL_3D_COLOR_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_3D_COLOR_TEXTURE);
}




Handle<Value> GetGL_4D_COLOR_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_4D_COLOR_TEXTURE);
}




Handle<Value> GetGL_POINT_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_TOKEN);
}




Handle<Value> GetGL_LINE_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_TOKEN);
}




Handle<Value> GetGL_LINE_RESET_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_RESET_TOKEN);
}




Handle<Value> GetGL_POLYGON_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_TOKEN);
}




Handle<Value> GetGL_BITMAP_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BITMAP_TOKEN);
}




Handle<Value> GetGL_DRAW_PIXEL_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DRAW_PIXEL_TOKEN);
}




Handle<Value> GetGL_COPY_PIXEL_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COPY_PIXEL_TOKEN);
}




Handle<Value> GetGL_PASS_THROUGH_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PASS_THROUGH_TOKEN);
}




Handle<Value> GetGL_FEEDBACK_BUFFER_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FEEDBACK_BUFFER_POINTER);
}




Handle<Value> GetGL_FEEDBACK_BUFFER_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FEEDBACK_BUFFER_SIZE);
}




Handle<Value> GetGL_FEEDBACK_BUFFER_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FEEDBACK_BUFFER_TYPE);
}




Handle<Value> GetGL_SELECTION_BUFFER_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SELECTION_BUFFER_POINTER);
}




Handle<Value> GetGL_SELECTION_BUFFER_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SELECTION_BUFFER_SIZE);
}




Handle<Value> GetGL_FOG(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG);
}




Handle<Value> GetGL_FOG_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_MODE);
}




Handle<Value> GetGL_FOG_DENSITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_DENSITY);
}




Handle<Value> GetGL_FOG_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_COLOR);
}




Handle<Value> GetGL_FOG_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_INDEX);
}




Handle<Value> GetGL_FOG_START(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_START);
}




Handle<Value> GetGL_FOG_END(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_END);
}




Handle<Value> GetGL_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINEAR);
}




Handle<Value> GetGL_EXP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EXP);
}




Handle<Value> GetGL_EXP2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EXP2);
}




Handle<Value> GetGL_LOGIC_OP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LOGIC_OP);
}




Handle<Value> GetGL_INDEX_LOGIC_OP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_LOGIC_OP);
}




Handle<Value> GetGL_COLOR_LOGIC_OP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_LOGIC_OP);
}




Handle<Value> GetGL_LOGIC_OP_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LOGIC_OP_MODE);
}




Handle<Value> GetGL_CLEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLEAR);
}




Handle<Value> GetGL_SET(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SET);
}




Handle<Value> GetGL_COPY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COPY);
}




Handle<Value> GetGL_COPY_INVERTED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COPY_INVERTED);
}




Handle<Value> GetGL_NOOP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NOOP);
}




Handle<Value> GetGL_INVERT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INVERT);
}




Handle<Value> GetGL_AND(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AND);
}




Handle<Value> GetGL_NAND(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NAND);
}




Handle<Value> GetGL_OR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OR);
}




Handle<Value> GetGL_NOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NOR);
}




Handle<Value> GetGL_XOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_XOR);
}




Handle<Value> GetGL_EQUIV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EQUIV);
}




Handle<Value> GetGL_AND_REVERSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AND_REVERSE);
}




Handle<Value> GetGL_AND_INVERTED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AND_INVERTED);
}




Handle<Value> GetGL_OR_REVERSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OR_REVERSE);
}




Handle<Value> GetGL_OR_INVERTED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OR_INVERTED);
}




Handle<Value> GetGL_STENCIL_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_BITS);
}




Handle<Value> GetGL_STENCIL_TEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_TEST);
}




Handle<Value> GetGL_STENCIL_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_CLEAR_VALUE);
}




Handle<Value> GetGL_STENCIL_FUNC(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_FUNC);
}




Handle<Value> GetGL_STENCIL_VALUE_MASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_VALUE_MASK);
}




Handle<Value> GetGL_STENCIL_FAIL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_FAIL);
}




Handle<Value> GetGL_STENCIL_PASS_DEPTH_FAIL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_PASS_DEPTH_FAIL);
}




Handle<Value> GetGL_STENCIL_PASS_DEPTH_PASS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_PASS_DEPTH_PASS);
}




Handle<Value> GetGL_STENCIL_REF(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_REF);
}




Handle<Value> GetGL_STENCIL_WRITEMASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_WRITEMASK);
}




Handle<Value> GetGL_STENCIL_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_INDEX);
}




Handle<Value> GetGL_KEEP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_KEEP);
}




Handle<Value> GetGL_REPLACE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REPLACE);
}




Handle<Value> GetGL_INCR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INCR);
}




Handle<Value> GetGL_DECR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DECR);
}




Handle<Value> GetGL_NONE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NONE);
}




Handle<Value> GetGL_LEFT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LEFT);
}




Handle<Value> GetGL_RIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RIGHT);
}




Handle<Value> GetGL_FRONT_LEFT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT_LEFT);
}




Handle<Value> GetGL_FRONT_RIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT_RIGHT);
}




Handle<Value> GetGL_BACK_LEFT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BACK_LEFT);
}




Handle<Value> GetGL_BACK_RIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BACK_RIGHT);
}




Handle<Value> GetGL_AUX0(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX0);
}




Handle<Value> GetGL_AUX1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX1);
}




Handle<Value> GetGL_AUX2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX2);
}




Handle<Value> GetGL_AUX3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX3);
}




Handle<Value> GetGL_COLOR_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_INDEX);
}




Handle<Value> GetGL_RED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RED);
}




Handle<Value> GetGL_GREEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREEN);
}




Handle<Value> GetGL_BLUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLUE);
}




Handle<Value> GetGL_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA);
}




Handle<Value> GetGL_LUMINANCE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE);
}




Handle<Value> GetGL_LUMINANCE_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE_ALPHA);
}




Handle<Value> GetGL_ALPHA_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_BITS);
}




Handle<Value> GetGL_RED_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RED_BITS);
}




Handle<Value> GetGL_GREEN_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREEN_BITS);
}




Handle<Value> GetGL_BLUE_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLUE_BITS);
}




Handle<Value> GetGL_INDEX_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_BITS);
}




Handle<Value> GetGL_SUBPIXEL_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SUBPIXEL_BITS);
}




Handle<Value> GetGL_AUX_BUFFERS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX_BUFFERS);
}




Handle<Value> GetGL_READ_BUFFER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_READ_BUFFER);
}




Handle<Value> GetGL_DRAW_BUFFER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DRAW_BUFFER);
}




Handle<Value> GetGL_DOUBLEBUFFER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOUBLEBUFFER);
}




Handle<Value> GetGL_STEREO(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STEREO);
}




Handle<Value> GetGL_BITMAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BITMAP);
}




Handle<Value> GetGL_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR);
}




Handle<Value> GetGL_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH);
}




Handle<Value> GetGL_STENCIL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL);
}




Handle<Value> GetGL_DITHER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DITHER);
}




Handle<Value> GetGL_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB);
}




Handle<Value> GetGL_RGBA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA);
}




Handle<Value> GetGL_MAX_LIST_NESTING(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_LIST_NESTING);
}




Handle<Value> GetGL_MAX_EVAL_ORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_EVAL_ORDER);
}




Handle<Value> GetGL_MAX_LIGHTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_LIGHTS);
}




Handle<Value> GetGL_MAX_CLIP_PLANES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CLIP_PLANES);
}




Handle<Value> GetGL_MAX_TEXTURE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_TEXTURE_SIZE);
}




Handle<Value> GetGL_MAX_PIXEL_MAP_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_PIXEL_MAP_TABLE);
}




Handle<Value> GetGL_MAX_ATTRIB_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_ATTRIB_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_MODELVIEW_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_MODELVIEW_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_NAME_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_NAME_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_PROJECTION_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_PROJECTION_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_TEXTURE_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_TEXTURE_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_VIEWPORT_DIMS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_VIEWPORT_DIMS);
}




Handle<Value> GetGL_MAX_CLIENT_ATTRIB_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CLIENT_ATTRIB_STACK_DEPTH);
}




Handle<Value> GetGL_ATTRIB_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ATTRIB_STACK_DEPTH);
}




Handle<Value> GetGL_CLIENT_ATTRIB_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_ATTRIB_STACK_DEPTH);
}




Handle<Value> GetGL_COLOR_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_CLEAR_VALUE);
}




Handle<Value> GetGL_COLOR_WRITEMASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_WRITEMASK);
}




Handle<Value> GetGL_CURRENT_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_INDEX);
}




Handle<Value> GetGL_CURRENT_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_COLOR);
}




Handle<Value> GetGL_CURRENT_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_NORMAL);
}




Handle<Value> GetGL_CURRENT_RASTER_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_COLOR);
}




Handle<Value> GetGL_CURRENT_RASTER_DISTANCE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_DISTANCE);
}




Handle<Value> GetGL_CURRENT_RASTER_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_INDEX);
}




Handle<Value> GetGL_CURRENT_RASTER_POSITION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_POSITION);
}




Handle<Value> GetGL_CURRENT_RASTER_TEXTURE_COORDS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_TEXTURE_COORDS);
}




Handle<Value> GetGL_CURRENT_RASTER_POSITION_VALID(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_POSITION_VALID);
}




Handle<Value> GetGL_CURRENT_TEXTURE_COORDS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_TEXTURE_COORDS);
}




Handle<Value> GetGL_INDEX_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_CLEAR_VALUE);
}




Handle<Value> GetGL_INDEX_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_MODE);
}




Handle<Value> GetGL_INDEX_WRITEMASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_WRITEMASK);
}




Handle<Value> GetGL_MODELVIEW_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MODELVIEW_MATRIX);
}




Handle<Value> GetGL_MODELVIEW_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MODELVIEW_STACK_DEPTH);
}




Handle<Value> GetGL_NAME_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NAME_STACK_DEPTH);
}




Handle<Value> GetGL_PROJECTION_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROJECTION_MATRIX);
}




Handle<Value> GetGL_PROJECTION_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROJECTION_STACK_DEPTH);
}




Handle<Value> GetGL_RENDER_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RENDER_MODE);
}




Handle<Value> GetGL_RGBA_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA_MODE);
}




Handle<Value> GetGL_TEXTURE_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MATRIX);
}




Handle<Value> GetGL_TEXTURE_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_STACK_DEPTH);
}




Handle<Value> GetGL_VIEWPORT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VIEWPORT);
}




Handle<Value> GetGL_AUTO_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUTO_NORMAL);
}




Handle<Value> GetGL_MAP1_COLOR_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_COLOR_4);
}




Handle<Value> GetGL_MAP1_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_INDEX);
}




Handle<Value> GetGL_MAP1_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_NORMAL);
}




Handle<Value> GetGL_MAP1_TEXTURE_COORD_1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_TEXTURE_COORD_1);
}




Handle<Value> GetGL_MAP1_TEXTURE_COORD_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_TEXTURE_COORD_2);
}




Handle<Value> GetGL_MAP1_TEXTURE_COORD_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_TEXTURE_COORD_3);
}




Handle<Value> GetGL_MAP1_TEXTURE_COORD_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_TEXTURE_COORD_4);
}




Handle<Value> GetGL_MAP1_VERTEX_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_VERTEX_3);
}




Handle<Value> GetGL_MAP1_VERTEX_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_VERTEX_4);
}




Handle<Value> GetGL_MAP2_COLOR_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_COLOR_4);
}




Handle<Value> GetGL_MAP2_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_INDEX);
}




Handle<Value> GetGL_MAP2_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_NORMAL);
}




Handle<Value> GetGL_MAP2_TEXTURE_COORD_1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_TEXTURE_COORD_1);
}




Handle<Value> GetGL_MAP2_TEXTURE_COORD_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_TEXTURE_COORD_2);
}




Handle<Value> GetGL_MAP2_TEXTURE_COORD_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_TEXTURE_COORD_3);
}




Handle<Value> GetGL_MAP2_TEXTURE_COORD_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_TEXTURE_COORD_4);
}




Handle<Value> GetGL_MAP2_VERTEX_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_VERTEX_3);
}




Handle<Value> GetGL_MAP2_VERTEX_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_VERTEX_4);
}




Handle<Value> GetGL_MAP1_GRID_DOMAIN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_GRID_DOMAIN);
}




Handle<Value> GetGL_MAP1_GRID_SEGMENTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_GRID_SEGMENTS);
}




Handle<Value> GetGL_MAP2_GRID_DOMAIN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_GRID_DOMAIN);
}




Handle<Value> GetGL_MAP2_GRID_SEGMENTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_GRID_SEGMENTS);
}




Handle<Value> GetGL_COEFF(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COEFF);
}




Handle<Value> GetGL_ORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ORDER);
}




Handle<Value> GetGL_DOMAIN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOMAIN);
}




Handle<Value> GetGL_PERSPECTIVE_CORRECTION_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PERSPECTIVE_CORRECTION_HINT);
}




Handle<Value> GetGL_POINT_SMOOTH_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SMOOTH_HINT);
}




Handle<Value> GetGL_LINE_SMOOTH_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_SMOOTH_HINT);
}




Handle<Value> GetGL_POLYGON_SMOOTH_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_SMOOTH_HINT);
}




Handle<Value> GetGL_FOG_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_HINT);
}




Handle<Value> GetGL_DONT_CARE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DONT_CARE);
}




Handle<Value> GetGL_FASTEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FASTEST);
}




Handle<Value> GetGL_NICEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NICEST);
}




Handle<Value> GetGL_SCISSOR_BOX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SCISSOR_BOX);
}




Handle<Value> GetGL_SCISSOR_TEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SCISSOR_TEST);
}




Handle<Value> GetGL_MAP_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP_COLOR);
}




Handle<Value> GetGL_MAP_STENCIL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP_STENCIL);
}




Handle<Value> GetGL_INDEX_SHIFT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_SHIFT);
}




Handle<Value> GetGL_INDEX_OFFSET(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_OFFSET);
}




Handle<Value> GetGL_RED_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RED_SCALE);
}




Handle<Value> GetGL_RED_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RED_BIAS);
}




Handle<Value> GetGL_GREEN_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREEN_SCALE);
}




Handle<Value> GetGL_GREEN_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREEN_BIAS);
}




Handle<Value> GetGL_BLUE_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLUE_SCALE);
}




Handle<Value> GetGL_BLUE_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLUE_BIAS);
}




Handle<Value> GetGL_ALPHA_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_SCALE);
}




Handle<Value> GetGL_ALPHA_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_BIAS);
}




Handle<Value> GetGL_DEPTH_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_SCALE);
}




Handle<Value> GetGL_DEPTH_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_BIAS);
}




Handle<Value> GetGL_PIXEL_MAP_S_TO_S_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_S_TO_S_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_I_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_I_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_R_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_R_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_G_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_G_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_B_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_B_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_A_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_A_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_R_TO_R_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_R_TO_R_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_G_TO_G_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_G_TO_G_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_B_TO_B_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_B_TO_B_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_A_TO_A_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_A_TO_A_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_S_TO_S(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_S_TO_S);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_I(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_I);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_R);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_G(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_G);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_B(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_B);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_A(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_A);
}




Handle<Value> GetGL_PIXEL_MAP_R_TO_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_R_TO_R);
}




Handle<Value> GetGL_PIXEL_MAP_G_TO_G(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_G_TO_G);
}




Handle<Value> GetGL_PIXEL_MAP_B_TO_B(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_B_TO_B);
}




Handle<Value> GetGL_PIXEL_MAP_A_TO_A(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_A_TO_A);
}




Handle<Value> GetGL_PACK_ALIGNMENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_ALIGNMENT);
}




Handle<Value> GetGL_PACK_LSB_FIRST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_LSB_FIRST);
}




Handle<Value> GetGL_PACK_ROW_LENGTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_ROW_LENGTH);
}




Handle<Value> GetGL_PACK_SKIP_PIXELS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_SKIP_PIXELS);
}




Handle<Value> GetGL_PACK_SKIP_ROWS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_SKIP_ROWS);
}




Handle<Value> GetGL_PACK_SWAP_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_SWAP_BYTES);
}




Handle<Value> GetGL_UNPACK_ALIGNMENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_ALIGNMENT);
}




Handle<Value> GetGL_UNPACK_LSB_FIRST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_LSB_FIRST);
}




Handle<Value> GetGL_UNPACK_ROW_LENGTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_ROW_LENGTH);
}




Handle<Value> GetGL_UNPACK_SKIP_PIXELS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_SKIP_PIXELS);
}




Handle<Value> GetGL_UNPACK_SKIP_ROWS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_SKIP_ROWS);
}




Handle<Value> GetGL_UNPACK_SWAP_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_SWAP_BYTES);
}




Handle<Value> GetGL_ZOOM_X(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ZOOM_X);
}




Handle<Value> GetGL_ZOOM_Y(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ZOOM_Y);
}




Handle<Value> GetGL_TEXTURE_ENV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_ENV);
}




Handle<Value> GetGL_TEXTURE_ENV_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_ENV_MODE);
}




Handle<Value> GetGL_TEXTURE_1D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_1D);
}




Handle<Value> GetGL_TEXTURE_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_2D);
}




Handle<Value> GetGL_TEXTURE_WRAP_S(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_WRAP_S);
}




Handle<Value> GetGL_TEXTURE_WRAP_T(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_WRAP_T);
}




Handle<Value> GetGL_TEXTURE_MAG_FILTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MAG_FILTER);
}




Handle<Value> GetGL_TEXTURE_MIN_FILTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MIN_FILTER);
}




Handle<Value> GetGL_TEXTURE_ENV_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_ENV_COLOR);
}




Handle<Value> GetGL_TEXTURE_GEN_S(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_S);
}




Handle<Value> GetGL_TEXTURE_GEN_T(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_T);
}




Handle<Value> GetGL_TEXTURE_GEN_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_MODE);
}




Handle<Value> GetGL_TEXTURE_BORDER_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BORDER_COLOR);
}




Handle<Value> GetGL_TEXTURE_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_WIDTH);
}




Handle<Value> GetGL_TEXTURE_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_HEIGHT);
}




Handle<Value> GetGL_TEXTURE_BORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BORDER);
}




Handle<Value> GetGL_TEXTURE_COMPONENTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COMPONENTS);
}




Handle<Value> GetGL_TEXTURE_RED_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_RED_SIZE);
}




Handle<Value> GetGL_TEXTURE_GREEN_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GREEN_SIZE);
}




Handle<Value> GetGL_TEXTURE_BLUE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BLUE_SIZE);
}




Handle<Value> GetGL_TEXTURE_ALPHA_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_ALPHA_SIZE);
}




Handle<Value> GetGL_TEXTURE_LUMINANCE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_LUMINANCE_SIZE);
}




Handle<Value> GetGL_TEXTURE_INTENSITY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_INTENSITY_SIZE);
}




Handle<Value> GetGL_NEAREST_MIPMAP_NEAREST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NEAREST_MIPMAP_NEAREST);
}




Handle<Value> GetGL_NEAREST_MIPMAP_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NEAREST_MIPMAP_LINEAR);
}




Handle<Value> GetGL_LINEAR_MIPMAP_NEAREST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINEAR_MIPMAP_NEAREST);
}




Handle<Value> GetGL_LINEAR_MIPMAP_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINEAR_MIPMAP_LINEAR);
}




Handle<Value> GetGL_OBJECT_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OBJECT_LINEAR);
}




Handle<Value> GetGL_OBJECT_PLANE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OBJECT_PLANE);
}




Handle<Value> GetGL_EYE_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EYE_LINEAR);
}




Handle<Value> GetGL_EYE_PLANE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EYE_PLANE);
}




Handle<Value> GetGL_SPHERE_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPHERE_MAP);
}




Handle<Value> GetGL_DECAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DECAL);
}




Handle<Value> GetGL_MODULATE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MODULATE);
}




Handle<Value> GetGL_NEAREST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NEAREST);
}




Handle<Value> GetGL_REPEAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REPEAT);
}




Handle<Value> GetGL_CLAMP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLAMP);
}




Handle<Value> GetGL_S(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_S);
}




Handle<Value> GetGL_T(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T);
}




Handle<Value> GetGL_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_R);
}




Handle<Value> GetGL_Q(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_Q);
}




Handle<Value> GetGL_TEXTURE_GEN_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_R);
}




Handle<Value> GetGL_TEXTURE_GEN_Q(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_Q);
}




Handle<Value> GetGL_VENDOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VENDOR);
}




Handle<Value> GetGL_RENDERER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RENDERER);
}




Handle<Value> GetGL_VERSION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERSION);
}




Handle<Value> GetGL_EXTENSIONS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EXTENSIONS);
}




Handle<Value> GetGL_NO_ERROR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NO_ERROR);
}




Handle<Value> GetGL_INVALID_ENUM(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INVALID_ENUM);
}




Handle<Value> GetGL_INVALID_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INVALID_VALUE);
}




Handle<Value> GetGL_STACK_OVERFLOW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STACK_OVERFLOW);
}




Handle<Value> GetGL_STACK_UNDERFLOW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STACK_UNDERFLOW);
}




Handle<Value> GetGL_OUT_OF_MEMORY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OUT_OF_MEMORY);
}




Handle<Value> GetGL_CURRENT_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_BIT);
}




Handle<Value> GetGL_POINT_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_BIT);
}




Handle<Value> GetGL_LINE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_BIT);
}




Handle<Value> GetGL_POLYGON_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_BIT);
}




Handle<Value> GetGL_POLYGON_STIPPLE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_STIPPLE_BIT);
}




Handle<Value> GetGL_PIXEL_MODE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MODE_BIT);
}




Handle<Value> GetGL_LIGHTING_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHTING_BIT);
}




Handle<Value> GetGL_FOG_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_BIT);
}




Handle<Value> GetGL_DEPTH_BUFFER_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_BUFFER_BIT);
}




Handle<Value> GetGL_ACCUM_BUFFER_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_BUFFER_BIT);
}




Handle<Value> GetGL_STENCIL_BUFFER_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_BUFFER_BIT);
}




Handle<Value> GetGL_VIEWPORT_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VIEWPORT_BIT);
}




Handle<Value> GetGL_TRANSFORM_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSFORM_BIT);
}




Handle<Value> GetGL_ENABLE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ENABLE_BIT);
}




Handle<Value> GetGL_COLOR_BUFFER_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_BUFFER_BIT);
}




Handle<Value> GetGL_HINT_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HINT_BIT);
}




Handle<Value> GetGL_EVAL_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EVAL_BIT);
}




Handle<Value> GetGL_LIST_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIST_BIT);
}




Handle<Value> GetGL_TEXTURE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BIT);
}




Handle<Value> GetGL_SCISSOR_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SCISSOR_BIT);
}




Handle<Value> GetGL_ALL_ATTRIB_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALL_ATTRIB_BITS);
}




Handle<Value> GetGL_PROXY_TEXTURE_1D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_1D);
}




Handle<Value> GetGL_PROXY_TEXTURE_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_2D);
}




Handle<Value> GetGL_TEXTURE_PRIORITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_PRIORITY);
}




Handle<Value> GetGL_TEXTURE_RESIDENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_RESIDENT);
}




Handle<Value> GetGL_TEXTURE_BINDING_1D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_1D);
}




Handle<Value> GetGL_TEXTURE_BINDING_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_2D);
}




Handle<Value> GetGL_TEXTURE_INTERNAL_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_INTERNAL_FORMAT);
}




Handle<Value> GetGL_ALPHA4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA4);
}




Handle<Value> GetGL_ALPHA8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA8);
}




Handle<Value> GetGL_ALPHA12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA12);
}




Handle<Value> GetGL_ALPHA16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA16);
}




Handle<Value> GetGL_LUMINANCE4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE4);
}




Handle<Value> GetGL_LUMINANCE8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE8);
}




Handle<Value> GetGL_LUMINANCE12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE12);
}




Handle<Value> GetGL_LUMINANCE16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE16);
}




Handle<Value> GetGL_LUMINANCE4_ALPHA4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE4_ALPHA4);
}




Handle<Value> GetGL_LUMINANCE6_ALPHA2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE6_ALPHA2);
}




Handle<Value> GetGL_LUMINANCE8_ALPHA8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE8_ALPHA8);
}




Handle<Value> GetGL_LUMINANCE12_ALPHA4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE12_ALPHA4);
}




Handle<Value> GetGL_LUMINANCE12_ALPHA12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE12_ALPHA12);
}




Handle<Value> GetGL_LUMINANCE16_ALPHA16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE16_ALPHA16);
}




Handle<Value> GetGL_INTENSITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY);
}




Handle<Value> GetGL_INTENSITY4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY4);
}




Handle<Value> GetGL_INTENSITY8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY8);
}




Handle<Value> GetGL_INTENSITY12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY12);
}




Handle<Value> GetGL_INTENSITY16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY16);
}




Handle<Value> GetGL_R3_G3_B2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_R3_G3_B2);
}




Handle<Value> GetGL_RGB4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB4);
}




Handle<Value> GetGL_RGB5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB5);
}




Handle<Value> GetGL_RGB8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB8);
}




Handle<Value> GetGL_RGB10(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB10);
}




Handle<Value> GetGL_RGB12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB12);
}




Handle<Value> GetGL_RGB16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB16);
}




Handle<Value> GetGL_RGBA2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA2);
}




Handle<Value> GetGL_RGBA4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA4);
}




Handle<Value> GetGL_RGB5_A1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB5_A1);
}




Handle<Value> GetGL_RGBA8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA8);
}




Handle<Value> GetGL_RGB10_A2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB10_A2);
}




Handle<Value> GetGL_RGBA12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA12);
}




Handle<Value> GetGL_RGBA16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA16);
}




Handle<Value> GetGL_CLIENT_PIXEL_STORE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_PIXEL_STORE_BIT);
}




Handle<Value> GetGL_CLIENT_VERTEX_ARRAY_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_VERTEX_ARRAY_BIT);
}




Handle<Value> GetGL_ALL_CLIENT_ATTRIB_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALL_CLIENT_ATTRIB_BITS);
}




Handle<Value> GetGL_CLIENT_ALL_ATTRIB_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_ALL_ATTRIB_BITS);
}




Handle<Value> GLglClearIndexCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glClearIndex((GLfloat) arg0);
  return v8::Undefined();
}




Handle<Value> GLglClearColorCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glClearColor((GLclampf) arg0, (GLclampf) arg1, (GLclampf) arg2, (GLclampf) arg3);
  return v8::Undefined();
}




Handle<Value> GLglClearCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glClear((GLbitfield) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexMaskCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glIndexMask((GLuint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColorMaskCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glColorMask((GLboolean) arg0, (GLboolean) arg1, (GLboolean) arg2, (GLboolean) arg3);
  return v8::Undefined();
}




Handle<Value> GLglAlphaFuncCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glAlphaFunc((GLenum) arg0, (GLclampf) arg1);
  return v8::Undefined();
}




Handle<Value> GLglBlendFuncCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glBlendFunc((GLenum) arg0, (GLenum) arg1);
  return v8::Undefined();
}




Handle<Value> GLglLogicOpCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glLogicOp((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglCullFaceCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glCullFace((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglFrontFaceCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glFrontFace((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglPointSizeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glPointSize((GLfloat) arg0);
  return v8::Undefined();
}




Handle<Value> GLglLineWidthCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glLineWidth((GLfloat) arg0);
  return v8::Undefined();
}




Handle<Value> GLglLineStippleCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  unsigned int arg1 = args[1]->Uint32Value();

  //make call
  glLineStipple((GLint) arg0, (GLushort) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPolygonModeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glPolygonMode((GLenum) arg0, (GLenum) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPolygonOffsetCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glPolygonOffset((GLfloat) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPolygonStippleCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLubyte* arg0 = new  GLubyte[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLubyte aux = ( GLubyte)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glPolygonStipple((const GLubyte*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglGetPolygonStippleCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLubyte* arg0 = new GLubyte[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLubyte aux = (GLubyte)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glGetPolygonStipple((GLubyte*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEdgeFlagCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glEdgeFlag((GLboolean) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEdgeFlagvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLboolean* arg0 = new  GLboolean[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLboolean aux = ( GLboolean)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glEdgeFlagv((const GLboolean*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglScissorCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glScissor((GLint) arg0, (GLint) arg1, (GLsizei) arg2, (GLsizei) arg3);
  return v8::Undefined();
}




Handle<Value> GLglClipPlaneCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glClipPlane((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglGetClipPlaneCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble* arg1 = new GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble aux = (GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGetClipPlane((GLenum) arg0, (GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglDrawBufferCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glDrawBuffer((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglReadBufferCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glReadBuffer((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEnableCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glEnable((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglDisableCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glDisable((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIsEnabledCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glIsEnabled((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEnableClientStateCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glEnableClientState((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglDisableClientStateCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glDisableClientState((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglGetBooleanvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLboolean* arg1 = new GLboolean[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLboolean aux = (GLboolean)arg->Uint32Value();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGetBooleanv((GLenum) arg0, (GLboolean*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglGetDoublevCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble* arg1 = new GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble aux = (GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGetDoublev((GLenum) arg0, (GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglGetFloatvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat* arg1 = new GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGetFloatv((GLenum) arg0, (GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglGetIntegervCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint* arg1 = new GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGetIntegerv((GLenum) arg0, (GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPushAttribCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glPushAttrib((GLbitfield) arg0);
  return v8::Undefined();
}




Handle<Value> GLglPopAttribCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPopAttrib();
  return v8::Undefined();
}




Handle<Value> GLglPushClientAttribCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glPushClientAttrib((GLbitfield) arg0);
  return v8::Undefined();
}




Handle<Value> GLglPopClientAttribCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPopClientAttrib();
  return v8::Undefined();
}




Handle<Value> GLglRenderModeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glRenderMode((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglGetErrorCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glGetError();
  return v8::Undefined();
}




Handle<Value> GLglFinishCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glFinish();
  return v8::Undefined();
}




Handle<Value> GLglFlushCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glFlush();
  return v8::Undefined();
}




Handle<Value> GLglHintCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glHint((GLenum) arg0, (GLenum) arg1);
  return v8::Undefined();
}




Handle<Value> GLglClearDepthCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glClearDepth((GLclampd) arg0);
  return v8::Undefined();
}




Handle<Value> GLglDepthFuncCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glDepthFunc((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglDepthMaskCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glDepthMask((GLboolean) arg0);
  return v8::Undefined();
}




Handle<Value> GLglDepthRangeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glDepthRange((GLclampd) arg0, (GLclampd) arg1);
  return v8::Undefined();
}




Handle<Value> GLglClearAccumCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glClearAccum((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglAccumCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glAccum((GLenum) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMatrixModeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glMatrixMode((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglOrthoCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

  //make call
  glOrtho((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3, (GLdouble) arg4, (GLdouble) arg5);
  return v8::Undefined();
}




Handle<Value> GLglFrustumCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

  //make call
  glFrustum((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3, (GLdouble) arg4, (GLdouble) arg5);
  return v8::Undefined();
}




Handle<Value> GLglViewportCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glViewport((GLint) arg0, (GLint) arg1, (GLsizei) arg2, (GLsizei) arg3);
  return v8::Undefined();
}




Handle<Value> GLglPushMatrixCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPushMatrix();
  return v8::Undefined();
}




Handle<Value> GLglPopMatrixCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPopMatrix();
  return v8::Undefined();
}




Handle<Value> GLglLoadIdentityCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glLoadIdentity();
  return v8::Undefined();
}




Handle<Value> GLglLoadMatrixdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glLoadMatrixd((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglLoadMatrixfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glLoadMatrixf((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglMultMatrixdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glMultMatrixd((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglMultMatrixfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glMultMatrixf((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRotatedCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRotated((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRotatefCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRotatef((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglScaledCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glScaled((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglScalefCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glScalef((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTranslatedCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTranslated((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTranslatefCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTranslatef((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglIsListCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glIsList((GLuint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglDeleteListsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  int arg1 = args[1]->IntegerValue();

  //make call
  glDeleteLists((GLuint) arg0, (GLsizei) arg1);
  return v8::Undefined();
}




Handle<Value> GLglGenListsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glGenLists((GLsizei) arg0);
  return v8::Undefined();
}




Handle<Value> GLglNewListCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  int arg1 = args[1]->IntegerValue();

  //make call
  glNewList((GLuint) arg0, (GLenum) arg1);
  return v8::Undefined();
}




Handle<Value> GLglEndListCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glEndList();
  return v8::Undefined();
}




Handle<Value> GLglCallListCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glCallList((GLuint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglListBaseCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glListBase((GLuint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglBeginCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glBegin((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEndCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glEnd();
  return v8::Undefined();
}




Handle<Value> GLglVertex2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glVertex2d((GLdouble) arg0, (GLdouble) arg1);
  return v8::Undefined();
}




Handle<Value> GLglVertex2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glVertex2f((GLfloat) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglVertex2iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glVertex2i((GLint) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglVertex2sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glVertex2s((GLshort) arg0, (GLshort) arg1);
  return v8::Undefined();
}




Handle<Value> GLglVertex3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glVertex3d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglVertex3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glVertex3f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglVertex3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glVertex3i((GLint) arg0, (GLint) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglVertex3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glVertex3s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2);
  return v8::Undefined();
}




Handle<Value> GLglVertex4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glVertex4d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3);
  return v8::Undefined();
}




Handle<Value> GLglVertex4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glVertex4f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglVertex4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glVertex4i((GLint) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3);
  return v8::Undefined();
}




Handle<Value> GLglVertex4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glVertex4s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3);
  return v8::Undefined();
}




Handle<Value> GLglVertex2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex2dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex2fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex2ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex2iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex2svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex2sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex3dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex3fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex3iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex3sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex4dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex4fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex4iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglVertex4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glVertex4sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglNormal3bCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glNormal3b((GLbyte) arg0, (GLbyte) arg1, (GLbyte) arg2);
  return v8::Undefined();
}




Handle<Value> GLglNormal3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glNormal3d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglNormal3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glNormal3f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglNormal3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glNormal3i((GLint) arg0, (GLint) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglNormal3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glNormal3s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2);
  return v8::Undefined();
}




Handle<Value> GLglNormal3bvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLbyte* arg0 = new  GLbyte[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLbyte aux = ( GLbyte)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glNormal3bv((const GLbyte*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglNormal3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glNormal3dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglNormal3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glNormal3fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglNormal3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glNormal3iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglNormal3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glNormal3sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glIndexd((GLdouble) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glIndexf((GLfloat) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glIndexi((GLint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glIndexs((GLshort) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexubCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glIndexub((GLubyte) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexdvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glIndexdv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glIndexfv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glIndexiv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexsvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glIndexsv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglIndexubvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLubyte* arg0 = new  GLubyte[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLubyte aux = ( GLubyte)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glIndexubv((const GLubyte*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor3bCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glColor3b((GLbyte) arg0, (GLbyte) arg1, (GLbyte) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColor3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glColor3d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColor3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glColor3f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColor3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glColor3i((GLint) arg0, (GLint) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColor3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glColor3s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColor3ubCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glColor3ub((GLubyte) arg0, (GLubyte) arg1, (GLubyte) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColor3uiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glColor3ui((GLuint) arg0, (GLuint) arg1, (GLuint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColor3usCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glColor3us((GLushort) arg0, (GLushort) arg1, (GLushort) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColor4bCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glColor4b((GLbyte) arg0, (GLbyte) arg1, (GLbyte) arg2, (GLbyte) arg3);
  return v8::Undefined();
}




Handle<Value> GLglColor4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glColor4d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3);
  return v8::Undefined();
}




Handle<Value> GLglColor4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glColor4f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglColor4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glColor4i((GLint) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3);
  return v8::Undefined();
}




Handle<Value> GLglColor4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glColor4s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3);
  return v8::Undefined();
}




Handle<Value> GLglColor4ubCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glColor4ub((GLubyte) arg0, (GLubyte) arg1, (GLubyte) arg2, (GLubyte) arg3);
  return v8::Undefined();
}




Handle<Value> GLglColor4uiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glColor4ui((GLuint) arg0, (GLuint) arg1, (GLuint) arg2, (GLuint) arg3);
  return v8::Undefined();
}




Handle<Value> GLglColor4usCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glColor4us((GLushort) arg0, (GLushort) arg1, (GLushort) arg2, (GLushort) arg3);
  return v8::Undefined();
}




Handle<Value> GLglColor3bvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLbyte* arg0 = new  GLbyte[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLbyte aux = ( GLbyte)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor3bv((const GLbyte*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor3dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor3fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor3iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor3sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor3ubvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLubyte* arg0 = new  GLubyte[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLubyte aux = ( GLubyte)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor3ubv((const GLubyte*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor3uivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLuint* arg0 = new  GLuint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLuint aux = ( GLuint)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor3uiv((const GLuint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor3usvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLushort* arg0 = new  GLushort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLushort aux = ( GLushort)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor3usv((const GLushort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor4bvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLbyte* arg0 = new  GLbyte[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLbyte aux = ( GLbyte)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor4bv((const GLbyte*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor4dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor4fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor4iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor4sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor4ubvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLubyte* arg0 = new  GLubyte[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLubyte aux = ( GLubyte)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor4ubv((const GLubyte*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor4uivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLuint* arg0 = new  GLuint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLuint aux = ( GLuint)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor4uiv((const GLuint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglColor4usvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLushort* arg0 = new  GLushort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLushort aux = ( GLushort)arg->Uint32Value();
      arg0[j] = aux; 
  }
    
    
  //make call
  glColor4usv((const GLushort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glTexCoord1d((GLdouble) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glTexCoord1f((GLfloat) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord1iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glTexCoord1i((GLint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord1sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glTexCoord1s((GLshort) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glTexCoord2d((GLdouble) arg0, (GLdouble) arg1);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glTexCoord2f((GLfloat) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord2iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glTexCoord2i((GLint) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord2sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glTexCoord2s((GLshort) arg0, (GLshort) arg1);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexCoord3d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexCoord3f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexCoord3i((GLint) arg0, (GLint) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexCoord3s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glTexCoord4d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glTexCoord4f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glTexCoord4i((GLint) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glTexCoord4s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord1dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord1dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord1fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord1fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord1ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord1iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord1svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord1sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord2dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord2fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord2ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord2iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord2svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord2sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord3dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord3fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord3iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord3sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord4dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord4fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord4iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexCoord4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glTexCoord4sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glRasterPos2d((GLdouble) arg0, (GLdouble) arg1);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glRasterPos2f((GLfloat) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos2iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glRasterPos2i((GLint) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos2sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glRasterPos2s((GLshort) arg0, (GLshort) arg1);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glRasterPos3d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glRasterPos3f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glRasterPos3i((GLint) arg0, (GLint) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glRasterPos3s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRasterPos4d((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRasterPos4f((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glRasterPos4i((GLint) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glRasterPos4s((GLshort) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos2dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos2fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos2ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos2iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos2svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos2sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos3dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos3fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos3iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos3sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos4dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos4fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos4iv((const GLint*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRasterPos4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glRasterPos4sv((const GLshort*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglRectdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRectd((GLdouble) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRectfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRectf((GLfloat) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRectiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glRecti((GLint) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRectsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glRects((GLshort) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3);
  return v8::Undefined();
}




Handle<Value> GLglRectdvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glRectdv((const GLdouble*) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglRectfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glRectfv((const GLfloat*) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglRectivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLint* arg0 = new  GLint[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glRectiv((const GLint*) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglRectsvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLshort* arg0 = new  GLshort[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg0[j] = aux; 
  }
    
    
    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glRectsv((const GLshort*) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglArrayElementCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glArrayElement((GLint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglDrawArraysCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glDrawArrays((GLenum) arg0, (GLint) arg1, (GLsizei) arg2);
  return v8::Undefined();
}




Handle<Value> GLglShadeModelCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glShadeModel((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglLightfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glLightf((GLenum) arg0, (GLenum) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglLightiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glLighti((GLenum) arg0, (GLenum) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglLightfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLfloat* arg2 = new  GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glLightfv((GLenum) arg0, (GLenum) arg1, (const GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglLightivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLint* arg2 = new  GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glLightiv((GLenum) arg0, (GLenum) arg1, (const GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetLightfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetLightfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetLightivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetLightiv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglLightModelfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glLightModelf((GLenum) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglLightModeliCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glLightModeli((GLenum) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglLightModelfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glLightModelfv((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglLightModelivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glLightModeliv((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMaterialfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMaterialf((GLenum) arg0, (GLenum) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMaterialiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMateriali((GLenum) arg0, (GLenum) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMaterialfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLfloat* arg2 = new  GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glMaterialfv((GLenum) arg0, (GLenum) arg1, (const GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMaterialivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLint* arg2 = new  GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glMaterialiv((GLenum) arg0, (GLenum) arg1, (const GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetMaterialfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetMaterialfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetMaterialivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetMaterialiv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColorMaterialCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glColorMaterial((GLenum) arg0, (GLenum) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPixelZoomCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glPixelZoom((GLfloat) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPixelStorefCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glPixelStoref((GLenum) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPixelStoreiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glPixelStorei((GLenum) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPixelTransferfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glPixelTransferf((GLenum) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPixelTransferiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glPixelTransferi((GLenum) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPixelMapfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLfloat* arg2 = new  GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glPixelMapfv((GLenum) arg0, (GLsizei) arg1, (const GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglPixelMapuivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLuint* arg2 = new  GLuint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLuint aux = ( GLuint)arg->Uint32Value();
      arg2[j] = aux; 
  }
    
    
  //make call
  glPixelMapuiv((GLenum) arg0, (GLsizei) arg1, (const GLuint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglPixelMapusvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLushort* arg2 = new  GLushort[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLushort aux = ( GLushort)arg->Uint32Value();
      arg2[j] = aux; 
  }
    
    
  //make call
  glPixelMapusv((GLenum) arg0, (GLsizei) arg1, (const GLushort*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetPixelMapfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat* arg1 = new GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGetPixelMapfv((GLenum) arg0, (GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglGetPixelMapuivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLuint* arg1 = new GLuint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLuint aux = (GLuint)arg->Uint32Value();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGetPixelMapuiv((GLenum) arg0, (GLuint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglGetPixelMapusvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLushort* arg1 = new GLushort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLushort aux = (GLushort)arg->Uint32Value();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGetPixelMapusv((GLenum) arg0, (GLushort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglBitmapCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 7) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

    
  Handle<Array> arrHandle6 = Handle<Array>::Cast(args[6]);
   GLubyte* arg6 = new  GLubyte[arrHandle6->Length()];
  for (unsigned j = 0; j < arrHandle6->Length(); j++) {
      Handle<Value> arg(arrHandle6->Get(Integer::New(j)));
       GLubyte aux = ( GLubyte)arg->Uint32Value();
      arg6[j] = aux; 
  }
    
    
  //make call
  glBitmap((GLsizei) arg0, (GLsizei) arg1, (GLfloat) arg2, (GLfloat) arg3, (GLfloat) arg4, (GLfloat) arg5, (const GLubyte*) arg6);
  return v8::Undefined();
}




Handle<Value> GLglCopyPixelsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glCopyPixels((GLint) arg0, (GLint) arg1, (GLsizei) arg2, (GLsizei) arg3, (GLenum) arg4);
  return v8::Undefined();
}




Handle<Value> GLglStencilFuncCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glStencilFunc((GLenum) arg0, (GLint) arg1, (GLuint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglStencilMaskCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glStencilMask((GLuint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglStencilOpCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glStencilOp((GLenum) arg0, (GLenum) arg1, (GLenum) arg2);
  return v8::Undefined();
}




Handle<Value> GLglClearStencilCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glClearStencil((GLint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglTexGendCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexGend((GLenum) arg0, (GLenum) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexGenfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexGenf((GLenum) arg0, (GLenum) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexGeniCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexGeni((GLenum) arg0, (GLenum) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexGendvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLdouble* arg2 = new  GLdouble[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glTexGendv((GLenum) arg0, (GLenum) arg1, (const GLdouble*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexGenfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLfloat* arg2 = new  GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glTexGenfv((GLenum) arg0, (GLenum) arg1, (const GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexGenivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLint* arg2 = new  GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glTexGeniv((GLenum) arg0, (GLenum) arg1, (const GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetTexGendvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLdouble* arg2 = new GLdouble[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLdouble aux = (GLdouble)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetTexGendv((GLenum) arg0, (GLenum) arg1, (GLdouble*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetTexGenfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetTexGenfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetTexGenivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetTexGeniv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexEnvfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexEnvf((GLenum) arg0, (GLenum) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexEnviCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexEnvi((GLenum) arg0, (GLenum) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexEnvfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLfloat* arg2 = new  GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glTexEnvfv((GLenum) arg0, (GLenum) arg1, (const GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexEnvivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLint* arg2 = new  GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glTexEnviv((GLenum) arg0, (GLenum) arg1, (const GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetTexEnvfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetTexEnvfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetTexEnvivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetTexEnviv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexParameterfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexParameterf((GLenum) arg0, (GLenum) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexParameteriCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexParameteri((GLenum) arg0, (GLenum) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLfloat* arg2 = new  GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glTexParameterfv((GLenum) arg0, (GLenum) arg1, (const GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglTexParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLint* arg2 = new  GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glTexParameteriv((GLenum) arg0, (GLenum) arg1, (const GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetTexParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetTexParameterfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetTexParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetTexParameteriv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetTexLevelParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

    
  Handle<Array> arrHandle3 = Handle<Array>::Cast(args[3]);
  GLfloat* arg3 = new GLfloat[arrHandle3->Length()];
  for (unsigned j = 0; j < arrHandle3->Length(); j++) {
      Handle<Value> arg(arrHandle3->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg3[j] = aux; 
  }
    
    
  //make call
  glGetTexLevelParameterfv((GLenum) arg0, (GLint) arg1, (GLenum) arg2, (GLfloat*) arg3);
  return v8::Undefined();
}




Handle<Value> GLglGetTexLevelParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

    
  Handle<Array> arrHandle3 = Handle<Array>::Cast(args[3]);
  GLint* arg3 = new GLint[arrHandle3->Length()];
  for (unsigned j = 0; j < arrHandle3->Length(); j++) {
      Handle<Value> arg(arrHandle3->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg3[j] = aux; 
  }
    
    
  //make call
  glGetTexLevelParameteriv((GLenum) arg0, (GLint) arg1, (GLenum) arg2, (GLint*) arg3);
  return v8::Undefined();
}




Handle<Value> GLglGenTexturesCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLuint* arg1 = new GLuint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLuint aux = (GLuint)arg->Uint32Value();
      arg1[j] = aux; 
  }
    
    
  //make call
  glGenTextures((GLsizei) arg0, (GLuint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglDeleteTexturesCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLuint* arg1 = new  GLuint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLuint aux = ( GLuint)arg->Uint32Value();
      arg1[j] = aux; 
  }
    
    
  //make call
  glDeleteTextures((GLsizei) arg0, (const GLuint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglBindTextureCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  unsigned int arg1 = args[1]->Uint32Value();

  //make call
  glBindTexture((GLenum) arg0, (GLuint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglPrioritizeTexturesCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLuint* arg1 = new  GLuint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLuint aux = ( GLuint)arg->Uint32Value();
      arg1[j] = aux; 
  }
    
    
    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLclampf* arg2 = new  GLclampf[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLclampf aux = ( GLclampf)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glPrioritizeTextures((GLsizei) arg0, (const GLuint*) arg1, (const GLclampf*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglAreTexturesResidentCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLuint* arg1 = new  GLuint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLuint aux = ( GLuint)arg->Uint32Value();
      arg1[j] = aux; 
  }
    
    
    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLboolean* arg2 = new GLboolean[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLboolean aux = (GLboolean)arg->Uint32Value();
      arg2[j] = aux; 
  }
    
    
  //make call
  glAreTexturesResident((GLsizei) arg0, (const GLuint*) arg1, (GLboolean*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglIsTextureCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glIsTexture((GLuint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglCopyTexImage1DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 7) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();
  int arg6 = args[6]->IntegerValue();

  //make call
  glCopyTexImage1D((GLenum) arg0, (GLint) arg1, (GLenum) arg2, (GLint) arg3, (GLint) arg4, (GLsizei) arg5, (GLint) arg6);
  return v8::Undefined();
}




Handle<Value> GLglCopyTexImage2DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 8) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();
  int arg6 = args[6]->IntegerValue();
  int arg7 = args[7]->IntegerValue();

  //make call
  glCopyTexImage2D((GLenum) arg0, (GLint) arg1, (GLenum) arg2, (GLint) arg3, (GLint) arg4, (GLsizei) arg5, (GLsizei) arg6, (GLint) arg7);
  return v8::Undefined();
}




Handle<Value> GLglCopyTexSubImage1DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();

  //make call
  glCopyTexSubImage1D((GLenum) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3, (GLint) arg4, (GLsizei) arg5);
  return v8::Undefined();
}




Handle<Value> GLglCopyTexSubImage2DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 8) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();
  int arg6 = args[6]->IntegerValue();
  int arg7 = args[7]->IntegerValue();

  //make call
  glCopyTexSubImage2D((GLenum) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3, (GLint) arg4, (GLint) arg5, (GLsizei) arg6, (GLsizei) arg7);
  return v8::Undefined();
}




Handle<Value> GLglMap1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

    
  Handle<Array> arrHandle5 = Handle<Array>::Cast(args[5]);
   GLdouble* arg5 = new  GLdouble[arrHandle5->Length()];
  for (unsigned j = 0; j < arrHandle5->Length(); j++) {
      Handle<Value> arg(arrHandle5->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg5[j] = aux; 
  }
    
    
  //make call
  glMap1d((GLenum) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLint) arg3, (GLint) arg4, (const GLdouble*) arg5);
  return v8::Undefined();
}




Handle<Value> GLglMap1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

    
  Handle<Array> arrHandle5 = Handle<Array>::Cast(args[5]);
   GLfloat* arg5 = new  GLfloat[arrHandle5->Length()];
  for (unsigned j = 0; j < arrHandle5->Length(); j++) {
      Handle<Value> arg(arrHandle5->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg5[j] = aux; 
  }
    
    
  //make call
  glMap1f((GLenum) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLint) arg3, (GLint) arg4, (const GLfloat*) arg5);
  return v8::Undefined();
}




Handle<Value> GLglMap2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 10) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  double arg5 = args[5]->NumberValue();
  double arg6 = args[6]->NumberValue();
  int arg7 = args[7]->IntegerValue();
  int arg8 = args[8]->IntegerValue();

    
  Handle<Array> arrHandle9 = Handle<Array>::Cast(args[9]);
   GLdouble* arg9 = new  GLdouble[arrHandle9->Length()];
  for (unsigned j = 0; j < arrHandle9->Length(); j++) {
      Handle<Value> arg(arrHandle9->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg9[j] = aux; 
  }
    
    
  //make call
  glMap2d((GLenum) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLint) arg3, (GLint) arg4, (GLdouble) arg5, (GLdouble) arg6, (GLint) arg7, (GLint) arg8, (const GLdouble*) arg9);
  return v8::Undefined();
}




Handle<Value> GLglMap2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 10) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  double arg5 = args[5]->NumberValue();
  double arg6 = args[6]->NumberValue();
  int arg7 = args[7]->IntegerValue();
  int arg8 = args[8]->IntegerValue();

    
  Handle<Array> arrHandle9 = Handle<Array>::Cast(args[9]);
   GLfloat* arg9 = new  GLfloat[arrHandle9->Length()];
  for (unsigned j = 0; j < arrHandle9->Length(); j++) {
      Handle<Value> arg(arrHandle9->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg9[j] = aux; 
  }
    
    
  //make call
  glMap2f((GLenum) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLint) arg3, (GLint) arg4, (GLfloat) arg5, (GLfloat) arg6, (GLint) arg7, (GLint) arg8, (const GLfloat*) arg9);
  return v8::Undefined();
}




Handle<Value> GLglGetMapdvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLdouble* arg2 = new GLdouble[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLdouble aux = (GLdouble)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetMapdv((GLenum) arg0, (GLenum) arg1, (GLdouble*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetMapfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetMapfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetMapivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetMapiv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglEvalCoord1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glEvalCoord1d((GLdouble) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEvalCoord1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glEvalCoord1f((GLfloat) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEvalCoord1dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glEvalCoord1dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEvalCoord1fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glEvalCoord1fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEvalCoord2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glEvalCoord2d((GLdouble) arg0, (GLdouble) arg1);
  return v8::Undefined();
}




Handle<Value> GLglEvalCoord2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glEvalCoord2f((GLfloat) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglEvalCoord2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glEvalCoord2dv((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEvalCoord2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glEvalCoord2fv((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglMapGrid1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMapGrid1d((GLint) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMapGrid1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMapGrid1f((GLint) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMapGrid2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

  //make call
  glMapGrid2d((GLint) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLint) arg3, (GLdouble) arg4, (GLdouble) arg5);
  return v8::Undefined();
}




Handle<Value> GLglMapGrid2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

  //make call
  glMapGrid2f((GLint) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLint) arg3, (GLfloat) arg4, (GLfloat) arg5);
  return v8::Undefined();
}




Handle<Value> GLglEvalPoint1Callback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glEvalPoint1((GLint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglEvalPoint2Callback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glEvalPoint2((GLint) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglEvalMesh1Callback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glEvalMesh1((GLenum) arg0, (GLint) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglEvalMesh2Callback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glEvalMesh2((GLenum) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3, (GLint) arg4);
  return v8::Undefined();
}




Handle<Value> GLglFogfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glFogf((GLenum) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglFogiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glFogi((GLenum) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglFogfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glFogfv((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglFogivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glFogiv((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglFeedbackBufferCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glFeedbackBuffer((GLsizei) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglPassThroughCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glPassThrough((GLfloat) arg0);
  return v8::Undefined();
}




Handle<Value> GLglSelectBufferCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLuint* arg1 = new GLuint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLuint aux = (GLuint)arg->Uint32Value();
      arg1[j] = aux; 
  }
    
    
  //make call
  glSelectBuffer((GLsizei) arg0, (GLuint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglInitNamesCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glInitNames();
  return v8::Undefined();
}




Handle<Value> GLglLoadNameCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glLoadName((GLuint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglPushNameCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glPushName((GLuint) arg0);
  return v8::Undefined();
}




Handle<Value> GLglPopNameCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPopName();
  return v8::Undefined();
}




Handle<Value> GetGL_RESCALE_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RESCALE_NORMAL);
}




Handle<Value> GetGL_CLAMP_TO_EDGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLAMP_TO_EDGE);
}




Handle<Value> GetGL_MAX_ELEMENTS_VERTICES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_ELEMENTS_VERTICES);
}




Handle<Value> GetGL_MAX_ELEMENTS_INDICES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_ELEMENTS_INDICES);
}




Handle<Value> GetGL_BGR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BGR);
}




Handle<Value> GetGL_BGRA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BGRA);
}




Handle<Value> GetGL_UNSIGNED_BYTE_3_3_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_BYTE_3_3_2);
}




Handle<Value> GetGL_UNSIGNED_BYTE_2_3_3_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_BYTE_2_3_3_REV);
}




Handle<Value> GetGL_UNSIGNED_SHORT_5_6_5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_5_6_5);
}




Handle<Value> GetGL_UNSIGNED_SHORT_5_6_5_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_5_6_5_REV);
}




Handle<Value> GetGL_UNSIGNED_SHORT_4_4_4_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_4_4_4_4);
}




Handle<Value> GetGL_UNSIGNED_SHORT_4_4_4_4_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_4_4_4_4_REV);
}




Handle<Value> GetGL_UNSIGNED_SHORT_5_5_5_1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_5_5_5_1);
}




Handle<Value> GetGL_UNSIGNED_SHORT_1_5_5_5_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_1_5_5_5_REV);
}




Handle<Value> GetGL_UNSIGNED_INT_8_8_8_8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_8_8_8_8);
}




Handle<Value> GetGL_UNSIGNED_INT_8_8_8_8_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_8_8_8_8_REV);
}




Handle<Value> GetGL_UNSIGNED_INT_10_10_10_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_10_10_10_2);
}




Handle<Value> GetGL_UNSIGNED_INT_2_10_10_10_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_2_10_10_10_REV);
}




Handle<Value> GetGL_LIGHT_MODEL_COLOR_CONTROL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT_MODEL_COLOR_CONTROL);
}




Handle<Value> GetGL_SINGLE_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SINGLE_COLOR);
}




Handle<Value> GetGL_SEPARATE_SPECULAR_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SEPARATE_SPECULAR_COLOR);
}




Handle<Value> GetGL_TEXTURE_MIN_LOD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MIN_LOD);
}




Handle<Value> GetGL_TEXTURE_MAX_LOD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MAX_LOD);
}




Handle<Value> GetGL_TEXTURE_BASE_LEVEL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BASE_LEVEL);
}




Handle<Value> GetGL_TEXTURE_MAX_LEVEL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MAX_LEVEL);
}




Handle<Value> GetGL_SMOOTH_POINT_SIZE_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH_POINT_SIZE_RANGE);
}




Handle<Value> GetGL_SMOOTH_POINT_SIZE_GRANULARITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH_POINT_SIZE_GRANULARITY);
}




Handle<Value> GetGL_SMOOTH_LINE_WIDTH_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH_LINE_WIDTH_RANGE);
}




Handle<Value> GetGL_SMOOTH_LINE_WIDTH_GRANULARITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH_LINE_WIDTH_GRANULARITY);
}




Handle<Value> GetGL_ALIASED_POINT_SIZE_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALIASED_POINT_SIZE_RANGE);
}




Handle<Value> GetGL_ALIASED_LINE_WIDTH_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALIASED_LINE_WIDTH_RANGE);
}




Handle<Value> GetGL_PACK_SKIP_IMAGES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_SKIP_IMAGES);
}




Handle<Value> GetGL_PACK_IMAGE_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_IMAGE_HEIGHT);
}




Handle<Value> GetGL_UNPACK_SKIP_IMAGES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_SKIP_IMAGES);
}




Handle<Value> GetGL_UNPACK_IMAGE_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_IMAGE_HEIGHT);
}




Handle<Value> GetGL_TEXTURE_3D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_3D);
}




Handle<Value> GetGL_PROXY_TEXTURE_3D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_3D);
}




Handle<Value> GetGL_TEXTURE_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_DEPTH);
}




Handle<Value> GetGL_TEXTURE_WRAP_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_WRAP_R);
}




Handle<Value> GetGL_MAX_3D_TEXTURE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_3D_TEXTURE_SIZE);
}




Handle<Value> GetGL_TEXTURE_BINDING_3D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_3D);
}




Handle<Value> GLglCopyTexSubImage3DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 9) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();
  int arg6 = args[6]->IntegerValue();
  int arg7 = args[7]->IntegerValue();
  int arg8 = args[8]->IntegerValue();

  //make call
  glCopyTexSubImage3D((GLenum) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3, (GLint) arg4, (GLint) arg5, (GLint) arg6, (GLsizei) arg7, (GLsizei) arg8);
  return v8::Undefined();
}




Handle<Value> GetGL_CONSTANT_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT_COLOR);
}




Handle<Value> GetGL_ONE_MINUS_CONSTANT_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_CONSTANT_COLOR);
}




Handle<Value> GetGL_CONSTANT_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT_ALPHA);
}




Handle<Value> GetGL_ONE_MINUS_CONSTANT_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_CONSTANT_ALPHA);
}




Handle<Value> GetGL_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE);
}




Handle<Value> GetGL_POST_CONVOLUTION_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_COLOR_TABLE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_COLOR_TABLE);
}




Handle<Value> GetGL_PROXY_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_COLOR_TABLE);
}




Handle<Value> GetGL_PROXY_POST_CONVOLUTION_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_POST_CONVOLUTION_COLOR_TABLE);
}




Handle<Value> GetGL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE);
}




Handle<Value> GetGL_COLOR_TABLE_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_SCALE);
}




Handle<Value> GetGL_COLOR_TABLE_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_BIAS);
}




Handle<Value> GetGL_COLOR_TABLE_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_FORMAT);
}




Handle<Value> GetGL_COLOR_TABLE_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_WIDTH);
}




Handle<Value> GetGL_COLOR_TABLE_RED_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_RED_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_GREEN_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_GREEN_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_BLUE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_BLUE_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_ALPHA_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_ALPHA_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_LUMINANCE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_LUMINANCE_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_INTENSITY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_INTENSITY_SIZE);
}




Handle<Value> GetGL_CONVOLUTION_1D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_1D);
}




Handle<Value> GetGL_CONVOLUTION_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_2D);
}




Handle<Value> GetGL_SEPARABLE_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SEPARABLE_2D);
}




Handle<Value> GetGL_CONVOLUTION_BORDER_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_BORDER_MODE);
}




Handle<Value> GetGL_CONVOLUTION_FILTER_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_FILTER_SCALE);
}




Handle<Value> GetGL_CONVOLUTION_FILTER_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_FILTER_BIAS);
}




Handle<Value> GetGL_REDUCE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REDUCE);
}




Handle<Value> GetGL_CONVOLUTION_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_FORMAT);
}




Handle<Value> GetGL_CONVOLUTION_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_WIDTH);
}




Handle<Value> GetGL_CONVOLUTION_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_HEIGHT);
}




Handle<Value> GetGL_MAX_CONVOLUTION_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CONVOLUTION_WIDTH);
}




Handle<Value> GetGL_MAX_CONVOLUTION_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CONVOLUTION_HEIGHT);
}




Handle<Value> GetGL_POST_CONVOLUTION_RED_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_RED_SCALE);
}




Handle<Value> GetGL_POST_CONVOLUTION_GREEN_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_GREEN_SCALE);
}




Handle<Value> GetGL_POST_CONVOLUTION_BLUE_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_BLUE_SCALE);
}




Handle<Value> GetGL_POST_CONVOLUTION_ALPHA_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_ALPHA_SCALE);
}




Handle<Value> GetGL_POST_CONVOLUTION_RED_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_RED_BIAS);
}




Handle<Value> GetGL_POST_CONVOLUTION_GREEN_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_GREEN_BIAS);
}




Handle<Value> GetGL_POST_CONVOLUTION_BLUE_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_BLUE_BIAS);
}




Handle<Value> GetGL_POST_CONVOLUTION_ALPHA_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_ALPHA_BIAS);
}




Handle<Value> GetGL_CONSTANT_BORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT_BORDER);
}




Handle<Value> GetGL_REPLICATE_BORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REPLICATE_BORDER);
}




Handle<Value> GetGL_CONVOLUTION_BORDER_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_BORDER_COLOR);
}




Handle<Value> GetGL_COLOR_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATRIX);
}




Handle<Value> GetGL_COLOR_MATRIX_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATRIX_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_COLOR_MATRIX_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_COLOR_MATRIX_STACK_DEPTH);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_RED_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_RED_SCALE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_GREEN_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_GREEN_SCALE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_BLUE_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_BLUE_SCALE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_ALPHA_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_ALPHA_SCALE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_RED_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_RED_BIAS);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_GREEN_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_GREEN_BIAS);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_BLUE_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_BLUE_BIAS);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_ALPHA_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_ALPHA_BIAS);
}




Handle<Value> GetGL_HISTOGRAM(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM);
}




Handle<Value> GetGL_PROXY_HISTOGRAM(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_HISTOGRAM);
}




Handle<Value> GetGL_HISTOGRAM_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_WIDTH);
}




Handle<Value> GetGL_HISTOGRAM_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_FORMAT);
}




Handle<Value> GetGL_HISTOGRAM_RED_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_RED_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_GREEN_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_GREEN_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_BLUE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_BLUE_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_ALPHA_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_ALPHA_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_LUMINANCE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_LUMINANCE_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_SINK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_SINK);
}




Handle<Value> GetGL_MINMAX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MINMAX);
}




Handle<Value> GetGL_MINMAX_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MINMAX_FORMAT);
}




Handle<Value> GetGL_MINMAX_SINK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MINMAX_SINK);
}




Handle<Value> GetGL_TABLE_TOO_LARGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TABLE_TOO_LARGE);
}




Handle<Value> GetGL_MIN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MIN);
}




Handle<Value> GetGL_MAX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX);
}




Handle<Value> GetGL_FUNC_ADD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FUNC_ADD);
}




Handle<Value> GetGL_FUNC_SUBTRACT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FUNC_SUBTRACT);
}




Handle<Value> GetGL_FUNC_REVERSE_SUBTRACT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FUNC_REVERSE_SUBTRACT);
}




Handle<Value> GetGL_BLEND_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND_COLOR);
}




Handle<Value> GLglColorTableParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLint* arg2 = new  GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glColorTableParameteriv((GLenum) arg0, (GLenum) arg1, (const GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglColorTableParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLfloat* arg2 = new  GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glColorTableParameterfv((GLenum) arg0, (GLenum) arg1, (const GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglCopyColorSubTableCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glCopyColorSubTable((GLenum) arg0, (GLsizei) arg1, (GLint) arg2, (GLint) arg3, (GLsizei) arg4);
  return v8::Undefined();
}




Handle<Value> GLglCopyColorTableCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glCopyColorTable((GLenum) arg0, (GLenum) arg1, (GLint) arg2, (GLint) arg3, (GLsizei) arg4);
  return v8::Undefined();
}




Handle<Value> GLglGetColorTableParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetColorTableParameterfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetColorTableParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetColorTableParameteriv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglBlendEquationCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glBlendEquation((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglBlendColorCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glBlendColor((GLclampf) arg0, (GLclampf) arg1, (GLclampf) arg2, (GLclampf) arg3);
  return v8::Undefined();
}




Handle<Value> GLglHistogramCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glHistogram((GLenum) arg0, (GLsizei) arg1, (GLenum) arg2, (GLboolean) arg3);
  return v8::Undefined();
}




Handle<Value> GLglResetHistogramCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glResetHistogram((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglGetHistogramParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetHistogramParameterfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetHistogramParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetHistogramParameteriv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMinmaxCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glMinmax((GLenum) arg0, (GLenum) arg1, (GLboolean) arg2);
  return v8::Undefined();
}




Handle<Value> GLglResetMinmaxCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glResetMinmax((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglGetMinmaxParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetMinmaxParameterfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetMinmaxParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetMinmaxParameteriv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglConvolutionParameterfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glConvolutionParameterf((GLenum) arg0, (GLenum) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglConvolutionParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLfloat* arg2 = new  GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glConvolutionParameterfv((GLenum) arg0, (GLenum) arg1, (const GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglConvolutionParameteriCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glConvolutionParameteri((GLenum) arg0, (GLenum) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglConvolutionParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
   GLint* arg2 = new  GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glConvolutionParameteriv((GLenum) arg0, (GLenum) arg1, (const GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglCopyConvolutionFilter1DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glCopyConvolutionFilter1D((GLenum) arg0, (GLenum) arg1, (GLint) arg2, (GLint) arg3, (GLsizei) arg4);
  return v8::Undefined();
}




Handle<Value> GLglCopyConvolutionFilter2DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();

  //make call
  glCopyConvolutionFilter2D((GLenum) arg0, (GLenum) arg1, (GLint) arg2, (GLint) arg3, (GLsizei) arg4, (GLsizei) arg5);
  return v8::Undefined();
}




Handle<Value> GLglGetConvolutionParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat* arg2 = new GLfloat[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat aux = (GLfloat)arg->NumberValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetConvolutionParameterfv((GLenum) arg0, (GLenum) arg1, (GLfloat*) arg2);
  return v8::Undefined();
}




Handle<Value> GLglGetConvolutionParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    
  Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint* arg2 = new GLint[arrHandle2->Length()];
  for (unsigned j = 0; j < arrHandle2->Length(); j++) {
      Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint aux = (GLint)arg->IntegerValue();
      arg2[j] = aux; 
  }
    
    
  //make call
  glGetConvolutionParameteriv((GLenum) arg0, (GLenum) arg1, (GLint*) arg2);
  return v8::Undefined();
}




Handle<Value> GetGL_TEXTURE0(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE0);
}




Handle<Value> GetGL_TEXTURE1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE1);
}




Handle<Value> GetGL_TEXTURE2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE2);
}




Handle<Value> GetGL_TEXTURE3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE3);
}




Handle<Value> GetGL_TEXTURE4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE4);
}




Handle<Value> GetGL_TEXTURE5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE5);
}




Handle<Value> GetGL_TEXTURE6(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE6);
}




Handle<Value> GetGL_TEXTURE7(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE7);
}




Handle<Value> GetGL_TEXTURE8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE8);
}




Handle<Value> GetGL_TEXTURE9(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE9);
}




Handle<Value> GetGL_TEXTURE10(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE10);
}




Handle<Value> GetGL_TEXTURE11(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE11);
}




Handle<Value> GetGL_TEXTURE12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE12);
}




Handle<Value> GetGL_TEXTURE13(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE13);
}




Handle<Value> GetGL_TEXTURE14(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE14);
}




Handle<Value> GetGL_TEXTURE15(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE15);
}




Handle<Value> GetGL_TEXTURE16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE16);
}




Handle<Value> GetGL_TEXTURE17(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE17);
}




Handle<Value> GetGL_TEXTURE18(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE18);
}




Handle<Value> GetGL_TEXTURE19(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE19);
}




Handle<Value> GetGL_TEXTURE20(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE20);
}




Handle<Value> GetGL_TEXTURE21(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE21);
}




Handle<Value> GetGL_TEXTURE22(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE22);
}




Handle<Value> GetGL_TEXTURE23(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE23);
}




Handle<Value> GetGL_TEXTURE24(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE24);
}




Handle<Value> GetGL_TEXTURE25(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE25);
}




Handle<Value> GetGL_TEXTURE26(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE26);
}




Handle<Value> GetGL_TEXTURE27(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE27);
}




Handle<Value> GetGL_TEXTURE28(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE28);
}




Handle<Value> GetGL_TEXTURE29(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE29);
}




Handle<Value> GetGL_TEXTURE30(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE30);
}




Handle<Value> GetGL_TEXTURE31(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE31);
}




Handle<Value> GetGL_ACTIVE_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACTIVE_TEXTURE);
}




Handle<Value> GetGL_CLIENT_ACTIVE_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_ACTIVE_TEXTURE);
}




Handle<Value> GetGL_MAX_TEXTURE_UNITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_TEXTURE_UNITS);
}




Handle<Value> GetGL_NORMAL_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_MAP);
}




Handle<Value> GetGL_REFLECTION_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REFLECTION_MAP);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP);
}




Handle<Value> GetGL_TEXTURE_BINDING_CUBE_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_CUBE_MAP);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_POSITIVE_X(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_POSITIVE_X);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_POSITIVE_Y(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_POSITIVE_Y);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_POSITIVE_Z(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_POSITIVE_Z);
}




Handle<Value> GetGL_PROXY_TEXTURE_CUBE_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_CUBE_MAP);
}




Handle<Value> GetGL_MAX_CUBE_MAP_TEXTURE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CUBE_MAP_TEXTURE_SIZE);
}




Handle<Value> GetGL_COMPRESSED_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_ALPHA);
}




Handle<Value> GetGL_COMPRESSED_LUMINANCE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_LUMINANCE);
}




Handle<Value> GetGL_COMPRESSED_LUMINANCE_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_LUMINANCE_ALPHA);
}




Handle<Value> GetGL_COMPRESSED_INTENSITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_INTENSITY);
}




Handle<Value> GetGL_COMPRESSED_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_RGB);
}




Handle<Value> GetGL_COMPRESSED_RGBA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_RGBA);
}




Handle<Value> GetGL_TEXTURE_COMPRESSION_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COMPRESSION_HINT);
}




Handle<Value> GetGL_TEXTURE_COMPRESSED_IMAGE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COMPRESSED_IMAGE_SIZE);
}




Handle<Value> GetGL_TEXTURE_COMPRESSED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COMPRESSED);
}




Handle<Value> GetGL_NUM_COMPRESSED_TEXTURE_FORMATS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NUM_COMPRESSED_TEXTURE_FORMATS);
}




Handle<Value> GetGL_COMPRESSED_TEXTURE_FORMATS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_TEXTURE_FORMATS);
}




Handle<Value> GetGL_MULTISAMPLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MULTISAMPLE);
}




Handle<Value> GetGL_SAMPLE_ALPHA_TO_COVERAGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_ALPHA_TO_COVERAGE);
}




Handle<Value> GetGL_SAMPLE_ALPHA_TO_ONE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_ALPHA_TO_ONE);
}




Handle<Value> GetGL_SAMPLE_COVERAGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_COVERAGE);
}




Handle<Value> GetGL_SAMPLE_BUFFERS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_BUFFERS);
}




Handle<Value> GetGL_SAMPLES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLES);
}




Handle<Value> GetGL_SAMPLE_COVERAGE_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_COVERAGE_VALUE);
}




Handle<Value> GetGL_SAMPLE_COVERAGE_INVERT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_COVERAGE_INVERT);
}




Handle<Value> GetGL_MULTISAMPLE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MULTISAMPLE_BIT);
}




Handle<Value> GetGL_TRANSPOSE_MODELVIEW_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSPOSE_MODELVIEW_MATRIX);
}




Handle<Value> GetGL_TRANSPOSE_PROJECTION_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSPOSE_PROJECTION_MATRIX);
}




Handle<Value> GetGL_TRANSPOSE_TEXTURE_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSPOSE_TEXTURE_MATRIX);
}




Handle<Value> GetGL_TRANSPOSE_COLOR_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSPOSE_COLOR_MATRIX);
}




Handle<Value> GetGL_COMBINE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMBINE);
}




Handle<Value> GetGL_COMBINE_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMBINE_RGB);
}




Handle<Value> GetGL_COMBINE_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMBINE_ALPHA);
}




Handle<Value> GetGL_SOURCE0_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE0_RGB);
}




Handle<Value> GetGL_SOURCE1_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE1_RGB);
}




Handle<Value> GetGL_SOURCE2_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE2_RGB);
}




Handle<Value> GetGL_SOURCE0_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE0_ALPHA);
}




Handle<Value> GetGL_SOURCE1_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE1_ALPHA);
}




Handle<Value> GetGL_SOURCE2_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE2_ALPHA);
}




Handle<Value> GetGL_OPERAND0_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND0_RGB);
}




Handle<Value> GetGL_OPERAND1_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND1_RGB);
}




Handle<Value> GetGL_OPERAND2_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND2_RGB);
}




Handle<Value> GetGL_OPERAND0_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND0_ALPHA);
}




Handle<Value> GetGL_OPERAND1_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND1_ALPHA);
}




Handle<Value> GetGL_OPERAND2_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND2_ALPHA);
}




Handle<Value> GetGL_RGB_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB_SCALE);
}




Handle<Value> GetGL_ADD_SIGNED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ADD_SIGNED);
}




Handle<Value> GetGL_INTERPOLATE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTERPOLATE);
}




Handle<Value> GetGL_SUBTRACT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SUBTRACT);
}




Handle<Value> GetGL_CONSTANT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT);
}




Handle<Value> GetGL_PRIMARY_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PRIMARY_COLOR);
}




Handle<Value> GetGL_PREVIOUS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PREVIOUS);
}




Handle<Value> GetGL_DOT3_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOT3_RGB);
}




Handle<Value> GetGL_DOT3_RGBA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOT3_RGBA);
}




Handle<Value> GetGL_CLAMP_TO_BORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLAMP_TO_BORDER);
}




Handle<Value> GLglActiveTextureCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glActiveTexture((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglClientActiveTextureCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glClientActiveTexture((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glMultiTexCoord1d((GLenum) arg0, (GLdouble) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord1dv((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glMultiTexCoord1f((GLenum) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord1fv((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glMultiTexCoord1i((GLenum) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord1iv((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glMultiTexCoord1s((GLenum) arg0, (GLshort) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord1sv((GLenum) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMultiTexCoord2d((GLenum) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord2dv((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMultiTexCoord2f((GLenum) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord2fv((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMultiTexCoord2i((GLenum) arg0, (GLint) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord2iv((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMultiTexCoord2s((GLenum) arg0, (GLshort) arg1, (GLshort) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord2sv((GLenum) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glMultiTexCoord3d((GLenum) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord3dv((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glMultiTexCoord3f((GLenum) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord3fv((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glMultiTexCoord3i((GLenum) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord3iv((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glMultiTexCoord3s((GLenum) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord3sv((GLenum) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();

  //make call
  glMultiTexCoord4d((GLenum) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3, (GLdouble) arg4);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord4dv((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();

  //make call
  glMultiTexCoord4f((GLenum) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3, (GLfloat) arg4);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord4fv((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glMultiTexCoord4i((GLenum) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3, (GLint) arg4);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord4iv((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glMultiTexCoord4s((GLenum) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3, (GLshort) arg4);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord4sv((GLenum) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglLoadTransposeMatrixdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glLoadTransposeMatrixd((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglLoadTransposeMatrixfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glLoadTransposeMatrixf((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglMultTransposeMatrixdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLdouble* arg0 = new  GLdouble[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glMultTransposeMatrixd((const GLdouble*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglMultTransposeMatrixfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    
  Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
   GLfloat* arg0 = new  GLfloat[arrHandle0->Length()];
  for (unsigned j = 0; j < arrHandle0->Length(); j++) {
      Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg0[j] = aux; 
  }
    
    
  //make call
  glMultTransposeMatrixf((const GLfloat*) arg0);
  return v8::Undefined();
}




Handle<Value> GLglSampleCoverageCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  unsigned int arg1 = args[1]->Uint32Value();

  //make call
  glSampleCoverage((GLclampf) arg0, (GLboolean) arg1);
  return v8::Undefined();
}




Handle<Value> GetGL_ARB_multitexture(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ARB_multitexture);
}




Handle<Value> GetGL_TEXTURE0_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE0_ARB);
}




Handle<Value> GetGL_TEXTURE1_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE1_ARB);
}




Handle<Value> GetGL_TEXTURE2_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE2_ARB);
}




Handle<Value> GetGL_TEXTURE3_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE3_ARB);
}




Handle<Value> GetGL_TEXTURE4_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE4_ARB);
}




Handle<Value> GetGL_TEXTURE5_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE5_ARB);
}




Handle<Value> GetGL_TEXTURE6_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE6_ARB);
}




Handle<Value> GetGL_TEXTURE7_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE7_ARB);
}




Handle<Value> GetGL_TEXTURE8_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE8_ARB);
}




Handle<Value> GetGL_TEXTURE9_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE9_ARB);
}




Handle<Value> GetGL_TEXTURE10_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE10_ARB);
}




Handle<Value> GetGL_TEXTURE11_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE11_ARB);
}




Handle<Value> GetGL_TEXTURE12_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE12_ARB);
}




Handle<Value> GetGL_TEXTURE13_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE13_ARB);
}




Handle<Value> GetGL_TEXTURE14_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE14_ARB);
}




Handle<Value> GetGL_TEXTURE15_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE15_ARB);
}




Handle<Value> GetGL_TEXTURE16_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE16_ARB);
}




Handle<Value> GetGL_TEXTURE17_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE17_ARB);
}




Handle<Value> GetGL_TEXTURE18_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE18_ARB);
}




Handle<Value> GetGL_TEXTURE19_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE19_ARB);
}




Handle<Value> GetGL_TEXTURE20_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE20_ARB);
}




Handle<Value> GetGL_TEXTURE21_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE21_ARB);
}




Handle<Value> GetGL_TEXTURE22_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE22_ARB);
}




Handle<Value> GetGL_TEXTURE23_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE23_ARB);
}




Handle<Value> GetGL_TEXTURE24_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE24_ARB);
}




Handle<Value> GetGL_TEXTURE25_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE25_ARB);
}




Handle<Value> GetGL_TEXTURE26_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE26_ARB);
}




Handle<Value> GetGL_TEXTURE27_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE27_ARB);
}




Handle<Value> GetGL_TEXTURE28_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE28_ARB);
}




Handle<Value> GetGL_TEXTURE29_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE29_ARB);
}




Handle<Value> GetGL_TEXTURE30_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE30_ARB);
}




Handle<Value> GetGL_TEXTURE31_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE31_ARB);
}




Handle<Value> GetGL_ACTIVE_TEXTURE_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACTIVE_TEXTURE_ARB);
}




Handle<Value> GetGL_CLIENT_ACTIVE_TEXTURE_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_ACTIVE_TEXTURE_ARB);
}




Handle<Value> GetGL_MAX_TEXTURE_UNITS_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_TEXTURE_UNITS_ARB);
}




Handle<Value> GLglActiveTextureARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glActiveTextureARB((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglClientActiveTextureARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glClientActiveTextureARB((GLenum) arg0);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1dARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glMultiTexCoord1dARB((GLenum) arg0, (GLdouble) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1dvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord1dvARB((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1fARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glMultiTexCoord1fARB((GLenum) arg0, (GLfloat) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1fvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord1fvARB((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1iARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glMultiTexCoord1iARB((GLenum) arg0, (GLint) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1ivARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord1ivARB((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1sARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glMultiTexCoord1sARB((GLenum) arg0, (GLshort) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord1svARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord1svARB((GLenum) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2dARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMultiTexCoord2dARB((GLenum) arg0, (GLdouble) arg1, (GLdouble) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2dvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord2dvARB((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2fARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMultiTexCoord2fARB((GLenum) arg0, (GLfloat) arg1, (GLfloat) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2fvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord2fvARB((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2iARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMultiTexCoord2iARB((GLenum) arg0, (GLint) arg1, (GLint) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2ivARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord2ivARB((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2sARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMultiTexCoord2sARB((GLenum) arg0, (GLshort) arg1, (GLshort) arg2);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord2svARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord2svARB((GLenum) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3dARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glMultiTexCoord3dARB((GLenum) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3dvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord3dvARB((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3fARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glMultiTexCoord3fARB((GLenum) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3fvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord3fvARB((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3iARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glMultiTexCoord3iARB((GLenum) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3ivARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord3ivARB((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3sARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glMultiTexCoord3sARB((GLenum) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord3svARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord3svARB((GLenum) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4dARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();

  //make call
  glMultiTexCoord4dARB((GLenum) arg0, (GLdouble) arg1, (GLdouble) arg2, (GLdouble) arg3, (GLdouble) arg4);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4dvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLdouble* arg1 = new  GLdouble[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLdouble aux = ( GLdouble)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord4dvARB((GLenum) arg0, (const GLdouble*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4fARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();

  //make call
  glMultiTexCoord4fARB((GLenum) arg0, (GLfloat) arg1, (GLfloat) arg2, (GLfloat) arg3, (GLfloat) arg4);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4fvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLfloat* arg1 = new  GLfloat[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLfloat aux = ( GLfloat)arg->NumberValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord4fvARB((GLenum) arg0, (const GLfloat*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4iARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glMultiTexCoord4iARB((GLenum) arg0, (GLint) arg1, (GLint) arg2, (GLint) arg3, (GLint) arg4);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4ivARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLint* arg1 = new  GLint[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLint aux = ( GLint)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord4ivARB((GLenum) arg0, (const GLint*) arg1);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4sARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glMultiTexCoord4sARB((GLenum) arg0, (GLshort) arg1, (GLshort) arg2, (GLshort) arg3, (GLshort) arg4);
  return v8::Undefined();
}




Handle<Value> GLglMultiTexCoord4svARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    
  Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
   GLshort* arg1 = new  GLshort[arrHandle1->Length()];
  for (unsigned j = 0; j < arrHandle1->Length(); j++) {
      Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
       GLshort aux = ( GLshort)arg->IntegerValue();
      arg1[j] = aux; 
  }
    
    
  //make call
  glMultiTexCoord4svARB((GLenum) arg0, (const GLshort*) arg1);
  return v8::Undefined();
}




Handle<Value> GetGL_TEXTURE_1D_ARRAY_EXT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_1D_ARRAY_EXT);
}




Handle<Value> GetGL_PROXY_TEXTURE_1D_ARRAY_EXT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_1D_ARRAY_EXT);
}




Handle<Value> GetGL_TEXTURE_2D_ARRAY_EXT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_2D_ARRAY_EXT);
}




Handle<Value> GetGL_PROXY_TEXTURE_2D_ARRAY_EXT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_2D_ARRAY_EXT);
}




Handle<Value> GetGL_TEXTURE_BINDING_1D_ARRAY_EXT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_1D_ARRAY_EXT);
}




Handle<Value> GetGL_TEXTURE_BINDING_2D_ARRAY_EXT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_2D_ARRAY_EXT);
}




Handle<Value> GetGL_MAX_ARRAY_TEXTURE_LAYERS_EXT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_ARRAY_TEXTURE_LAYERS_EXT);
}




Handle<Value> GetGL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT);
}




Handle<ObjectTemplate> createGl(void) {
      HandleScope handle_scope;

      Handle<ObjectTemplate> Gl = ObjectTemplate::New();
      Gl->SetInternalFieldCount(1);

     Gl->SetAccessor(String::NewSymbol("VERSION_1_1"), GetGL_VERSION_1_1);

     Gl->SetAccessor(String::NewSymbol("VERSION_1_2"), GetGL_VERSION_1_2);

     Gl->SetAccessor(String::NewSymbol("VERSION_1_3"), GetGL_VERSION_1_3);

     Gl->SetAccessor(String::NewSymbol("ARB_imaging"), GetGL_ARB_imaging);

     Gl->SetAccessor(String::NewSymbol("FALSE"), GetGL_FALSE);

     Gl->SetAccessor(String::NewSymbol("TRUE"), GetGL_TRUE);

     Gl->SetAccessor(String::NewSymbol("BYTE"), GetGL_BYTE);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_BYTE"), GetGL_UNSIGNED_BYTE);

     Gl->SetAccessor(String::NewSymbol("SHORT"), GetGL_SHORT);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT"), GetGL_UNSIGNED_SHORT);

     Gl->SetAccessor(String::NewSymbol("INT"), GetGL_INT);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT"), GetGL_UNSIGNED_INT);

     Gl->SetAccessor(String::NewSymbol("FLOAT"), GetGL_FLOAT);

     Gl->SetAccessor(String::NewSymbol("2_BYTES"), GetGL_2_BYTES);

     Gl->SetAccessor(String::NewSymbol("3_BYTES"), GetGL_3_BYTES);

     Gl->SetAccessor(String::NewSymbol("4_BYTES"), GetGL_4_BYTES);

     Gl->SetAccessor(String::NewSymbol("DOUBLE"), GetGL_DOUBLE);

     Gl->SetAccessor(String::NewSymbol("POINTS"), GetGL_POINTS);

     Gl->SetAccessor(String::NewSymbol("LINES"), GetGL_LINES);

     Gl->SetAccessor(String::NewSymbol("LINE_LOOP"), GetGL_LINE_LOOP);

     Gl->SetAccessor(String::NewSymbol("LINE_STRIP"), GetGL_LINE_STRIP);

     Gl->SetAccessor(String::NewSymbol("TRIANGLES"), GetGL_TRIANGLES);

     Gl->SetAccessor(String::NewSymbol("TRIANGLE_STRIP"), GetGL_TRIANGLE_STRIP);

     Gl->SetAccessor(String::NewSymbol("TRIANGLE_FAN"), GetGL_TRIANGLE_FAN);

     Gl->SetAccessor(String::NewSymbol("QUADS"), GetGL_QUADS);

     Gl->SetAccessor(String::NewSymbol("QUAD_STRIP"), GetGL_QUAD_STRIP);

     Gl->SetAccessor(String::NewSymbol("POLYGON"), GetGL_POLYGON);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY"), GetGL_VERTEX_ARRAY);

     Gl->SetAccessor(String::NewSymbol("NORMAL_ARRAY"), GetGL_NORMAL_ARRAY);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY"), GetGL_COLOR_ARRAY);

     Gl->SetAccessor(String::NewSymbol("INDEX_ARRAY"), GetGL_INDEX_ARRAY);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY"), GetGL_TEXTURE_COORD_ARRAY);

     Gl->SetAccessor(String::NewSymbol("EDGE_FLAG_ARRAY"), GetGL_EDGE_FLAG_ARRAY);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY_SIZE"), GetGL_VERTEX_ARRAY_SIZE);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY_TYPE"), GetGL_VERTEX_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY_STRIDE"), GetGL_VERTEX_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("NORMAL_ARRAY_TYPE"), GetGL_NORMAL_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("NORMAL_ARRAY_STRIDE"), GetGL_NORMAL_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY_SIZE"), GetGL_COLOR_ARRAY_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY_TYPE"), GetGL_COLOR_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY_STRIDE"), GetGL_COLOR_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("INDEX_ARRAY_TYPE"), GetGL_INDEX_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("INDEX_ARRAY_STRIDE"), GetGL_INDEX_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY_SIZE"), GetGL_TEXTURE_COORD_ARRAY_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY_TYPE"), GetGL_TEXTURE_COORD_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY_STRIDE"), GetGL_TEXTURE_COORD_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("EDGE_FLAG_ARRAY_STRIDE"), GetGL_EDGE_FLAG_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY_POINTER"), GetGL_VERTEX_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("NORMAL_ARRAY_POINTER"), GetGL_NORMAL_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY_POINTER"), GetGL_COLOR_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("INDEX_ARRAY_POINTER"), GetGL_INDEX_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY_POINTER"), GetGL_TEXTURE_COORD_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("EDGE_FLAG_ARRAY_POINTER"), GetGL_EDGE_FLAG_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("V2F"), GetGL_V2F);

     Gl->SetAccessor(String::NewSymbol("V3F"), GetGL_V3F);

     Gl->SetAccessor(String::NewSymbol("C4UB_V2F"), GetGL_C4UB_V2F);

     Gl->SetAccessor(String::NewSymbol("C4UB_V3F"), GetGL_C4UB_V3F);

     Gl->SetAccessor(String::NewSymbol("C3F_V3F"), GetGL_C3F_V3F);

     Gl->SetAccessor(String::NewSymbol("N3F_V3F"), GetGL_N3F_V3F);

     Gl->SetAccessor(String::NewSymbol("C4F_N3F_V3F"), GetGL_C4F_N3F_V3F);

     Gl->SetAccessor(String::NewSymbol("T2F_V3F"), GetGL_T2F_V3F);

     Gl->SetAccessor(String::NewSymbol("T4F_V4F"), GetGL_T4F_V4F);

     Gl->SetAccessor(String::NewSymbol("T2F_C4UB_V3F"), GetGL_T2F_C4UB_V3F);

     Gl->SetAccessor(String::NewSymbol("T2F_C3F_V3F"), GetGL_T2F_C3F_V3F);

     Gl->SetAccessor(String::NewSymbol("T2F_N3F_V3F"), GetGL_T2F_N3F_V3F);

     Gl->SetAccessor(String::NewSymbol("T2F_C4F_N3F_V3F"), GetGL_T2F_C4F_N3F_V3F);

     Gl->SetAccessor(String::NewSymbol("T4F_C4F_N3F_V4F"), GetGL_T4F_C4F_N3F_V4F);

     Gl->SetAccessor(String::NewSymbol("MATRIX_MODE"), GetGL_MATRIX_MODE);

     Gl->SetAccessor(String::NewSymbol("MODELVIEW"), GetGL_MODELVIEW);

     Gl->SetAccessor(String::NewSymbol("PROJECTION"), GetGL_PROJECTION);

     Gl->SetAccessor(String::NewSymbol("TEXTURE"), GetGL_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("POINT_SMOOTH"), GetGL_POINT_SMOOTH);

     Gl->SetAccessor(String::NewSymbol("POINT_SIZE"), GetGL_POINT_SIZE);

     Gl->SetAccessor(String::NewSymbol("POINT_SIZE_GRANULARITY"), GetGL_POINT_SIZE_GRANULARITY);

     Gl->SetAccessor(String::NewSymbol("POINT_SIZE_RANGE"), GetGL_POINT_SIZE_RANGE);

     Gl->SetAccessor(String::NewSymbol("LINE_SMOOTH"), GetGL_LINE_SMOOTH);

     Gl->SetAccessor(String::NewSymbol("LINE_STIPPLE"), GetGL_LINE_STIPPLE);

     Gl->SetAccessor(String::NewSymbol("LINE_STIPPLE_PATTERN"), GetGL_LINE_STIPPLE_PATTERN);

     Gl->SetAccessor(String::NewSymbol("LINE_STIPPLE_REPEAT"), GetGL_LINE_STIPPLE_REPEAT);

     Gl->SetAccessor(String::NewSymbol("LINE_WIDTH"), GetGL_LINE_WIDTH);

     Gl->SetAccessor(String::NewSymbol("LINE_WIDTH_GRANULARITY"), GetGL_LINE_WIDTH_GRANULARITY);

     Gl->SetAccessor(String::NewSymbol("LINE_WIDTH_RANGE"), GetGL_LINE_WIDTH_RANGE);

     Gl->SetAccessor(String::NewSymbol("POINT"), GetGL_POINT);

     Gl->SetAccessor(String::NewSymbol("LINE"), GetGL_LINE);

     Gl->SetAccessor(String::NewSymbol("FILL"), GetGL_FILL);

     Gl->SetAccessor(String::NewSymbol("CW"), GetGL_CW);

     Gl->SetAccessor(String::NewSymbol("CCW"), GetGL_CCW);

     Gl->SetAccessor(String::NewSymbol("FRONT"), GetGL_FRONT);

     Gl->SetAccessor(String::NewSymbol("BACK"), GetGL_BACK);

     Gl->SetAccessor(String::NewSymbol("POLYGON_MODE"), GetGL_POLYGON_MODE);

     Gl->SetAccessor(String::NewSymbol("POLYGON_SMOOTH"), GetGL_POLYGON_SMOOTH);

     Gl->SetAccessor(String::NewSymbol("POLYGON_STIPPLE"), GetGL_POLYGON_STIPPLE);

     Gl->SetAccessor(String::NewSymbol("EDGE_FLAG"), GetGL_EDGE_FLAG);

     Gl->SetAccessor(String::NewSymbol("CULL_FACE"), GetGL_CULL_FACE);

     Gl->SetAccessor(String::NewSymbol("CULL_FACE_MODE"), GetGL_CULL_FACE_MODE);

     Gl->SetAccessor(String::NewSymbol("FRONT_FACE"), GetGL_FRONT_FACE);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_FACTOR"), GetGL_POLYGON_OFFSET_FACTOR);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_UNITS"), GetGL_POLYGON_OFFSET_UNITS);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_POINT"), GetGL_POLYGON_OFFSET_POINT);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_LINE"), GetGL_POLYGON_OFFSET_LINE);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_FILL"), GetGL_POLYGON_OFFSET_FILL);

     Gl->SetAccessor(String::NewSymbol("COMPILE"), GetGL_COMPILE);

     Gl->SetAccessor(String::NewSymbol("COMPILE_AND_EXECUTE"), GetGL_COMPILE_AND_EXECUTE);

     Gl->SetAccessor(String::NewSymbol("LIST_BASE"), GetGL_LIST_BASE);

     Gl->SetAccessor(String::NewSymbol("LIST_INDEX"), GetGL_LIST_INDEX);

     Gl->SetAccessor(String::NewSymbol("LIST_MODE"), GetGL_LIST_MODE);

     Gl->SetAccessor(String::NewSymbol("NEVER"), GetGL_NEVER);

     Gl->SetAccessor(String::NewSymbol("LESS"), GetGL_LESS);

     Gl->SetAccessor(String::NewSymbol("EQUAL"), GetGL_EQUAL);

     Gl->SetAccessor(String::NewSymbol("LEQUAL"), GetGL_LEQUAL);

     Gl->SetAccessor(String::NewSymbol("GREATER"), GetGL_GREATER);

     Gl->SetAccessor(String::NewSymbol("NOTEQUAL"), GetGL_NOTEQUAL);

     Gl->SetAccessor(String::NewSymbol("GEQUAL"), GetGL_GEQUAL);

     Gl->SetAccessor(String::NewSymbol("ALWAYS"), GetGL_ALWAYS);

     Gl->SetAccessor(String::NewSymbol("DEPTH_TEST"), GetGL_DEPTH_TEST);

     Gl->SetAccessor(String::NewSymbol("DEPTH_BITS"), GetGL_DEPTH_BITS);

     Gl->SetAccessor(String::NewSymbol("DEPTH_CLEAR_VALUE"), GetGL_DEPTH_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("DEPTH_FUNC"), GetGL_DEPTH_FUNC);

     Gl->SetAccessor(String::NewSymbol("DEPTH_RANGE"), GetGL_DEPTH_RANGE);

     Gl->SetAccessor(String::NewSymbol("DEPTH_WRITEMASK"), GetGL_DEPTH_WRITEMASK);

     Gl->SetAccessor(String::NewSymbol("DEPTH_COMPONENT"), GetGL_DEPTH_COMPONENT);

     Gl->SetAccessor(String::NewSymbol("LIGHTING"), GetGL_LIGHTING);

     Gl->SetAccessor(String::NewSymbol("LIGHT0"), GetGL_LIGHT0);

     Gl->SetAccessor(String::NewSymbol("LIGHT1"), GetGL_LIGHT1);

     Gl->SetAccessor(String::NewSymbol("LIGHT2"), GetGL_LIGHT2);

     Gl->SetAccessor(String::NewSymbol("LIGHT3"), GetGL_LIGHT3);

     Gl->SetAccessor(String::NewSymbol("LIGHT4"), GetGL_LIGHT4);

     Gl->SetAccessor(String::NewSymbol("LIGHT5"), GetGL_LIGHT5);

     Gl->SetAccessor(String::NewSymbol("LIGHT6"), GetGL_LIGHT6);

     Gl->SetAccessor(String::NewSymbol("LIGHT7"), GetGL_LIGHT7);

     Gl->SetAccessor(String::NewSymbol("SPOT_EXPONENT"), GetGL_SPOT_EXPONENT);

     Gl->SetAccessor(String::NewSymbol("SPOT_CUTOFF"), GetGL_SPOT_CUTOFF);

     Gl->SetAccessor(String::NewSymbol("AMBIENT"), GetGL_AMBIENT);

     Gl->SetAccessor(String::NewSymbol("DIFFUSE"), GetGL_DIFFUSE);

     Gl->SetAccessor(String::NewSymbol("SPECULAR"), GetGL_SPECULAR);

     Gl->SetAccessor(String::NewSymbol("SHININESS"), GetGL_SHININESS);

     Gl->SetAccessor(String::NewSymbol("EMISSION"), GetGL_EMISSION);

     Gl->SetAccessor(String::NewSymbol("POSITION"), GetGL_POSITION);

     Gl->SetAccessor(String::NewSymbol("SPOT_DIRECTION"), GetGL_SPOT_DIRECTION);

     Gl->SetAccessor(String::NewSymbol("AMBIENT_AND_DIFFUSE"), GetGL_AMBIENT_AND_DIFFUSE);

     Gl->SetAccessor(String::NewSymbol("COLOR_INDEXES"), GetGL_COLOR_INDEXES);

     Gl->SetAccessor(String::NewSymbol("LIGHT_MODEL_TWO_SIDE"), GetGL_LIGHT_MODEL_TWO_SIDE);

     Gl->SetAccessor(String::NewSymbol("LIGHT_MODEL_LOCAL_VIEWER"), GetGL_LIGHT_MODEL_LOCAL_VIEWER);

     Gl->SetAccessor(String::NewSymbol("LIGHT_MODEL_AMBIENT"), GetGL_LIGHT_MODEL_AMBIENT);

     Gl->SetAccessor(String::NewSymbol("FRONT_AND_BACK"), GetGL_FRONT_AND_BACK);

     Gl->SetAccessor(String::NewSymbol("SHADE_MODEL"), GetGL_SHADE_MODEL);

     Gl->SetAccessor(String::NewSymbol("FLAT"), GetGL_FLAT);

     Gl->SetAccessor(String::NewSymbol("SMOOTH"), GetGL_SMOOTH);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATERIAL"), GetGL_COLOR_MATERIAL);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATERIAL_FACE"), GetGL_COLOR_MATERIAL_FACE);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATERIAL_PARAMETER"), GetGL_COLOR_MATERIAL_PARAMETER);

     Gl->SetAccessor(String::NewSymbol("NORMALIZE"), GetGL_NORMALIZE);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE0"), GetGL_CLIP_PLANE0);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE1"), GetGL_CLIP_PLANE1);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE2"), GetGL_CLIP_PLANE2);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE3"), GetGL_CLIP_PLANE3);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE4"), GetGL_CLIP_PLANE4);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE5"), GetGL_CLIP_PLANE5);

     Gl->SetAccessor(String::NewSymbol("ACCUM_RED_BITS"), GetGL_ACCUM_RED_BITS);

     Gl->SetAccessor(String::NewSymbol("ACCUM_GREEN_BITS"), GetGL_ACCUM_GREEN_BITS);

     Gl->SetAccessor(String::NewSymbol("ACCUM_BLUE_BITS"), GetGL_ACCUM_BLUE_BITS);

     Gl->SetAccessor(String::NewSymbol("ACCUM_ALPHA_BITS"), GetGL_ACCUM_ALPHA_BITS);

     Gl->SetAccessor(String::NewSymbol("ACCUM_CLEAR_VALUE"), GetGL_ACCUM_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("ACCUM"), GetGL_ACCUM);

     Gl->SetAccessor(String::NewSymbol("ADD"), GetGL_ADD);

     Gl->SetAccessor(String::NewSymbol("LOAD"), GetGL_LOAD);

     Gl->SetAccessor(String::NewSymbol("MULT"), GetGL_MULT);

     Gl->SetAccessor(String::NewSymbol("RETURN"), GetGL_RETURN);

     Gl->SetAccessor(String::NewSymbol("ALPHA_TEST"), GetGL_ALPHA_TEST);

     Gl->SetAccessor(String::NewSymbol("ALPHA_TEST_REF"), GetGL_ALPHA_TEST_REF);

     Gl->SetAccessor(String::NewSymbol("ALPHA_TEST_FUNC"), GetGL_ALPHA_TEST_FUNC);

     Gl->SetAccessor(String::NewSymbol("BLEND"), GetGL_BLEND);

     Gl->SetAccessor(String::NewSymbol("BLEND_SRC"), GetGL_BLEND_SRC);

     Gl->SetAccessor(String::NewSymbol("BLEND_DST"), GetGL_BLEND_DST);

     Gl->SetAccessor(String::NewSymbol("ZERO"), GetGL_ZERO);

     Gl->SetAccessor(String::NewSymbol("ONE"), GetGL_ONE);

     Gl->SetAccessor(String::NewSymbol("SRC_COLOR"), GetGL_SRC_COLOR);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_SRC_COLOR"), GetGL_ONE_MINUS_SRC_COLOR);

     Gl->SetAccessor(String::NewSymbol("SRC_ALPHA"), GetGL_SRC_ALPHA);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_SRC_ALPHA"), GetGL_ONE_MINUS_SRC_ALPHA);

     Gl->SetAccessor(String::NewSymbol("DST_ALPHA"), GetGL_DST_ALPHA);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_DST_ALPHA"), GetGL_ONE_MINUS_DST_ALPHA);

     Gl->SetAccessor(String::NewSymbol("DST_COLOR"), GetGL_DST_COLOR);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_DST_COLOR"), GetGL_ONE_MINUS_DST_COLOR);

     Gl->SetAccessor(String::NewSymbol("SRC_ALPHA_SATURATE"), GetGL_SRC_ALPHA_SATURATE);

     Gl->SetAccessor(String::NewSymbol("FEEDBACK"), GetGL_FEEDBACK);

     Gl->SetAccessor(String::NewSymbol("RENDER"), GetGL_RENDER);

     Gl->SetAccessor(String::NewSymbol("SELECT"), GetGL_SELECT);

     Gl->SetAccessor(String::NewSymbol("2D"), GetGL_2D);

     Gl->SetAccessor(String::NewSymbol("3D"), GetGL_3D);

     Gl->SetAccessor(String::NewSymbol("3D_COLOR"), GetGL_3D_COLOR);

     Gl->SetAccessor(String::NewSymbol("3D_COLOR_TEXTURE"), GetGL_3D_COLOR_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("4D_COLOR_TEXTURE"), GetGL_4D_COLOR_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("POINT_TOKEN"), GetGL_POINT_TOKEN);

     Gl->SetAccessor(String::NewSymbol("LINE_TOKEN"), GetGL_LINE_TOKEN);

     Gl->SetAccessor(String::NewSymbol("LINE_RESET_TOKEN"), GetGL_LINE_RESET_TOKEN);

     Gl->SetAccessor(String::NewSymbol("POLYGON_TOKEN"), GetGL_POLYGON_TOKEN);

     Gl->SetAccessor(String::NewSymbol("BITMAP_TOKEN"), GetGL_BITMAP_TOKEN);

     Gl->SetAccessor(String::NewSymbol("DRAW_PIXEL_TOKEN"), GetGL_DRAW_PIXEL_TOKEN);

     Gl->SetAccessor(String::NewSymbol("COPY_PIXEL_TOKEN"), GetGL_COPY_PIXEL_TOKEN);

     Gl->SetAccessor(String::NewSymbol("PASS_THROUGH_TOKEN"), GetGL_PASS_THROUGH_TOKEN);

     Gl->SetAccessor(String::NewSymbol("FEEDBACK_BUFFER_POINTER"), GetGL_FEEDBACK_BUFFER_POINTER);

     Gl->SetAccessor(String::NewSymbol("FEEDBACK_BUFFER_SIZE"), GetGL_FEEDBACK_BUFFER_SIZE);

     Gl->SetAccessor(String::NewSymbol("FEEDBACK_BUFFER_TYPE"), GetGL_FEEDBACK_BUFFER_TYPE);

     Gl->SetAccessor(String::NewSymbol("SELECTION_BUFFER_POINTER"), GetGL_SELECTION_BUFFER_POINTER);

     Gl->SetAccessor(String::NewSymbol("SELECTION_BUFFER_SIZE"), GetGL_SELECTION_BUFFER_SIZE);

     Gl->SetAccessor(String::NewSymbol("FOG"), GetGL_FOG);

     Gl->SetAccessor(String::NewSymbol("FOG_MODE"), GetGL_FOG_MODE);

     Gl->SetAccessor(String::NewSymbol("FOG_DENSITY"), GetGL_FOG_DENSITY);

     Gl->SetAccessor(String::NewSymbol("FOG_COLOR"), GetGL_FOG_COLOR);

     Gl->SetAccessor(String::NewSymbol("FOG_INDEX"), GetGL_FOG_INDEX);

     Gl->SetAccessor(String::NewSymbol("FOG_START"), GetGL_FOG_START);

     Gl->SetAccessor(String::NewSymbol("FOG_END"), GetGL_FOG_END);

     Gl->SetAccessor(String::NewSymbol("LINEAR"), GetGL_LINEAR);

     Gl->SetAccessor(String::NewSymbol("EXP"), GetGL_EXP);

     Gl->SetAccessor(String::NewSymbol("EXP2"), GetGL_EXP2);

     Gl->SetAccessor(String::NewSymbol("LOGIC_OP"), GetGL_LOGIC_OP);

     Gl->SetAccessor(String::NewSymbol("INDEX_LOGIC_OP"), GetGL_INDEX_LOGIC_OP);

     Gl->SetAccessor(String::NewSymbol("COLOR_LOGIC_OP"), GetGL_COLOR_LOGIC_OP);

     Gl->SetAccessor(String::NewSymbol("LOGIC_OP_MODE"), GetGL_LOGIC_OP_MODE);

     Gl->SetAccessor(String::NewSymbol("CLEAR"), GetGL_CLEAR);

     Gl->SetAccessor(String::NewSymbol("SET"), GetGL_SET);

     Gl->SetAccessor(String::NewSymbol("COPY"), GetGL_COPY);

     Gl->SetAccessor(String::NewSymbol("COPY_INVERTED"), GetGL_COPY_INVERTED);

     Gl->SetAccessor(String::NewSymbol("NOOP"), GetGL_NOOP);

     Gl->SetAccessor(String::NewSymbol("INVERT"), GetGL_INVERT);

     Gl->SetAccessor(String::NewSymbol("AND"), GetGL_AND);

     Gl->SetAccessor(String::NewSymbol("NAND"), GetGL_NAND);

     Gl->SetAccessor(String::NewSymbol("OR"), GetGL_OR);

     Gl->SetAccessor(String::NewSymbol("NOR"), GetGL_NOR);

     Gl->SetAccessor(String::NewSymbol("XOR"), GetGL_XOR);

     Gl->SetAccessor(String::NewSymbol("EQUIV"), GetGL_EQUIV);

     Gl->SetAccessor(String::NewSymbol("AND_REVERSE"), GetGL_AND_REVERSE);

     Gl->SetAccessor(String::NewSymbol("AND_INVERTED"), GetGL_AND_INVERTED);

     Gl->SetAccessor(String::NewSymbol("OR_REVERSE"), GetGL_OR_REVERSE);

     Gl->SetAccessor(String::NewSymbol("OR_INVERTED"), GetGL_OR_INVERTED);

     Gl->SetAccessor(String::NewSymbol("STENCIL_BITS"), GetGL_STENCIL_BITS);

     Gl->SetAccessor(String::NewSymbol("STENCIL_TEST"), GetGL_STENCIL_TEST);

     Gl->SetAccessor(String::NewSymbol("STENCIL_CLEAR_VALUE"), GetGL_STENCIL_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("STENCIL_FUNC"), GetGL_STENCIL_FUNC);

     Gl->SetAccessor(String::NewSymbol("STENCIL_VALUE_MASK"), GetGL_STENCIL_VALUE_MASK);

     Gl->SetAccessor(String::NewSymbol("STENCIL_FAIL"), GetGL_STENCIL_FAIL);

     Gl->SetAccessor(String::NewSymbol("STENCIL_PASS_DEPTH_FAIL"), GetGL_STENCIL_PASS_DEPTH_FAIL);

     Gl->SetAccessor(String::NewSymbol("STENCIL_PASS_DEPTH_PASS"), GetGL_STENCIL_PASS_DEPTH_PASS);

     Gl->SetAccessor(String::NewSymbol("STENCIL_REF"), GetGL_STENCIL_REF);

     Gl->SetAccessor(String::NewSymbol("STENCIL_WRITEMASK"), GetGL_STENCIL_WRITEMASK);

     Gl->SetAccessor(String::NewSymbol("STENCIL_INDEX"), GetGL_STENCIL_INDEX);

     Gl->SetAccessor(String::NewSymbol("KEEP"), GetGL_KEEP);

     Gl->SetAccessor(String::NewSymbol("REPLACE"), GetGL_REPLACE);

     Gl->SetAccessor(String::NewSymbol("INCR"), GetGL_INCR);

     Gl->SetAccessor(String::NewSymbol("DECR"), GetGL_DECR);

     Gl->SetAccessor(String::NewSymbol("NONE"), GetGL_NONE);

     Gl->SetAccessor(String::NewSymbol("LEFT"), GetGL_LEFT);

     Gl->SetAccessor(String::NewSymbol("RIGHT"), GetGL_RIGHT);

     Gl->SetAccessor(String::NewSymbol("FRONT_LEFT"), GetGL_FRONT_LEFT);

     Gl->SetAccessor(String::NewSymbol("FRONT_RIGHT"), GetGL_FRONT_RIGHT);

     Gl->SetAccessor(String::NewSymbol("BACK_LEFT"), GetGL_BACK_LEFT);

     Gl->SetAccessor(String::NewSymbol("BACK_RIGHT"), GetGL_BACK_RIGHT);

     Gl->SetAccessor(String::NewSymbol("AUX0"), GetGL_AUX0);

     Gl->SetAccessor(String::NewSymbol("AUX1"), GetGL_AUX1);

     Gl->SetAccessor(String::NewSymbol("AUX2"), GetGL_AUX2);

     Gl->SetAccessor(String::NewSymbol("AUX3"), GetGL_AUX3);

     Gl->SetAccessor(String::NewSymbol("COLOR_INDEX"), GetGL_COLOR_INDEX);

     Gl->SetAccessor(String::NewSymbol("RED"), GetGL_RED);

     Gl->SetAccessor(String::NewSymbol("GREEN"), GetGL_GREEN);

     Gl->SetAccessor(String::NewSymbol("BLUE"), GetGL_BLUE);

     Gl->SetAccessor(String::NewSymbol("ALPHA"), GetGL_ALPHA);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE"), GetGL_LUMINANCE);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE_ALPHA"), GetGL_LUMINANCE_ALPHA);

     Gl->SetAccessor(String::NewSymbol("ALPHA_BITS"), GetGL_ALPHA_BITS);

     Gl->SetAccessor(String::NewSymbol("RED_BITS"), GetGL_RED_BITS);

     Gl->SetAccessor(String::NewSymbol("GREEN_BITS"), GetGL_GREEN_BITS);

     Gl->SetAccessor(String::NewSymbol("BLUE_BITS"), GetGL_BLUE_BITS);

     Gl->SetAccessor(String::NewSymbol("INDEX_BITS"), GetGL_INDEX_BITS);

     Gl->SetAccessor(String::NewSymbol("SUBPIXEL_BITS"), GetGL_SUBPIXEL_BITS);

     Gl->SetAccessor(String::NewSymbol("AUX_BUFFERS"), GetGL_AUX_BUFFERS);

     Gl->SetAccessor(String::NewSymbol("READ_BUFFER"), GetGL_READ_BUFFER);

     Gl->SetAccessor(String::NewSymbol("DRAW_BUFFER"), GetGL_DRAW_BUFFER);

     Gl->SetAccessor(String::NewSymbol("DOUBLEBUFFER"), GetGL_DOUBLEBUFFER);

     Gl->SetAccessor(String::NewSymbol("STEREO"), GetGL_STEREO);

     Gl->SetAccessor(String::NewSymbol("BITMAP"), GetGL_BITMAP);

     Gl->SetAccessor(String::NewSymbol("COLOR"), GetGL_COLOR);

     Gl->SetAccessor(String::NewSymbol("DEPTH"), GetGL_DEPTH);

     Gl->SetAccessor(String::NewSymbol("STENCIL"), GetGL_STENCIL);

     Gl->SetAccessor(String::NewSymbol("DITHER"), GetGL_DITHER);

     Gl->SetAccessor(String::NewSymbol("RGB"), GetGL_RGB);

     Gl->SetAccessor(String::NewSymbol("RGBA"), GetGL_RGBA);

     Gl->SetAccessor(String::NewSymbol("MAX_LIST_NESTING"), GetGL_MAX_LIST_NESTING);

     Gl->SetAccessor(String::NewSymbol("MAX_EVAL_ORDER"), GetGL_MAX_EVAL_ORDER);

     Gl->SetAccessor(String::NewSymbol("MAX_LIGHTS"), GetGL_MAX_LIGHTS);

     Gl->SetAccessor(String::NewSymbol("MAX_CLIP_PLANES"), GetGL_MAX_CLIP_PLANES);

     Gl->SetAccessor(String::NewSymbol("MAX_TEXTURE_SIZE"), GetGL_MAX_TEXTURE_SIZE);

     Gl->SetAccessor(String::NewSymbol("MAX_PIXEL_MAP_TABLE"), GetGL_MAX_PIXEL_MAP_TABLE);

     Gl->SetAccessor(String::NewSymbol("MAX_ATTRIB_STACK_DEPTH"), GetGL_MAX_ATTRIB_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_MODELVIEW_STACK_DEPTH"), GetGL_MAX_MODELVIEW_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_NAME_STACK_DEPTH"), GetGL_MAX_NAME_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_PROJECTION_STACK_DEPTH"), GetGL_MAX_PROJECTION_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_TEXTURE_STACK_DEPTH"), GetGL_MAX_TEXTURE_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_VIEWPORT_DIMS"), GetGL_MAX_VIEWPORT_DIMS);

     Gl->SetAccessor(String::NewSymbol("MAX_CLIENT_ATTRIB_STACK_DEPTH"), GetGL_MAX_CLIENT_ATTRIB_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("ATTRIB_STACK_DEPTH"), GetGL_ATTRIB_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("CLIENT_ATTRIB_STACK_DEPTH"), GetGL_CLIENT_ATTRIB_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("COLOR_CLEAR_VALUE"), GetGL_COLOR_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("COLOR_WRITEMASK"), GetGL_COLOR_WRITEMASK);

     Gl->SetAccessor(String::NewSymbol("CURRENT_INDEX"), GetGL_CURRENT_INDEX);

     Gl->SetAccessor(String::NewSymbol("CURRENT_COLOR"), GetGL_CURRENT_COLOR);

     Gl->SetAccessor(String::NewSymbol("CURRENT_NORMAL"), GetGL_CURRENT_NORMAL);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_COLOR"), GetGL_CURRENT_RASTER_COLOR);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_DISTANCE"), GetGL_CURRENT_RASTER_DISTANCE);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_INDEX"), GetGL_CURRENT_RASTER_INDEX);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_POSITION"), GetGL_CURRENT_RASTER_POSITION);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_TEXTURE_COORDS"), GetGL_CURRENT_RASTER_TEXTURE_COORDS);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_POSITION_VALID"), GetGL_CURRENT_RASTER_POSITION_VALID);

     Gl->SetAccessor(String::NewSymbol("CURRENT_TEXTURE_COORDS"), GetGL_CURRENT_TEXTURE_COORDS);

     Gl->SetAccessor(String::NewSymbol("INDEX_CLEAR_VALUE"), GetGL_INDEX_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("INDEX_MODE"), GetGL_INDEX_MODE);

     Gl->SetAccessor(String::NewSymbol("INDEX_WRITEMASK"), GetGL_INDEX_WRITEMASK);

     Gl->SetAccessor(String::NewSymbol("MODELVIEW_MATRIX"), GetGL_MODELVIEW_MATRIX);

     Gl->SetAccessor(String::NewSymbol("MODELVIEW_STACK_DEPTH"), GetGL_MODELVIEW_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("NAME_STACK_DEPTH"), GetGL_NAME_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("PROJECTION_MATRIX"), GetGL_PROJECTION_MATRIX);

     Gl->SetAccessor(String::NewSymbol("PROJECTION_STACK_DEPTH"), GetGL_PROJECTION_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("RENDER_MODE"), GetGL_RENDER_MODE);

     Gl->SetAccessor(String::NewSymbol("RGBA_MODE"), GetGL_RGBA_MODE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MATRIX"), GetGL_TEXTURE_MATRIX);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_STACK_DEPTH"), GetGL_TEXTURE_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("VIEWPORT"), GetGL_VIEWPORT);

     Gl->SetAccessor(String::NewSymbol("AUTO_NORMAL"), GetGL_AUTO_NORMAL);

     Gl->SetAccessor(String::NewSymbol("MAP1_COLOR_4"), GetGL_MAP1_COLOR_4);

     Gl->SetAccessor(String::NewSymbol("MAP1_INDEX"), GetGL_MAP1_INDEX);

     Gl->SetAccessor(String::NewSymbol("MAP1_NORMAL"), GetGL_MAP1_NORMAL);

     Gl->SetAccessor(String::NewSymbol("MAP1_TEXTURE_COORD_1"), GetGL_MAP1_TEXTURE_COORD_1);

     Gl->SetAccessor(String::NewSymbol("MAP1_TEXTURE_COORD_2"), GetGL_MAP1_TEXTURE_COORD_2);

     Gl->SetAccessor(String::NewSymbol("MAP1_TEXTURE_COORD_3"), GetGL_MAP1_TEXTURE_COORD_3);

     Gl->SetAccessor(String::NewSymbol("MAP1_TEXTURE_COORD_4"), GetGL_MAP1_TEXTURE_COORD_4);

     Gl->SetAccessor(String::NewSymbol("MAP1_VERTEX_3"), GetGL_MAP1_VERTEX_3);

     Gl->SetAccessor(String::NewSymbol("MAP1_VERTEX_4"), GetGL_MAP1_VERTEX_4);

     Gl->SetAccessor(String::NewSymbol("MAP2_COLOR_4"), GetGL_MAP2_COLOR_4);

     Gl->SetAccessor(String::NewSymbol("MAP2_INDEX"), GetGL_MAP2_INDEX);

     Gl->SetAccessor(String::NewSymbol("MAP2_NORMAL"), GetGL_MAP2_NORMAL);

     Gl->SetAccessor(String::NewSymbol("MAP2_TEXTURE_COORD_1"), GetGL_MAP2_TEXTURE_COORD_1);

     Gl->SetAccessor(String::NewSymbol("MAP2_TEXTURE_COORD_2"), GetGL_MAP2_TEXTURE_COORD_2);

     Gl->SetAccessor(String::NewSymbol("MAP2_TEXTURE_COORD_3"), GetGL_MAP2_TEXTURE_COORD_3);

     Gl->SetAccessor(String::NewSymbol("MAP2_TEXTURE_COORD_4"), GetGL_MAP2_TEXTURE_COORD_4);

     Gl->SetAccessor(String::NewSymbol("MAP2_VERTEX_3"), GetGL_MAP2_VERTEX_3);

     Gl->SetAccessor(String::NewSymbol("MAP2_VERTEX_4"), GetGL_MAP2_VERTEX_4);

     Gl->SetAccessor(String::NewSymbol("MAP1_GRID_DOMAIN"), GetGL_MAP1_GRID_DOMAIN);

     Gl->SetAccessor(String::NewSymbol("MAP1_GRID_SEGMENTS"), GetGL_MAP1_GRID_SEGMENTS);

     Gl->SetAccessor(String::NewSymbol("MAP2_GRID_DOMAIN"), GetGL_MAP2_GRID_DOMAIN);

     Gl->SetAccessor(String::NewSymbol("MAP2_GRID_SEGMENTS"), GetGL_MAP2_GRID_SEGMENTS);

     Gl->SetAccessor(String::NewSymbol("COEFF"), GetGL_COEFF);

     Gl->SetAccessor(String::NewSymbol("ORDER"), GetGL_ORDER);

     Gl->SetAccessor(String::NewSymbol("DOMAIN"), GetGL_DOMAIN);

     Gl->SetAccessor(String::NewSymbol("PERSPECTIVE_CORRECTION_HINT"), GetGL_PERSPECTIVE_CORRECTION_HINT);

     Gl->SetAccessor(String::NewSymbol("POINT_SMOOTH_HINT"), GetGL_POINT_SMOOTH_HINT);

     Gl->SetAccessor(String::NewSymbol("LINE_SMOOTH_HINT"), GetGL_LINE_SMOOTH_HINT);

     Gl->SetAccessor(String::NewSymbol("POLYGON_SMOOTH_HINT"), GetGL_POLYGON_SMOOTH_HINT);

     Gl->SetAccessor(String::NewSymbol("FOG_HINT"), GetGL_FOG_HINT);

     Gl->SetAccessor(String::NewSymbol("DONT_CARE"), GetGL_DONT_CARE);

     Gl->SetAccessor(String::NewSymbol("FASTEST"), GetGL_FASTEST);

     Gl->SetAccessor(String::NewSymbol("NICEST"), GetGL_NICEST);

     Gl->SetAccessor(String::NewSymbol("SCISSOR_BOX"), GetGL_SCISSOR_BOX);

     Gl->SetAccessor(String::NewSymbol("SCISSOR_TEST"), GetGL_SCISSOR_TEST);

     Gl->SetAccessor(String::NewSymbol("MAP_COLOR"), GetGL_MAP_COLOR);

     Gl->SetAccessor(String::NewSymbol("MAP_STENCIL"), GetGL_MAP_STENCIL);

     Gl->SetAccessor(String::NewSymbol("INDEX_SHIFT"), GetGL_INDEX_SHIFT);

     Gl->SetAccessor(String::NewSymbol("INDEX_OFFSET"), GetGL_INDEX_OFFSET);

     Gl->SetAccessor(String::NewSymbol("RED_SCALE"), GetGL_RED_SCALE);

     Gl->SetAccessor(String::NewSymbol("RED_BIAS"), GetGL_RED_BIAS);

     Gl->SetAccessor(String::NewSymbol("GREEN_SCALE"), GetGL_GREEN_SCALE);

     Gl->SetAccessor(String::NewSymbol("GREEN_BIAS"), GetGL_GREEN_BIAS);

     Gl->SetAccessor(String::NewSymbol("BLUE_SCALE"), GetGL_BLUE_SCALE);

     Gl->SetAccessor(String::NewSymbol("BLUE_BIAS"), GetGL_BLUE_BIAS);

     Gl->SetAccessor(String::NewSymbol("ALPHA_SCALE"), GetGL_ALPHA_SCALE);

     Gl->SetAccessor(String::NewSymbol("ALPHA_BIAS"), GetGL_ALPHA_BIAS);

     Gl->SetAccessor(String::NewSymbol("DEPTH_SCALE"), GetGL_DEPTH_SCALE);

     Gl->SetAccessor(String::NewSymbol("DEPTH_BIAS"), GetGL_DEPTH_BIAS);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_S_TO_S_SIZE"), GetGL_PIXEL_MAP_S_TO_S_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_I_SIZE"), GetGL_PIXEL_MAP_I_TO_I_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_R_SIZE"), GetGL_PIXEL_MAP_I_TO_R_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_G_SIZE"), GetGL_PIXEL_MAP_I_TO_G_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_B_SIZE"), GetGL_PIXEL_MAP_I_TO_B_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_A_SIZE"), GetGL_PIXEL_MAP_I_TO_A_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_R_TO_R_SIZE"), GetGL_PIXEL_MAP_R_TO_R_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_G_TO_G_SIZE"), GetGL_PIXEL_MAP_G_TO_G_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_B_TO_B_SIZE"), GetGL_PIXEL_MAP_B_TO_B_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_A_TO_A_SIZE"), GetGL_PIXEL_MAP_A_TO_A_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_S_TO_S"), GetGL_PIXEL_MAP_S_TO_S);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_I"), GetGL_PIXEL_MAP_I_TO_I);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_R"), GetGL_PIXEL_MAP_I_TO_R);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_G"), GetGL_PIXEL_MAP_I_TO_G);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_B"), GetGL_PIXEL_MAP_I_TO_B);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_A"), GetGL_PIXEL_MAP_I_TO_A);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_R_TO_R"), GetGL_PIXEL_MAP_R_TO_R);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_G_TO_G"), GetGL_PIXEL_MAP_G_TO_G);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_B_TO_B"), GetGL_PIXEL_MAP_B_TO_B);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_A_TO_A"), GetGL_PIXEL_MAP_A_TO_A);

     Gl->SetAccessor(String::NewSymbol("PACK_ALIGNMENT"), GetGL_PACK_ALIGNMENT);

     Gl->SetAccessor(String::NewSymbol("PACK_LSB_FIRST"), GetGL_PACK_LSB_FIRST);

     Gl->SetAccessor(String::NewSymbol("PACK_ROW_LENGTH"), GetGL_PACK_ROW_LENGTH);

     Gl->SetAccessor(String::NewSymbol("PACK_SKIP_PIXELS"), GetGL_PACK_SKIP_PIXELS);

     Gl->SetAccessor(String::NewSymbol("PACK_SKIP_ROWS"), GetGL_PACK_SKIP_ROWS);

     Gl->SetAccessor(String::NewSymbol("PACK_SWAP_BYTES"), GetGL_PACK_SWAP_BYTES);

     Gl->SetAccessor(String::NewSymbol("UNPACK_ALIGNMENT"), GetGL_UNPACK_ALIGNMENT);

     Gl->SetAccessor(String::NewSymbol("UNPACK_LSB_FIRST"), GetGL_UNPACK_LSB_FIRST);

     Gl->SetAccessor(String::NewSymbol("UNPACK_ROW_LENGTH"), GetGL_UNPACK_ROW_LENGTH);

     Gl->SetAccessor(String::NewSymbol("UNPACK_SKIP_PIXELS"), GetGL_UNPACK_SKIP_PIXELS);

     Gl->SetAccessor(String::NewSymbol("UNPACK_SKIP_ROWS"), GetGL_UNPACK_SKIP_ROWS);

     Gl->SetAccessor(String::NewSymbol("UNPACK_SWAP_BYTES"), GetGL_UNPACK_SWAP_BYTES);

     Gl->SetAccessor(String::NewSymbol("ZOOM_X"), GetGL_ZOOM_X);

     Gl->SetAccessor(String::NewSymbol("ZOOM_Y"), GetGL_ZOOM_Y);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_ENV"), GetGL_TEXTURE_ENV);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_ENV_MODE"), GetGL_TEXTURE_ENV_MODE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_1D"), GetGL_TEXTURE_1D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_2D"), GetGL_TEXTURE_2D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_WRAP_S"), GetGL_TEXTURE_WRAP_S);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_WRAP_T"), GetGL_TEXTURE_WRAP_T);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MAG_FILTER"), GetGL_TEXTURE_MAG_FILTER);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MIN_FILTER"), GetGL_TEXTURE_MIN_FILTER);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_ENV_COLOR"), GetGL_TEXTURE_ENV_COLOR);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_S"), GetGL_TEXTURE_GEN_S);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_T"), GetGL_TEXTURE_GEN_T);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_MODE"), GetGL_TEXTURE_GEN_MODE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BORDER_COLOR"), GetGL_TEXTURE_BORDER_COLOR);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_WIDTH"), GetGL_TEXTURE_WIDTH);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_HEIGHT"), GetGL_TEXTURE_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BORDER"), GetGL_TEXTURE_BORDER);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COMPONENTS"), GetGL_TEXTURE_COMPONENTS);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_RED_SIZE"), GetGL_TEXTURE_RED_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GREEN_SIZE"), GetGL_TEXTURE_GREEN_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BLUE_SIZE"), GetGL_TEXTURE_BLUE_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_ALPHA_SIZE"), GetGL_TEXTURE_ALPHA_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_LUMINANCE_SIZE"), GetGL_TEXTURE_LUMINANCE_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_INTENSITY_SIZE"), GetGL_TEXTURE_INTENSITY_SIZE);

     Gl->SetAccessor(String::NewSymbol("NEAREST_MIPMAP_NEAREST"), GetGL_NEAREST_MIPMAP_NEAREST);

     Gl->SetAccessor(String::NewSymbol("NEAREST_MIPMAP_LINEAR"), GetGL_NEAREST_MIPMAP_LINEAR);

     Gl->SetAccessor(String::NewSymbol("LINEAR_MIPMAP_NEAREST"), GetGL_LINEAR_MIPMAP_NEAREST);

     Gl->SetAccessor(String::NewSymbol("LINEAR_MIPMAP_LINEAR"), GetGL_LINEAR_MIPMAP_LINEAR);

     Gl->SetAccessor(String::NewSymbol("OBJECT_LINEAR"), GetGL_OBJECT_LINEAR);

     Gl->SetAccessor(String::NewSymbol("OBJECT_PLANE"), GetGL_OBJECT_PLANE);

     Gl->SetAccessor(String::NewSymbol("EYE_LINEAR"), GetGL_EYE_LINEAR);

     Gl->SetAccessor(String::NewSymbol("EYE_PLANE"), GetGL_EYE_PLANE);

     Gl->SetAccessor(String::NewSymbol("SPHERE_MAP"), GetGL_SPHERE_MAP);

     Gl->SetAccessor(String::NewSymbol("DECAL"), GetGL_DECAL);

     Gl->SetAccessor(String::NewSymbol("MODULATE"), GetGL_MODULATE);

     Gl->SetAccessor(String::NewSymbol("NEAREST"), GetGL_NEAREST);

     Gl->SetAccessor(String::NewSymbol("REPEAT"), GetGL_REPEAT);

     Gl->SetAccessor(String::NewSymbol("CLAMP"), GetGL_CLAMP);

     Gl->SetAccessor(String::NewSymbol("S"), GetGL_S);

     Gl->SetAccessor(String::NewSymbol("T"), GetGL_T);

     Gl->SetAccessor(String::NewSymbol("R"), GetGL_R);

     Gl->SetAccessor(String::NewSymbol("Q"), GetGL_Q);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_R"), GetGL_TEXTURE_GEN_R);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_Q"), GetGL_TEXTURE_GEN_Q);

     Gl->SetAccessor(String::NewSymbol("VENDOR"), GetGL_VENDOR);

     Gl->SetAccessor(String::NewSymbol("RENDERER"), GetGL_RENDERER);

     Gl->SetAccessor(String::NewSymbol("VERSION"), GetGL_VERSION);

     Gl->SetAccessor(String::NewSymbol("EXTENSIONS"), GetGL_EXTENSIONS);

     Gl->SetAccessor(String::NewSymbol("NO_ERROR"), GetGL_NO_ERROR);

     Gl->SetAccessor(String::NewSymbol("INVALID_ENUM"), GetGL_INVALID_ENUM);

     Gl->SetAccessor(String::NewSymbol("INVALID_VALUE"), GetGL_INVALID_VALUE);

     Gl->SetAccessor(String::NewSymbol("STACK_OVERFLOW"), GetGL_STACK_OVERFLOW);

     Gl->SetAccessor(String::NewSymbol("STACK_UNDERFLOW"), GetGL_STACK_UNDERFLOW);

     Gl->SetAccessor(String::NewSymbol("OUT_OF_MEMORY"), GetGL_OUT_OF_MEMORY);

     Gl->SetAccessor(String::NewSymbol("CURRENT_BIT"), GetGL_CURRENT_BIT);

     Gl->SetAccessor(String::NewSymbol("POINT_BIT"), GetGL_POINT_BIT);

     Gl->SetAccessor(String::NewSymbol("LINE_BIT"), GetGL_LINE_BIT);

     Gl->SetAccessor(String::NewSymbol("POLYGON_BIT"), GetGL_POLYGON_BIT);

     Gl->SetAccessor(String::NewSymbol("POLYGON_STIPPLE_BIT"), GetGL_POLYGON_STIPPLE_BIT);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MODE_BIT"), GetGL_PIXEL_MODE_BIT);

     Gl->SetAccessor(String::NewSymbol("LIGHTING_BIT"), GetGL_LIGHTING_BIT);

     Gl->SetAccessor(String::NewSymbol("FOG_BIT"), GetGL_FOG_BIT);

     Gl->SetAccessor(String::NewSymbol("DEPTH_BUFFER_BIT"), GetGL_DEPTH_BUFFER_BIT);

     Gl->SetAccessor(String::NewSymbol("ACCUM_BUFFER_BIT"), GetGL_ACCUM_BUFFER_BIT);

     Gl->SetAccessor(String::NewSymbol("STENCIL_BUFFER_BIT"), GetGL_STENCIL_BUFFER_BIT);

     Gl->SetAccessor(String::NewSymbol("VIEWPORT_BIT"), GetGL_VIEWPORT_BIT);

     Gl->SetAccessor(String::NewSymbol("TRANSFORM_BIT"), GetGL_TRANSFORM_BIT);

     Gl->SetAccessor(String::NewSymbol("ENABLE_BIT"), GetGL_ENABLE_BIT);

     Gl->SetAccessor(String::NewSymbol("COLOR_BUFFER_BIT"), GetGL_COLOR_BUFFER_BIT);

     Gl->SetAccessor(String::NewSymbol("HINT_BIT"), GetGL_HINT_BIT);

     Gl->SetAccessor(String::NewSymbol("EVAL_BIT"), GetGL_EVAL_BIT);

     Gl->SetAccessor(String::NewSymbol("LIST_BIT"), GetGL_LIST_BIT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BIT"), GetGL_TEXTURE_BIT);

     Gl->SetAccessor(String::NewSymbol("SCISSOR_BIT"), GetGL_SCISSOR_BIT);

     Gl->SetAccessor(String::NewSymbol("ALL_ATTRIB_BITS"), GetGL_ALL_ATTRIB_BITS);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_1D"), GetGL_PROXY_TEXTURE_1D);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_2D"), GetGL_PROXY_TEXTURE_2D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_PRIORITY"), GetGL_TEXTURE_PRIORITY);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_RESIDENT"), GetGL_TEXTURE_RESIDENT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_1D"), GetGL_TEXTURE_BINDING_1D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_2D"), GetGL_TEXTURE_BINDING_2D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_INTERNAL_FORMAT"), GetGL_TEXTURE_INTERNAL_FORMAT);

     Gl->SetAccessor(String::NewSymbol("ALPHA4"), GetGL_ALPHA4);

     Gl->SetAccessor(String::NewSymbol("ALPHA8"), GetGL_ALPHA8);

     Gl->SetAccessor(String::NewSymbol("ALPHA12"), GetGL_ALPHA12);

     Gl->SetAccessor(String::NewSymbol("ALPHA16"), GetGL_ALPHA16);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE4"), GetGL_LUMINANCE4);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE8"), GetGL_LUMINANCE8);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE12"), GetGL_LUMINANCE12);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE16"), GetGL_LUMINANCE16);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE4_ALPHA4"), GetGL_LUMINANCE4_ALPHA4);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE6_ALPHA2"), GetGL_LUMINANCE6_ALPHA2);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE8_ALPHA8"), GetGL_LUMINANCE8_ALPHA8);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE12_ALPHA4"), GetGL_LUMINANCE12_ALPHA4);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE12_ALPHA12"), GetGL_LUMINANCE12_ALPHA12);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE16_ALPHA16"), GetGL_LUMINANCE16_ALPHA16);

     Gl->SetAccessor(String::NewSymbol("INTENSITY"), GetGL_INTENSITY);

     Gl->SetAccessor(String::NewSymbol("INTENSITY4"), GetGL_INTENSITY4);

     Gl->SetAccessor(String::NewSymbol("INTENSITY8"), GetGL_INTENSITY8);

     Gl->SetAccessor(String::NewSymbol("INTENSITY12"), GetGL_INTENSITY12);

     Gl->SetAccessor(String::NewSymbol("INTENSITY16"), GetGL_INTENSITY16);

     Gl->SetAccessor(String::NewSymbol("R3_G3_B2"), GetGL_R3_G3_B2);

     Gl->SetAccessor(String::NewSymbol("RGB4"), GetGL_RGB4);

     Gl->SetAccessor(String::NewSymbol("RGB5"), GetGL_RGB5);

     Gl->SetAccessor(String::NewSymbol("RGB8"), GetGL_RGB8);

     Gl->SetAccessor(String::NewSymbol("RGB10"), GetGL_RGB10);

     Gl->SetAccessor(String::NewSymbol("RGB12"), GetGL_RGB12);

     Gl->SetAccessor(String::NewSymbol("RGB16"), GetGL_RGB16);

     Gl->SetAccessor(String::NewSymbol("RGBA2"), GetGL_RGBA2);

     Gl->SetAccessor(String::NewSymbol("RGBA4"), GetGL_RGBA4);

     Gl->SetAccessor(String::NewSymbol("RGB5_A1"), GetGL_RGB5_A1);

     Gl->SetAccessor(String::NewSymbol("RGBA8"), GetGL_RGBA8);

     Gl->SetAccessor(String::NewSymbol("RGB10_A2"), GetGL_RGB10_A2);

     Gl->SetAccessor(String::NewSymbol("RGBA12"), GetGL_RGBA12);

     Gl->SetAccessor(String::NewSymbol("RGBA16"), GetGL_RGBA16);

     Gl->SetAccessor(String::NewSymbol("CLIENT_PIXEL_STORE_BIT"), GetGL_CLIENT_PIXEL_STORE_BIT);

     Gl->SetAccessor(String::NewSymbol("CLIENT_VERTEX_ARRAY_BIT"), GetGL_CLIENT_VERTEX_ARRAY_BIT);

     Gl->SetAccessor(String::NewSymbol("ALL_CLIENT_ATTRIB_BITS"), GetGL_ALL_CLIENT_ATTRIB_BITS);

     Gl->SetAccessor(String::NewSymbol("CLIENT_ALL_ATTRIB_BITS"), GetGL_CLIENT_ALL_ATTRIB_BITS);

     Gl->SetAccessor(String::NewSymbol("RESCALE_NORMAL"), GetGL_RESCALE_NORMAL);

     Gl->SetAccessor(String::NewSymbol("CLAMP_TO_EDGE"), GetGL_CLAMP_TO_EDGE);

     Gl->SetAccessor(String::NewSymbol("MAX_ELEMENTS_VERTICES"), GetGL_MAX_ELEMENTS_VERTICES);

     Gl->SetAccessor(String::NewSymbol("MAX_ELEMENTS_INDICES"), GetGL_MAX_ELEMENTS_INDICES);

     Gl->SetAccessor(String::NewSymbol("BGR"), GetGL_BGR);

     Gl->SetAccessor(String::NewSymbol("BGRA"), GetGL_BGRA);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_BYTE_3_3_2"), GetGL_UNSIGNED_BYTE_3_3_2);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_BYTE_2_3_3_REV"), GetGL_UNSIGNED_BYTE_2_3_3_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_5_6_5"), GetGL_UNSIGNED_SHORT_5_6_5);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_5_6_5_REV"), GetGL_UNSIGNED_SHORT_5_6_5_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_4_4_4_4"), GetGL_UNSIGNED_SHORT_4_4_4_4);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_4_4_4_4_REV"), GetGL_UNSIGNED_SHORT_4_4_4_4_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_5_5_5_1"), GetGL_UNSIGNED_SHORT_5_5_5_1);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_1_5_5_5_REV"), GetGL_UNSIGNED_SHORT_1_5_5_5_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_8_8_8_8"), GetGL_UNSIGNED_INT_8_8_8_8);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_8_8_8_8_REV"), GetGL_UNSIGNED_INT_8_8_8_8_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_10_10_10_2"), GetGL_UNSIGNED_INT_10_10_10_2);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_2_10_10_10_REV"), GetGL_UNSIGNED_INT_2_10_10_10_REV);

     Gl->SetAccessor(String::NewSymbol("LIGHT_MODEL_COLOR_CONTROL"), GetGL_LIGHT_MODEL_COLOR_CONTROL);

     Gl->SetAccessor(String::NewSymbol("SINGLE_COLOR"), GetGL_SINGLE_COLOR);

     Gl->SetAccessor(String::NewSymbol("SEPARATE_SPECULAR_COLOR"), GetGL_SEPARATE_SPECULAR_COLOR);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MIN_LOD"), GetGL_TEXTURE_MIN_LOD);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MAX_LOD"), GetGL_TEXTURE_MAX_LOD);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BASE_LEVEL"), GetGL_TEXTURE_BASE_LEVEL);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MAX_LEVEL"), GetGL_TEXTURE_MAX_LEVEL);

     Gl->SetAccessor(String::NewSymbol("SMOOTH_POINT_SIZE_RANGE"), GetGL_SMOOTH_POINT_SIZE_RANGE);

     Gl->SetAccessor(String::NewSymbol("SMOOTH_POINT_SIZE_GRANULARITY"), GetGL_SMOOTH_POINT_SIZE_GRANULARITY);

     Gl->SetAccessor(String::NewSymbol("SMOOTH_LINE_WIDTH_RANGE"), GetGL_SMOOTH_LINE_WIDTH_RANGE);

     Gl->SetAccessor(String::NewSymbol("SMOOTH_LINE_WIDTH_GRANULARITY"), GetGL_SMOOTH_LINE_WIDTH_GRANULARITY);

     Gl->SetAccessor(String::NewSymbol("ALIASED_POINT_SIZE_RANGE"), GetGL_ALIASED_POINT_SIZE_RANGE);

     Gl->SetAccessor(String::NewSymbol("ALIASED_LINE_WIDTH_RANGE"), GetGL_ALIASED_LINE_WIDTH_RANGE);

     Gl->SetAccessor(String::NewSymbol("PACK_SKIP_IMAGES"), GetGL_PACK_SKIP_IMAGES);

     Gl->SetAccessor(String::NewSymbol("PACK_IMAGE_HEIGHT"), GetGL_PACK_IMAGE_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("UNPACK_SKIP_IMAGES"), GetGL_UNPACK_SKIP_IMAGES);

     Gl->SetAccessor(String::NewSymbol("UNPACK_IMAGE_HEIGHT"), GetGL_UNPACK_IMAGE_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_3D"), GetGL_TEXTURE_3D);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_3D"), GetGL_PROXY_TEXTURE_3D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_DEPTH"), GetGL_TEXTURE_DEPTH);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_WRAP_R"), GetGL_TEXTURE_WRAP_R);

     Gl->SetAccessor(String::NewSymbol("MAX_3D_TEXTURE_SIZE"), GetGL_MAX_3D_TEXTURE_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_3D"), GetGL_TEXTURE_BINDING_3D);

     Gl->SetAccessor(String::NewSymbol("CONSTANT_COLOR"), GetGL_CONSTANT_COLOR);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_CONSTANT_COLOR"), GetGL_ONE_MINUS_CONSTANT_COLOR);

     Gl->SetAccessor(String::NewSymbol("CONSTANT_ALPHA"), GetGL_CONSTANT_ALPHA);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_CONSTANT_ALPHA"), GetGL_ONE_MINUS_CONSTANT_ALPHA);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE"), GetGL_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_COLOR_TABLE"), GetGL_POST_CONVOLUTION_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_COLOR_TABLE"), GetGL_POST_COLOR_MATRIX_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("PROXY_COLOR_TABLE"), GetGL_PROXY_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("PROXY_POST_CONVOLUTION_COLOR_TABLE"), GetGL_PROXY_POST_CONVOLUTION_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("PROXY_POST_COLOR_MATRIX_COLOR_TABLE"), GetGL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_SCALE"), GetGL_COLOR_TABLE_SCALE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_BIAS"), GetGL_COLOR_TABLE_BIAS);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_FORMAT"), GetGL_COLOR_TABLE_FORMAT);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_WIDTH"), GetGL_COLOR_TABLE_WIDTH);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_RED_SIZE"), GetGL_COLOR_TABLE_RED_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_GREEN_SIZE"), GetGL_COLOR_TABLE_GREEN_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_BLUE_SIZE"), GetGL_COLOR_TABLE_BLUE_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_ALPHA_SIZE"), GetGL_COLOR_TABLE_ALPHA_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_LUMINANCE_SIZE"), GetGL_COLOR_TABLE_LUMINANCE_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_INTENSITY_SIZE"), GetGL_COLOR_TABLE_INTENSITY_SIZE);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_1D"), GetGL_CONVOLUTION_1D);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_2D"), GetGL_CONVOLUTION_2D);

     Gl->SetAccessor(String::NewSymbol("SEPARABLE_2D"), GetGL_SEPARABLE_2D);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_BORDER_MODE"), GetGL_CONVOLUTION_BORDER_MODE);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_FILTER_SCALE"), GetGL_CONVOLUTION_FILTER_SCALE);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_FILTER_BIAS"), GetGL_CONVOLUTION_FILTER_BIAS);

     Gl->SetAccessor(String::NewSymbol("REDUCE"), GetGL_REDUCE);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_FORMAT"), GetGL_CONVOLUTION_FORMAT);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_WIDTH"), GetGL_CONVOLUTION_WIDTH);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_HEIGHT"), GetGL_CONVOLUTION_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("MAX_CONVOLUTION_WIDTH"), GetGL_MAX_CONVOLUTION_WIDTH);

     Gl->SetAccessor(String::NewSymbol("MAX_CONVOLUTION_HEIGHT"), GetGL_MAX_CONVOLUTION_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_RED_SCALE"), GetGL_POST_CONVOLUTION_RED_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_GREEN_SCALE"), GetGL_POST_CONVOLUTION_GREEN_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_BLUE_SCALE"), GetGL_POST_CONVOLUTION_BLUE_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_ALPHA_SCALE"), GetGL_POST_CONVOLUTION_ALPHA_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_RED_BIAS"), GetGL_POST_CONVOLUTION_RED_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_GREEN_BIAS"), GetGL_POST_CONVOLUTION_GREEN_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_BLUE_BIAS"), GetGL_POST_CONVOLUTION_BLUE_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_ALPHA_BIAS"), GetGL_POST_CONVOLUTION_ALPHA_BIAS);

     Gl->SetAccessor(String::NewSymbol("CONSTANT_BORDER"), GetGL_CONSTANT_BORDER);

     Gl->SetAccessor(String::NewSymbol("REPLICATE_BORDER"), GetGL_REPLICATE_BORDER);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_BORDER_COLOR"), GetGL_CONVOLUTION_BORDER_COLOR);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATRIX"), GetGL_COLOR_MATRIX);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATRIX_STACK_DEPTH"), GetGL_COLOR_MATRIX_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_COLOR_MATRIX_STACK_DEPTH"), GetGL_MAX_COLOR_MATRIX_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_RED_SCALE"), GetGL_POST_COLOR_MATRIX_RED_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_GREEN_SCALE"), GetGL_POST_COLOR_MATRIX_GREEN_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_BLUE_SCALE"), GetGL_POST_COLOR_MATRIX_BLUE_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_ALPHA_SCALE"), GetGL_POST_COLOR_MATRIX_ALPHA_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_RED_BIAS"), GetGL_POST_COLOR_MATRIX_RED_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_GREEN_BIAS"), GetGL_POST_COLOR_MATRIX_GREEN_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_BLUE_BIAS"), GetGL_POST_COLOR_MATRIX_BLUE_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_ALPHA_BIAS"), GetGL_POST_COLOR_MATRIX_ALPHA_BIAS);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM"), GetGL_HISTOGRAM);

     Gl->SetAccessor(String::NewSymbol("PROXY_HISTOGRAM"), GetGL_PROXY_HISTOGRAM);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_WIDTH"), GetGL_HISTOGRAM_WIDTH);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_FORMAT"), GetGL_HISTOGRAM_FORMAT);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_RED_SIZE"), GetGL_HISTOGRAM_RED_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_GREEN_SIZE"), GetGL_HISTOGRAM_GREEN_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_BLUE_SIZE"), GetGL_HISTOGRAM_BLUE_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_ALPHA_SIZE"), GetGL_HISTOGRAM_ALPHA_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_LUMINANCE_SIZE"), GetGL_HISTOGRAM_LUMINANCE_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_SINK"), GetGL_HISTOGRAM_SINK);

     Gl->SetAccessor(String::NewSymbol("MINMAX"), GetGL_MINMAX);

     Gl->SetAccessor(String::NewSymbol("MINMAX_FORMAT"), GetGL_MINMAX_FORMAT);

     Gl->SetAccessor(String::NewSymbol("MINMAX_SINK"), GetGL_MINMAX_SINK);

     Gl->SetAccessor(String::NewSymbol("TABLE_TOO_LARGE"), GetGL_TABLE_TOO_LARGE);

     Gl->SetAccessor(String::NewSymbol("MIN"), GetGL_MIN);

     Gl->SetAccessor(String::NewSymbol("MAX"), GetGL_MAX);

     Gl->SetAccessor(String::NewSymbol("FUNC_ADD"), GetGL_FUNC_ADD);

     Gl->SetAccessor(String::NewSymbol("FUNC_SUBTRACT"), GetGL_FUNC_SUBTRACT);

     Gl->SetAccessor(String::NewSymbol("FUNC_REVERSE_SUBTRACT"), GetGL_FUNC_REVERSE_SUBTRACT);

     Gl->SetAccessor(String::NewSymbol("BLEND_COLOR"), GetGL_BLEND_COLOR);

     Gl->SetAccessor(String::NewSymbol("TEXTURE0"), GetGL_TEXTURE0);

     Gl->SetAccessor(String::NewSymbol("TEXTURE1"), GetGL_TEXTURE1);

     Gl->SetAccessor(String::NewSymbol("TEXTURE2"), GetGL_TEXTURE2);

     Gl->SetAccessor(String::NewSymbol("TEXTURE3"), GetGL_TEXTURE3);

     Gl->SetAccessor(String::NewSymbol("TEXTURE4"), GetGL_TEXTURE4);

     Gl->SetAccessor(String::NewSymbol("TEXTURE5"), GetGL_TEXTURE5);

     Gl->SetAccessor(String::NewSymbol("TEXTURE6"), GetGL_TEXTURE6);

     Gl->SetAccessor(String::NewSymbol("TEXTURE7"), GetGL_TEXTURE7);

     Gl->SetAccessor(String::NewSymbol("TEXTURE8"), GetGL_TEXTURE8);

     Gl->SetAccessor(String::NewSymbol("TEXTURE9"), GetGL_TEXTURE9);

     Gl->SetAccessor(String::NewSymbol("TEXTURE10"), GetGL_TEXTURE10);

     Gl->SetAccessor(String::NewSymbol("TEXTURE11"), GetGL_TEXTURE11);

     Gl->SetAccessor(String::NewSymbol("TEXTURE12"), GetGL_TEXTURE12);

     Gl->SetAccessor(String::NewSymbol("TEXTURE13"), GetGL_TEXTURE13);

     Gl->SetAccessor(String::NewSymbol("TEXTURE14"), GetGL_TEXTURE14);

     Gl->SetAccessor(String::NewSymbol("TEXTURE15"), GetGL_TEXTURE15);

     Gl->SetAccessor(String::NewSymbol("TEXTURE16"), GetGL_TEXTURE16);

     Gl->SetAccessor(String::NewSymbol("TEXTURE17"), GetGL_TEXTURE17);

     Gl->SetAccessor(String::NewSymbol("TEXTURE18"), GetGL_TEXTURE18);

     Gl->SetAccessor(String::NewSymbol("TEXTURE19"), GetGL_TEXTURE19);

     Gl->SetAccessor(String::NewSymbol("TEXTURE20"), GetGL_TEXTURE20);

     Gl->SetAccessor(String::NewSymbol("TEXTURE21"), GetGL_TEXTURE21);

     Gl->SetAccessor(String::NewSymbol("TEXTURE22"), GetGL_TEXTURE22);

     Gl->SetAccessor(String::NewSymbol("TEXTURE23"), GetGL_TEXTURE23);

     Gl->SetAccessor(String::NewSymbol("TEXTURE24"), GetGL_TEXTURE24);

     Gl->SetAccessor(String::NewSymbol("TEXTURE25"), GetGL_TEXTURE25);

     Gl->SetAccessor(String::NewSymbol("TEXTURE26"), GetGL_TEXTURE26);

     Gl->SetAccessor(String::NewSymbol("TEXTURE27"), GetGL_TEXTURE27);

     Gl->SetAccessor(String::NewSymbol("TEXTURE28"), GetGL_TEXTURE28);

     Gl->SetAccessor(String::NewSymbol("TEXTURE29"), GetGL_TEXTURE29);

     Gl->SetAccessor(String::NewSymbol("TEXTURE30"), GetGL_TEXTURE30);

     Gl->SetAccessor(String::NewSymbol("TEXTURE31"), GetGL_TEXTURE31);

     Gl->SetAccessor(String::NewSymbol("ACTIVE_TEXTURE"), GetGL_ACTIVE_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("CLIENT_ACTIVE_TEXTURE"), GetGL_CLIENT_ACTIVE_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("MAX_TEXTURE_UNITS"), GetGL_MAX_TEXTURE_UNITS);

     Gl->SetAccessor(String::NewSymbol("NORMAL_MAP"), GetGL_NORMAL_MAP);

     Gl->SetAccessor(String::NewSymbol("REFLECTION_MAP"), GetGL_REFLECTION_MAP);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP"), GetGL_TEXTURE_CUBE_MAP);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_CUBE_MAP"), GetGL_TEXTURE_BINDING_CUBE_MAP);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_POSITIVE_X"), GetGL_TEXTURE_CUBE_MAP_POSITIVE_X);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_POSITIVE_Y"), GetGL_TEXTURE_CUBE_MAP_POSITIVE_Y);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_POSITIVE_Z"), GetGL_TEXTURE_CUBE_MAP_POSITIVE_Z);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_CUBE_MAP"), GetGL_PROXY_TEXTURE_CUBE_MAP);

     Gl->SetAccessor(String::NewSymbol("MAX_CUBE_MAP_TEXTURE_SIZE"), GetGL_MAX_CUBE_MAP_TEXTURE_SIZE);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_ALPHA"), GetGL_COMPRESSED_ALPHA);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_LUMINANCE"), GetGL_COMPRESSED_LUMINANCE);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_LUMINANCE_ALPHA"), GetGL_COMPRESSED_LUMINANCE_ALPHA);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_INTENSITY"), GetGL_COMPRESSED_INTENSITY);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_RGB"), GetGL_COMPRESSED_RGB);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_RGBA"), GetGL_COMPRESSED_RGBA);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COMPRESSION_HINT"), GetGL_TEXTURE_COMPRESSION_HINT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COMPRESSED_IMAGE_SIZE"), GetGL_TEXTURE_COMPRESSED_IMAGE_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COMPRESSED"), GetGL_TEXTURE_COMPRESSED);

     Gl->SetAccessor(String::NewSymbol("NUM_COMPRESSED_TEXTURE_FORMATS"), GetGL_NUM_COMPRESSED_TEXTURE_FORMATS);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_TEXTURE_FORMATS"), GetGL_COMPRESSED_TEXTURE_FORMATS);

     Gl->SetAccessor(String::NewSymbol("MULTISAMPLE"), GetGL_MULTISAMPLE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_ALPHA_TO_COVERAGE"), GetGL_SAMPLE_ALPHA_TO_COVERAGE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_ALPHA_TO_ONE"), GetGL_SAMPLE_ALPHA_TO_ONE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_COVERAGE"), GetGL_SAMPLE_COVERAGE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_BUFFERS"), GetGL_SAMPLE_BUFFERS);

     Gl->SetAccessor(String::NewSymbol("SAMPLES"), GetGL_SAMPLES);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_COVERAGE_VALUE"), GetGL_SAMPLE_COVERAGE_VALUE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_COVERAGE_INVERT"), GetGL_SAMPLE_COVERAGE_INVERT);

     Gl->SetAccessor(String::NewSymbol("MULTISAMPLE_BIT"), GetGL_MULTISAMPLE_BIT);

     Gl->SetAccessor(String::NewSymbol("TRANSPOSE_MODELVIEW_MATRIX"), GetGL_TRANSPOSE_MODELVIEW_MATRIX);

     Gl->SetAccessor(String::NewSymbol("TRANSPOSE_PROJECTION_MATRIX"), GetGL_TRANSPOSE_PROJECTION_MATRIX);

     Gl->SetAccessor(String::NewSymbol("TRANSPOSE_TEXTURE_MATRIX"), GetGL_TRANSPOSE_TEXTURE_MATRIX);

     Gl->SetAccessor(String::NewSymbol("TRANSPOSE_COLOR_MATRIX"), GetGL_TRANSPOSE_COLOR_MATRIX);

     Gl->SetAccessor(String::NewSymbol("COMBINE"), GetGL_COMBINE);

     Gl->SetAccessor(String::NewSymbol("COMBINE_RGB"), GetGL_COMBINE_RGB);

     Gl->SetAccessor(String::NewSymbol("COMBINE_ALPHA"), GetGL_COMBINE_ALPHA);

     Gl->SetAccessor(String::NewSymbol("SOURCE0_RGB"), GetGL_SOURCE0_RGB);

     Gl->SetAccessor(String::NewSymbol("SOURCE1_RGB"), GetGL_SOURCE1_RGB);

     Gl->SetAccessor(String::NewSymbol("SOURCE2_RGB"), GetGL_SOURCE2_RGB);

     Gl->SetAccessor(String::NewSymbol("SOURCE0_ALPHA"), GetGL_SOURCE0_ALPHA);

     Gl->SetAccessor(String::NewSymbol("SOURCE1_ALPHA"), GetGL_SOURCE1_ALPHA);

     Gl->SetAccessor(String::NewSymbol("SOURCE2_ALPHA"), GetGL_SOURCE2_ALPHA);

     Gl->SetAccessor(String::NewSymbol("OPERAND0_RGB"), GetGL_OPERAND0_RGB);

     Gl->SetAccessor(String::NewSymbol("OPERAND1_RGB"), GetGL_OPERAND1_RGB);

     Gl->SetAccessor(String::NewSymbol("OPERAND2_RGB"), GetGL_OPERAND2_RGB);

     Gl->SetAccessor(String::NewSymbol("OPERAND0_ALPHA"), GetGL_OPERAND0_ALPHA);

     Gl->SetAccessor(String::NewSymbol("OPERAND1_ALPHA"), GetGL_OPERAND1_ALPHA);

     Gl->SetAccessor(String::NewSymbol("OPERAND2_ALPHA"), GetGL_OPERAND2_ALPHA);

     Gl->SetAccessor(String::NewSymbol("RGB_SCALE"), GetGL_RGB_SCALE);

     Gl->SetAccessor(String::NewSymbol("ADD_SIGNED"), GetGL_ADD_SIGNED);

     Gl->SetAccessor(String::NewSymbol("INTERPOLATE"), GetGL_INTERPOLATE);

     Gl->SetAccessor(String::NewSymbol("SUBTRACT"), GetGL_SUBTRACT);

     Gl->SetAccessor(String::NewSymbol("CONSTANT"), GetGL_CONSTANT);

     Gl->SetAccessor(String::NewSymbol("PRIMARY_COLOR"), GetGL_PRIMARY_COLOR);

     Gl->SetAccessor(String::NewSymbol("PREVIOUS"), GetGL_PREVIOUS);

     Gl->SetAccessor(String::NewSymbol("DOT3_RGB"), GetGL_DOT3_RGB);

     Gl->SetAccessor(String::NewSymbol("DOT3_RGBA"), GetGL_DOT3_RGBA);

     Gl->SetAccessor(String::NewSymbol("CLAMP_TO_BORDER"), GetGL_CLAMP_TO_BORDER);

     Gl->SetAccessor(String::NewSymbol("ARB_multitexture"), GetGL_ARB_multitexture);

     Gl->SetAccessor(String::NewSymbol("TEXTURE0_ARB"), GetGL_TEXTURE0_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE1_ARB"), GetGL_TEXTURE1_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE2_ARB"), GetGL_TEXTURE2_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE3_ARB"), GetGL_TEXTURE3_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE4_ARB"), GetGL_TEXTURE4_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE5_ARB"), GetGL_TEXTURE5_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE6_ARB"), GetGL_TEXTURE6_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE7_ARB"), GetGL_TEXTURE7_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE8_ARB"), GetGL_TEXTURE8_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE9_ARB"), GetGL_TEXTURE9_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE10_ARB"), GetGL_TEXTURE10_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE11_ARB"), GetGL_TEXTURE11_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE12_ARB"), GetGL_TEXTURE12_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE13_ARB"), GetGL_TEXTURE13_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE14_ARB"), GetGL_TEXTURE14_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE15_ARB"), GetGL_TEXTURE15_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE16_ARB"), GetGL_TEXTURE16_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE17_ARB"), GetGL_TEXTURE17_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE18_ARB"), GetGL_TEXTURE18_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE19_ARB"), GetGL_TEXTURE19_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE20_ARB"), GetGL_TEXTURE20_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE21_ARB"), GetGL_TEXTURE21_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE22_ARB"), GetGL_TEXTURE22_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE23_ARB"), GetGL_TEXTURE23_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE24_ARB"), GetGL_TEXTURE24_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE25_ARB"), GetGL_TEXTURE25_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE26_ARB"), GetGL_TEXTURE26_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE27_ARB"), GetGL_TEXTURE27_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE28_ARB"), GetGL_TEXTURE28_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE29_ARB"), GetGL_TEXTURE29_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE30_ARB"), GetGL_TEXTURE30_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE31_ARB"), GetGL_TEXTURE31_ARB);

     Gl->SetAccessor(String::NewSymbol("ACTIVE_TEXTURE_ARB"), GetGL_ACTIVE_TEXTURE_ARB);

     Gl->SetAccessor(String::NewSymbol("CLIENT_ACTIVE_TEXTURE_ARB"), GetGL_CLIENT_ACTIVE_TEXTURE_ARB);

     Gl->SetAccessor(String::NewSymbol("MAX_TEXTURE_UNITS_ARB"), GetGL_MAX_TEXTURE_UNITS_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_1D_ARRAY_EXT"), GetGL_TEXTURE_1D_ARRAY_EXT);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_1D_ARRAY_EXT"), GetGL_PROXY_TEXTURE_1D_ARRAY_EXT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_2D_ARRAY_EXT"), GetGL_TEXTURE_2D_ARRAY_EXT);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_2D_ARRAY_EXT"), GetGL_PROXY_TEXTURE_2D_ARRAY_EXT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_1D_ARRAY_EXT"), GetGL_TEXTURE_BINDING_1D_ARRAY_EXT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_2D_ARRAY_EXT"), GetGL_TEXTURE_BINDING_2D_ARRAY_EXT);

     Gl->SetAccessor(String::NewSymbol("MAX_ARRAY_TEXTURE_LAYERS_EXT"), GetGL_MAX_ARRAY_TEXTURE_LAYERS_EXT);

     Gl->SetAccessor(String::NewSymbol("FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT"), GetGL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER_EXT);

     Gl->Set(String::NewSymbol("ClearIndex"), FunctionTemplate::New(GLglClearIndexCallback));

     Gl->Set(String::NewSymbol("ClearColor"), FunctionTemplate::New(GLglClearColorCallback));

     Gl->Set(String::NewSymbol("Clear"), FunctionTemplate::New(GLglClearCallback));

     Gl->Set(String::NewSymbol("IndexMask"), FunctionTemplate::New(GLglIndexMaskCallback));

     Gl->Set(String::NewSymbol("ColorMask"), FunctionTemplate::New(GLglColorMaskCallback));

     Gl->Set(String::NewSymbol("AlphaFunc"), FunctionTemplate::New(GLglAlphaFuncCallback));

     Gl->Set(String::NewSymbol("BlendFunc"), FunctionTemplate::New(GLglBlendFuncCallback));

     Gl->Set(String::NewSymbol("LogicOp"), FunctionTemplate::New(GLglLogicOpCallback));

     Gl->Set(String::NewSymbol("CullFace"), FunctionTemplate::New(GLglCullFaceCallback));

     Gl->Set(String::NewSymbol("FrontFace"), FunctionTemplate::New(GLglFrontFaceCallback));

     Gl->Set(String::NewSymbol("PointSize"), FunctionTemplate::New(GLglPointSizeCallback));

     Gl->Set(String::NewSymbol("LineWidth"), FunctionTemplate::New(GLglLineWidthCallback));

     Gl->Set(String::NewSymbol("LineStipple"), FunctionTemplate::New(GLglLineStippleCallback));

     Gl->Set(String::NewSymbol("PolygonMode"), FunctionTemplate::New(GLglPolygonModeCallback));

     Gl->Set(String::NewSymbol("PolygonOffset"), FunctionTemplate::New(GLglPolygonOffsetCallback));

     Gl->Set(String::NewSymbol("PolygonStipple"), FunctionTemplate::New(GLglPolygonStippleCallback));

     Gl->Set(String::NewSymbol("GetPolygonStipple"), FunctionTemplate::New(GLglGetPolygonStippleCallback));

     Gl->Set(String::NewSymbol("EdgeFlag"), FunctionTemplate::New(GLglEdgeFlagCallback));

     Gl->Set(String::NewSymbol("EdgeFlagv"), FunctionTemplate::New(GLglEdgeFlagvCallback));

     Gl->Set(String::NewSymbol("Scissor"), FunctionTemplate::New(GLglScissorCallback));

     Gl->Set(String::NewSymbol("ClipPlane"), FunctionTemplate::New(GLglClipPlaneCallback));

     Gl->Set(String::NewSymbol("GetClipPlane"), FunctionTemplate::New(GLglGetClipPlaneCallback));

     Gl->Set(String::NewSymbol("DrawBuffer"), FunctionTemplate::New(GLglDrawBufferCallback));

     Gl->Set(String::NewSymbol("ReadBuffer"), FunctionTemplate::New(GLglReadBufferCallback));

     Gl->Set(String::NewSymbol("Enable"), FunctionTemplate::New(GLglEnableCallback));

     Gl->Set(String::NewSymbol("Disable"), FunctionTemplate::New(GLglDisableCallback));

     Gl->Set(String::NewSymbol("IsEnabled"), FunctionTemplate::New(GLglIsEnabledCallback));

     Gl->Set(String::NewSymbol("EnableClientState"), FunctionTemplate::New(GLglEnableClientStateCallback));

     Gl->Set(String::NewSymbol("DisableClientState"), FunctionTemplate::New(GLglDisableClientStateCallback));

     Gl->Set(String::NewSymbol("GetBooleanv"), FunctionTemplate::New(GLglGetBooleanvCallback));

     Gl->Set(String::NewSymbol("GetDoublev"), FunctionTemplate::New(GLglGetDoublevCallback));

     Gl->Set(String::NewSymbol("GetFloatv"), FunctionTemplate::New(GLglGetFloatvCallback));

     Gl->Set(String::NewSymbol("GetIntegerv"), FunctionTemplate::New(GLglGetIntegervCallback));

     Gl->Set(String::NewSymbol("PushAttrib"), FunctionTemplate::New(GLglPushAttribCallback));

     Gl->Set(String::NewSymbol("PopAttrib"), FunctionTemplate::New(GLglPopAttribCallback));

     Gl->Set(String::NewSymbol("PushClientAttrib"), FunctionTemplate::New(GLglPushClientAttribCallback));

     Gl->Set(String::NewSymbol("PopClientAttrib"), FunctionTemplate::New(GLglPopClientAttribCallback));

     Gl->Set(String::NewSymbol("RenderMode"), FunctionTemplate::New(GLglRenderModeCallback));

     Gl->Set(String::NewSymbol("GetError"), FunctionTemplate::New(GLglGetErrorCallback));

     Gl->Set(String::NewSymbol("Finish"), FunctionTemplate::New(GLglFinishCallback));

     Gl->Set(String::NewSymbol("Flush"), FunctionTemplate::New(GLglFlushCallback));

     Gl->Set(String::NewSymbol("Hint"), FunctionTemplate::New(GLglHintCallback));

     Gl->Set(String::NewSymbol("ClearDepth"), FunctionTemplate::New(GLglClearDepthCallback));

     Gl->Set(String::NewSymbol("DepthFunc"), FunctionTemplate::New(GLglDepthFuncCallback));

     Gl->Set(String::NewSymbol("DepthMask"), FunctionTemplate::New(GLglDepthMaskCallback));

     Gl->Set(String::NewSymbol("DepthRange"), FunctionTemplate::New(GLglDepthRangeCallback));

     Gl->Set(String::NewSymbol("ClearAccum"), FunctionTemplate::New(GLglClearAccumCallback));

     Gl->Set(String::NewSymbol("Accum"), FunctionTemplate::New(GLglAccumCallback));

     Gl->Set(String::NewSymbol("MatrixMode"), FunctionTemplate::New(GLglMatrixModeCallback));

     Gl->Set(String::NewSymbol("Ortho"), FunctionTemplate::New(GLglOrthoCallback));

     Gl->Set(String::NewSymbol("Frustum"), FunctionTemplate::New(GLglFrustumCallback));

     Gl->Set(String::NewSymbol("Viewport"), FunctionTemplate::New(GLglViewportCallback));

     Gl->Set(String::NewSymbol("PushMatrix"), FunctionTemplate::New(GLglPushMatrixCallback));

     Gl->Set(String::NewSymbol("PopMatrix"), FunctionTemplate::New(GLglPopMatrixCallback));

     Gl->Set(String::NewSymbol("LoadIdentity"), FunctionTemplate::New(GLglLoadIdentityCallback));

     Gl->Set(String::NewSymbol("LoadMatrixd"), FunctionTemplate::New(GLglLoadMatrixdCallback));

     Gl->Set(String::NewSymbol("LoadMatrixf"), FunctionTemplate::New(GLglLoadMatrixfCallback));

     Gl->Set(String::NewSymbol("MultMatrixd"), FunctionTemplate::New(GLglMultMatrixdCallback));

     Gl->Set(String::NewSymbol("MultMatrixf"), FunctionTemplate::New(GLglMultMatrixfCallback));

     Gl->Set(String::NewSymbol("Rotated"), FunctionTemplate::New(GLglRotatedCallback));

     Gl->Set(String::NewSymbol("Rotatef"), FunctionTemplate::New(GLglRotatefCallback));

     Gl->Set(String::NewSymbol("Scaled"), FunctionTemplate::New(GLglScaledCallback));

     Gl->Set(String::NewSymbol("Scalef"), FunctionTemplate::New(GLglScalefCallback));

     Gl->Set(String::NewSymbol("Translated"), FunctionTemplate::New(GLglTranslatedCallback));

     Gl->Set(String::NewSymbol("Translatef"), FunctionTemplate::New(GLglTranslatefCallback));

     Gl->Set(String::NewSymbol("IsList"), FunctionTemplate::New(GLglIsListCallback));

     Gl->Set(String::NewSymbol("DeleteLists"), FunctionTemplate::New(GLglDeleteListsCallback));

     Gl->Set(String::NewSymbol("GenLists"), FunctionTemplate::New(GLglGenListsCallback));

     Gl->Set(String::NewSymbol("NewList"), FunctionTemplate::New(GLglNewListCallback));

     Gl->Set(String::NewSymbol("EndList"), FunctionTemplate::New(GLglEndListCallback));

     Gl->Set(String::NewSymbol("CallList"), FunctionTemplate::New(GLglCallListCallback));

     Gl->Set(String::NewSymbol("ListBase"), FunctionTemplate::New(GLglListBaseCallback));

     Gl->Set(String::NewSymbol("Begin"), FunctionTemplate::New(GLglBeginCallback));

     Gl->Set(String::NewSymbol("End"), FunctionTemplate::New(GLglEndCallback));

     Gl->Set(String::NewSymbol("Vertex2d"), FunctionTemplate::New(GLglVertex2dCallback));

     Gl->Set(String::NewSymbol("Vertex2f"), FunctionTemplate::New(GLglVertex2fCallback));

     Gl->Set(String::NewSymbol("Vertex2i"), FunctionTemplate::New(GLglVertex2iCallback));

     Gl->Set(String::NewSymbol("Vertex2s"), FunctionTemplate::New(GLglVertex2sCallback));

     Gl->Set(String::NewSymbol("Vertex3d"), FunctionTemplate::New(GLglVertex3dCallback));

     Gl->Set(String::NewSymbol("Vertex3f"), FunctionTemplate::New(GLglVertex3fCallback));

     Gl->Set(String::NewSymbol("Vertex3i"), FunctionTemplate::New(GLglVertex3iCallback));

     Gl->Set(String::NewSymbol("Vertex3s"), FunctionTemplate::New(GLglVertex3sCallback));

     Gl->Set(String::NewSymbol("Vertex4d"), FunctionTemplate::New(GLglVertex4dCallback));

     Gl->Set(String::NewSymbol("Vertex4f"), FunctionTemplate::New(GLglVertex4fCallback));

     Gl->Set(String::NewSymbol("Vertex4i"), FunctionTemplate::New(GLglVertex4iCallback));

     Gl->Set(String::NewSymbol("Vertex4s"), FunctionTemplate::New(GLglVertex4sCallback));

     Gl->Set(String::NewSymbol("Vertex2dv"), FunctionTemplate::New(GLglVertex2dvCallback));

     Gl->Set(String::NewSymbol("Vertex2fv"), FunctionTemplate::New(GLglVertex2fvCallback));

     Gl->Set(String::NewSymbol("Vertex2iv"), FunctionTemplate::New(GLglVertex2ivCallback));

     Gl->Set(String::NewSymbol("Vertex2sv"), FunctionTemplate::New(GLglVertex2svCallback));

     Gl->Set(String::NewSymbol("Vertex3dv"), FunctionTemplate::New(GLglVertex3dvCallback));

     Gl->Set(String::NewSymbol("Vertex3fv"), FunctionTemplate::New(GLglVertex3fvCallback));

     Gl->Set(String::NewSymbol("Vertex3iv"), FunctionTemplate::New(GLglVertex3ivCallback));

     Gl->Set(String::NewSymbol("Vertex3sv"), FunctionTemplate::New(GLglVertex3svCallback));

     Gl->Set(String::NewSymbol("Vertex4dv"), FunctionTemplate::New(GLglVertex4dvCallback));

     Gl->Set(String::NewSymbol("Vertex4fv"), FunctionTemplate::New(GLglVertex4fvCallback));

     Gl->Set(String::NewSymbol("Vertex4iv"), FunctionTemplate::New(GLglVertex4ivCallback));

     Gl->Set(String::NewSymbol("Vertex4sv"), FunctionTemplate::New(GLglVertex4svCallback));

     Gl->Set(String::NewSymbol("Normal3b"), FunctionTemplate::New(GLglNormal3bCallback));

     Gl->Set(String::NewSymbol("Normal3d"), FunctionTemplate::New(GLglNormal3dCallback));

     Gl->Set(String::NewSymbol("Normal3f"), FunctionTemplate::New(GLglNormal3fCallback));

     Gl->Set(String::NewSymbol("Normal3i"), FunctionTemplate::New(GLglNormal3iCallback));

     Gl->Set(String::NewSymbol("Normal3s"), FunctionTemplate::New(GLglNormal3sCallback));

     Gl->Set(String::NewSymbol("Normal3bv"), FunctionTemplate::New(GLglNormal3bvCallback));

     Gl->Set(String::NewSymbol("Normal3dv"), FunctionTemplate::New(GLglNormal3dvCallback));

     Gl->Set(String::NewSymbol("Normal3fv"), FunctionTemplate::New(GLglNormal3fvCallback));

     Gl->Set(String::NewSymbol("Normal3iv"), FunctionTemplate::New(GLglNormal3ivCallback));

     Gl->Set(String::NewSymbol("Normal3sv"), FunctionTemplate::New(GLglNormal3svCallback));

     Gl->Set(String::NewSymbol("Indexd"), FunctionTemplate::New(GLglIndexdCallback));

     Gl->Set(String::NewSymbol("Indexf"), FunctionTemplate::New(GLglIndexfCallback));

     Gl->Set(String::NewSymbol("Indexi"), FunctionTemplate::New(GLglIndexiCallback));

     Gl->Set(String::NewSymbol("Indexs"), FunctionTemplate::New(GLglIndexsCallback));

     Gl->Set(String::NewSymbol("Indexub"), FunctionTemplate::New(GLglIndexubCallback));

     Gl->Set(String::NewSymbol("Indexdv"), FunctionTemplate::New(GLglIndexdvCallback));

     Gl->Set(String::NewSymbol("Indexfv"), FunctionTemplate::New(GLglIndexfvCallback));

     Gl->Set(String::NewSymbol("Indexiv"), FunctionTemplate::New(GLglIndexivCallback));

     Gl->Set(String::NewSymbol("Indexsv"), FunctionTemplate::New(GLglIndexsvCallback));

     Gl->Set(String::NewSymbol("Indexubv"), FunctionTemplate::New(GLglIndexubvCallback));

     Gl->Set(String::NewSymbol("Color3b"), FunctionTemplate::New(GLglColor3bCallback));

     Gl->Set(String::NewSymbol("Color3d"), FunctionTemplate::New(GLglColor3dCallback));

     Gl->Set(String::NewSymbol("Color3f"), FunctionTemplate::New(GLglColor3fCallback));

     Gl->Set(String::NewSymbol("Color3i"), FunctionTemplate::New(GLglColor3iCallback));

     Gl->Set(String::NewSymbol("Color3s"), FunctionTemplate::New(GLglColor3sCallback));

     Gl->Set(String::NewSymbol("Color3ub"), FunctionTemplate::New(GLglColor3ubCallback));

     Gl->Set(String::NewSymbol("Color3ui"), FunctionTemplate::New(GLglColor3uiCallback));

     Gl->Set(String::NewSymbol("Color3us"), FunctionTemplate::New(GLglColor3usCallback));

     Gl->Set(String::NewSymbol("Color4b"), FunctionTemplate::New(GLglColor4bCallback));

     Gl->Set(String::NewSymbol("Color4d"), FunctionTemplate::New(GLglColor4dCallback));

     Gl->Set(String::NewSymbol("Color4f"), FunctionTemplate::New(GLglColor4fCallback));

     Gl->Set(String::NewSymbol("Color4i"), FunctionTemplate::New(GLglColor4iCallback));

     Gl->Set(String::NewSymbol("Color4s"), FunctionTemplate::New(GLglColor4sCallback));

     Gl->Set(String::NewSymbol("Color4ub"), FunctionTemplate::New(GLglColor4ubCallback));

     Gl->Set(String::NewSymbol("Color4ui"), FunctionTemplate::New(GLglColor4uiCallback));

     Gl->Set(String::NewSymbol("Color4us"), FunctionTemplate::New(GLglColor4usCallback));

     Gl->Set(String::NewSymbol("Color3bv"), FunctionTemplate::New(GLglColor3bvCallback));

     Gl->Set(String::NewSymbol("Color3dv"), FunctionTemplate::New(GLglColor3dvCallback));

     Gl->Set(String::NewSymbol("Color3fv"), FunctionTemplate::New(GLglColor3fvCallback));

     Gl->Set(String::NewSymbol("Color3iv"), FunctionTemplate::New(GLglColor3ivCallback));

     Gl->Set(String::NewSymbol("Color3sv"), FunctionTemplate::New(GLglColor3svCallback));

     Gl->Set(String::NewSymbol("Color3ubv"), FunctionTemplate::New(GLglColor3ubvCallback));

     Gl->Set(String::NewSymbol("Color3uiv"), FunctionTemplate::New(GLglColor3uivCallback));

     Gl->Set(String::NewSymbol("Color3usv"), FunctionTemplate::New(GLglColor3usvCallback));

     Gl->Set(String::NewSymbol("Color4bv"), FunctionTemplate::New(GLglColor4bvCallback));

     Gl->Set(String::NewSymbol("Color4dv"), FunctionTemplate::New(GLglColor4dvCallback));

     Gl->Set(String::NewSymbol("Color4fv"), FunctionTemplate::New(GLglColor4fvCallback));

     Gl->Set(String::NewSymbol("Color4iv"), FunctionTemplate::New(GLglColor4ivCallback));

     Gl->Set(String::NewSymbol("Color4sv"), FunctionTemplate::New(GLglColor4svCallback));

     Gl->Set(String::NewSymbol("Color4ubv"), FunctionTemplate::New(GLglColor4ubvCallback));

     Gl->Set(String::NewSymbol("Color4uiv"), FunctionTemplate::New(GLglColor4uivCallback));

     Gl->Set(String::NewSymbol("Color4usv"), FunctionTemplate::New(GLglColor4usvCallback));

     Gl->Set(String::NewSymbol("TexCoord1d"), FunctionTemplate::New(GLglTexCoord1dCallback));

     Gl->Set(String::NewSymbol("TexCoord1f"), FunctionTemplate::New(GLglTexCoord1fCallback));

     Gl->Set(String::NewSymbol("TexCoord1i"), FunctionTemplate::New(GLglTexCoord1iCallback));

     Gl->Set(String::NewSymbol("TexCoord1s"), FunctionTemplate::New(GLglTexCoord1sCallback));

     Gl->Set(String::NewSymbol("TexCoord2d"), FunctionTemplate::New(GLglTexCoord2dCallback));

     Gl->Set(String::NewSymbol("TexCoord2f"), FunctionTemplate::New(GLglTexCoord2fCallback));

     Gl->Set(String::NewSymbol("TexCoord2i"), FunctionTemplate::New(GLglTexCoord2iCallback));

     Gl->Set(String::NewSymbol("TexCoord2s"), FunctionTemplate::New(GLglTexCoord2sCallback));

     Gl->Set(String::NewSymbol("TexCoord3d"), FunctionTemplate::New(GLglTexCoord3dCallback));

     Gl->Set(String::NewSymbol("TexCoord3f"), FunctionTemplate::New(GLglTexCoord3fCallback));

     Gl->Set(String::NewSymbol("TexCoord3i"), FunctionTemplate::New(GLglTexCoord3iCallback));

     Gl->Set(String::NewSymbol("TexCoord3s"), FunctionTemplate::New(GLglTexCoord3sCallback));

     Gl->Set(String::NewSymbol("TexCoord4d"), FunctionTemplate::New(GLglTexCoord4dCallback));

     Gl->Set(String::NewSymbol("TexCoord4f"), FunctionTemplate::New(GLglTexCoord4fCallback));

     Gl->Set(String::NewSymbol("TexCoord4i"), FunctionTemplate::New(GLglTexCoord4iCallback));

     Gl->Set(String::NewSymbol("TexCoord4s"), FunctionTemplate::New(GLglTexCoord4sCallback));

     Gl->Set(String::NewSymbol("TexCoord1dv"), FunctionTemplate::New(GLglTexCoord1dvCallback));

     Gl->Set(String::NewSymbol("TexCoord1fv"), FunctionTemplate::New(GLglTexCoord1fvCallback));

     Gl->Set(String::NewSymbol("TexCoord1iv"), FunctionTemplate::New(GLglTexCoord1ivCallback));

     Gl->Set(String::NewSymbol("TexCoord1sv"), FunctionTemplate::New(GLglTexCoord1svCallback));

     Gl->Set(String::NewSymbol("TexCoord2dv"), FunctionTemplate::New(GLglTexCoord2dvCallback));

     Gl->Set(String::NewSymbol("TexCoord2fv"), FunctionTemplate::New(GLglTexCoord2fvCallback));

     Gl->Set(String::NewSymbol("TexCoord2iv"), FunctionTemplate::New(GLglTexCoord2ivCallback));

     Gl->Set(String::NewSymbol("TexCoord2sv"), FunctionTemplate::New(GLglTexCoord2svCallback));

     Gl->Set(String::NewSymbol("TexCoord3dv"), FunctionTemplate::New(GLglTexCoord3dvCallback));

     Gl->Set(String::NewSymbol("TexCoord3fv"), FunctionTemplate::New(GLglTexCoord3fvCallback));

     Gl->Set(String::NewSymbol("TexCoord3iv"), FunctionTemplate::New(GLglTexCoord3ivCallback));

     Gl->Set(String::NewSymbol("TexCoord3sv"), FunctionTemplate::New(GLglTexCoord3svCallback));

     Gl->Set(String::NewSymbol("TexCoord4dv"), FunctionTemplate::New(GLglTexCoord4dvCallback));

     Gl->Set(String::NewSymbol("TexCoord4fv"), FunctionTemplate::New(GLglTexCoord4fvCallback));

     Gl->Set(String::NewSymbol("TexCoord4iv"), FunctionTemplate::New(GLglTexCoord4ivCallback));

     Gl->Set(String::NewSymbol("TexCoord4sv"), FunctionTemplate::New(GLglTexCoord4svCallback));

     Gl->Set(String::NewSymbol("RasterPos2d"), FunctionTemplate::New(GLglRasterPos2dCallback));

     Gl->Set(String::NewSymbol("RasterPos2f"), FunctionTemplate::New(GLglRasterPos2fCallback));

     Gl->Set(String::NewSymbol("RasterPos2i"), FunctionTemplate::New(GLglRasterPos2iCallback));

     Gl->Set(String::NewSymbol("RasterPos2s"), FunctionTemplate::New(GLglRasterPos2sCallback));

     Gl->Set(String::NewSymbol("RasterPos3d"), FunctionTemplate::New(GLglRasterPos3dCallback));

     Gl->Set(String::NewSymbol("RasterPos3f"), FunctionTemplate::New(GLglRasterPos3fCallback));

     Gl->Set(String::NewSymbol("RasterPos3i"), FunctionTemplate::New(GLglRasterPos3iCallback));

     Gl->Set(String::NewSymbol("RasterPos3s"), FunctionTemplate::New(GLglRasterPos3sCallback));

     Gl->Set(String::NewSymbol("RasterPos4d"), FunctionTemplate::New(GLglRasterPos4dCallback));

     Gl->Set(String::NewSymbol("RasterPos4f"), FunctionTemplate::New(GLglRasterPos4fCallback));

     Gl->Set(String::NewSymbol("RasterPos4i"), FunctionTemplate::New(GLglRasterPos4iCallback));

     Gl->Set(String::NewSymbol("RasterPos4s"), FunctionTemplate::New(GLglRasterPos4sCallback));

     Gl->Set(String::NewSymbol("RasterPos2dv"), FunctionTemplate::New(GLglRasterPos2dvCallback));

     Gl->Set(String::NewSymbol("RasterPos2fv"), FunctionTemplate::New(GLglRasterPos2fvCallback));

     Gl->Set(String::NewSymbol("RasterPos2iv"), FunctionTemplate::New(GLglRasterPos2ivCallback));

     Gl->Set(String::NewSymbol("RasterPos2sv"), FunctionTemplate::New(GLglRasterPos2svCallback));

     Gl->Set(String::NewSymbol("RasterPos3dv"), FunctionTemplate::New(GLglRasterPos3dvCallback));

     Gl->Set(String::NewSymbol("RasterPos3fv"), FunctionTemplate::New(GLglRasterPos3fvCallback));

     Gl->Set(String::NewSymbol("RasterPos3iv"), FunctionTemplate::New(GLglRasterPos3ivCallback));

     Gl->Set(String::NewSymbol("RasterPos3sv"), FunctionTemplate::New(GLglRasterPos3svCallback));

     Gl->Set(String::NewSymbol("RasterPos4dv"), FunctionTemplate::New(GLglRasterPos4dvCallback));

     Gl->Set(String::NewSymbol("RasterPos4fv"), FunctionTemplate::New(GLglRasterPos4fvCallback));

     Gl->Set(String::NewSymbol("RasterPos4iv"), FunctionTemplate::New(GLglRasterPos4ivCallback));

     Gl->Set(String::NewSymbol("RasterPos4sv"), FunctionTemplate::New(GLglRasterPos4svCallback));

     Gl->Set(String::NewSymbol("Rectd"), FunctionTemplate::New(GLglRectdCallback));

     Gl->Set(String::NewSymbol("Rectf"), FunctionTemplate::New(GLglRectfCallback));

     Gl->Set(String::NewSymbol("Recti"), FunctionTemplate::New(GLglRectiCallback));

     Gl->Set(String::NewSymbol("Rects"), FunctionTemplate::New(GLglRectsCallback));

     Gl->Set(String::NewSymbol("Rectdv"), FunctionTemplate::New(GLglRectdvCallback));

     Gl->Set(String::NewSymbol("Rectfv"), FunctionTemplate::New(GLglRectfvCallback));

     Gl->Set(String::NewSymbol("Rectiv"), FunctionTemplate::New(GLglRectivCallback));

     Gl->Set(String::NewSymbol("Rectsv"), FunctionTemplate::New(GLglRectsvCallback));

     Gl->Set(String::NewSymbol("ArrayElement"), FunctionTemplate::New(GLglArrayElementCallback));

     Gl->Set(String::NewSymbol("DrawArrays"), FunctionTemplate::New(GLglDrawArraysCallback));

     Gl->Set(String::NewSymbol("ShadeModel"), FunctionTemplate::New(GLglShadeModelCallback));

     Gl->Set(String::NewSymbol("Lightf"), FunctionTemplate::New(GLglLightfCallback));

     Gl->Set(String::NewSymbol("Lighti"), FunctionTemplate::New(GLglLightiCallback));

     Gl->Set(String::NewSymbol("Lightfv"), FunctionTemplate::New(GLglLightfvCallback));

     Gl->Set(String::NewSymbol("Lightiv"), FunctionTemplate::New(GLglLightivCallback));

     Gl->Set(String::NewSymbol("GetLightfv"), FunctionTemplate::New(GLglGetLightfvCallback));

     Gl->Set(String::NewSymbol("GetLightiv"), FunctionTemplate::New(GLglGetLightivCallback));

     Gl->Set(String::NewSymbol("LightModelf"), FunctionTemplate::New(GLglLightModelfCallback));

     Gl->Set(String::NewSymbol("LightModeli"), FunctionTemplate::New(GLglLightModeliCallback));

     Gl->Set(String::NewSymbol("LightModelfv"), FunctionTemplate::New(GLglLightModelfvCallback));

     Gl->Set(String::NewSymbol("LightModeliv"), FunctionTemplate::New(GLglLightModelivCallback));

     Gl->Set(String::NewSymbol("Materialf"), FunctionTemplate::New(GLglMaterialfCallback));

     Gl->Set(String::NewSymbol("Materiali"), FunctionTemplate::New(GLglMaterialiCallback));

     Gl->Set(String::NewSymbol("Materialfv"), FunctionTemplate::New(GLglMaterialfvCallback));

     Gl->Set(String::NewSymbol("Materialiv"), FunctionTemplate::New(GLglMaterialivCallback));

     Gl->Set(String::NewSymbol("GetMaterialfv"), FunctionTemplate::New(GLglGetMaterialfvCallback));

     Gl->Set(String::NewSymbol("GetMaterialiv"), FunctionTemplate::New(GLglGetMaterialivCallback));

     Gl->Set(String::NewSymbol("ColorMaterial"), FunctionTemplate::New(GLglColorMaterialCallback));

     Gl->Set(String::NewSymbol("PixelZoom"), FunctionTemplate::New(GLglPixelZoomCallback));

     Gl->Set(String::NewSymbol("PixelStoref"), FunctionTemplate::New(GLglPixelStorefCallback));

     Gl->Set(String::NewSymbol("PixelStorei"), FunctionTemplate::New(GLglPixelStoreiCallback));

     Gl->Set(String::NewSymbol("PixelTransferf"), FunctionTemplate::New(GLglPixelTransferfCallback));

     Gl->Set(String::NewSymbol("PixelTransferi"), FunctionTemplate::New(GLglPixelTransferiCallback));

     Gl->Set(String::NewSymbol("PixelMapfv"), FunctionTemplate::New(GLglPixelMapfvCallback));

     Gl->Set(String::NewSymbol("PixelMapuiv"), FunctionTemplate::New(GLglPixelMapuivCallback));

     Gl->Set(String::NewSymbol("PixelMapusv"), FunctionTemplate::New(GLglPixelMapusvCallback));

     Gl->Set(String::NewSymbol("GetPixelMapfv"), FunctionTemplate::New(GLglGetPixelMapfvCallback));

     Gl->Set(String::NewSymbol("GetPixelMapuiv"), FunctionTemplate::New(GLglGetPixelMapuivCallback));

     Gl->Set(String::NewSymbol("GetPixelMapusv"), FunctionTemplate::New(GLglGetPixelMapusvCallback));

     Gl->Set(String::NewSymbol("Bitmap"), FunctionTemplate::New(GLglBitmapCallback));

     Gl->Set(String::NewSymbol("CopyPixels"), FunctionTemplate::New(GLglCopyPixelsCallback));

     Gl->Set(String::NewSymbol("StencilFunc"), FunctionTemplate::New(GLglStencilFuncCallback));

     Gl->Set(String::NewSymbol("StencilMask"), FunctionTemplate::New(GLglStencilMaskCallback));

     Gl->Set(String::NewSymbol("StencilOp"), FunctionTemplate::New(GLglStencilOpCallback));

     Gl->Set(String::NewSymbol("ClearStencil"), FunctionTemplate::New(GLglClearStencilCallback));

     Gl->Set(String::NewSymbol("TexGend"), FunctionTemplate::New(GLglTexGendCallback));

     Gl->Set(String::NewSymbol("TexGenf"), FunctionTemplate::New(GLglTexGenfCallback));

     Gl->Set(String::NewSymbol("TexGeni"), FunctionTemplate::New(GLglTexGeniCallback));

     Gl->Set(String::NewSymbol("TexGendv"), FunctionTemplate::New(GLglTexGendvCallback));

     Gl->Set(String::NewSymbol("TexGenfv"), FunctionTemplate::New(GLglTexGenfvCallback));

     Gl->Set(String::NewSymbol("TexGeniv"), FunctionTemplate::New(GLglTexGenivCallback));

     Gl->Set(String::NewSymbol("GetTexGendv"), FunctionTemplate::New(GLglGetTexGendvCallback));

     Gl->Set(String::NewSymbol("GetTexGenfv"), FunctionTemplate::New(GLglGetTexGenfvCallback));

     Gl->Set(String::NewSymbol("GetTexGeniv"), FunctionTemplate::New(GLglGetTexGenivCallback));

     Gl->Set(String::NewSymbol("TexEnvf"), FunctionTemplate::New(GLglTexEnvfCallback));

     Gl->Set(String::NewSymbol("TexEnvi"), FunctionTemplate::New(GLglTexEnviCallback));

     Gl->Set(String::NewSymbol("TexEnvfv"), FunctionTemplate::New(GLglTexEnvfvCallback));

     Gl->Set(String::NewSymbol("TexEnviv"), FunctionTemplate::New(GLglTexEnvivCallback));

     Gl->Set(String::NewSymbol("GetTexEnvfv"), FunctionTemplate::New(GLglGetTexEnvfvCallback));

     Gl->Set(String::NewSymbol("GetTexEnviv"), FunctionTemplate::New(GLglGetTexEnvivCallback));

     Gl->Set(String::NewSymbol("TexParameterf"), FunctionTemplate::New(GLglTexParameterfCallback));

     Gl->Set(String::NewSymbol("TexParameteri"), FunctionTemplate::New(GLglTexParameteriCallback));

     Gl->Set(String::NewSymbol("TexParameterfv"), FunctionTemplate::New(GLglTexParameterfvCallback));

     Gl->Set(String::NewSymbol("TexParameteriv"), FunctionTemplate::New(GLglTexParameterivCallback));

     Gl->Set(String::NewSymbol("GetTexParameterfv"), FunctionTemplate::New(GLglGetTexParameterfvCallback));

     Gl->Set(String::NewSymbol("GetTexParameteriv"), FunctionTemplate::New(GLglGetTexParameterivCallback));

     Gl->Set(String::NewSymbol("GetTexLevelParameterfv"), FunctionTemplate::New(GLglGetTexLevelParameterfvCallback));

     Gl->Set(String::NewSymbol("GetTexLevelParameteriv"), FunctionTemplate::New(GLglGetTexLevelParameterivCallback));

     Gl->Set(String::NewSymbol("GenTextures"), FunctionTemplate::New(GLglGenTexturesCallback));

     Gl->Set(String::NewSymbol("DeleteTextures"), FunctionTemplate::New(GLglDeleteTexturesCallback));

     Gl->Set(String::NewSymbol("BindTexture"), FunctionTemplate::New(GLglBindTextureCallback));

     Gl->Set(String::NewSymbol("PrioritizeTextures"), FunctionTemplate::New(GLglPrioritizeTexturesCallback));

     Gl->Set(String::NewSymbol("AreTexturesResident"), FunctionTemplate::New(GLglAreTexturesResidentCallback));

     Gl->Set(String::NewSymbol("IsTexture"), FunctionTemplate::New(GLglIsTextureCallback));

     Gl->Set(String::NewSymbol("CopyTexImage1D"), FunctionTemplate::New(GLglCopyTexImage1DCallback));

     Gl->Set(String::NewSymbol("CopyTexImage2D"), FunctionTemplate::New(GLglCopyTexImage2DCallback));

     Gl->Set(String::NewSymbol("CopyTexSubImage1D"), FunctionTemplate::New(GLglCopyTexSubImage1DCallback));

     Gl->Set(String::NewSymbol("CopyTexSubImage2D"), FunctionTemplate::New(GLglCopyTexSubImage2DCallback));

     Gl->Set(String::NewSymbol("Map1d"), FunctionTemplate::New(GLglMap1dCallback));

     Gl->Set(String::NewSymbol("Map1f"), FunctionTemplate::New(GLglMap1fCallback));

     Gl->Set(String::NewSymbol("Map2d"), FunctionTemplate::New(GLglMap2dCallback));

     Gl->Set(String::NewSymbol("Map2f"), FunctionTemplate::New(GLglMap2fCallback));

     Gl->Set(String::NewSymbol("GetMapdv"), FunctionTemplate::New(GLglGetMapdvCallback));

     Gl->Set(String::NewSymbol("GetMapfv"), FunctionTemplate::New(GLglGetMapfvCallback));

     Gl->Set(String::NewSymbol("GetMapiv"), FunctionTemplate::New(GLglGetMapivCallback));

     Gl->Set(String::NewSymbol("EvalCoord1d"), FunctionTemplate::New(GLglEvalCoord1dCallback));

     Gl->Set(String::NewSymbol("EvalCoord1f"), FunctionTemplate::New(GLglEvalCoord1fCallback));

     Gl->Set(String::NewSymbol("EvalCoord1dv"), FunctionTemplate::New(GLglEvalCoord1dvCallback));

     Gl->Set(String::NewSymbol("EvalCoord1fv"), FunctionTemplate::New(GLglEvalCoord1fvCallback));

     Gl->Set(String::NewSymbol("EvalCoord2d"), FunctionTemplate::New(GLglEvalCoord2dCallback));

     Gl->Set(String::NewSymbol("EvalCoord2f"), FunctionTemplate::New(GLglEvalCoord2fCallback));

     Gl->Set(String::NewSymbol("EvalCoord2dv"), FunctionTemplate::New(GLglEvalCoord2dvCallback));

     Gl->Set(String::NewSymbol("EvalCoord2fv"), FunctionTemplate::New(GLglEvalCoord2fvCallback));

     Gl->Set(String::NewSymbol("MapGrid1d"), FunctionTemplate::New(GLglMapGrid1dCallback));

     Gl->Set(String::NewSymbol("MapGrid1f"), FunctionTemplate::New(GLglMapGrid1fCallback));

     Gl->Set(String::NewSymbol("MapGrid2d"), FunctionTemplate::New(GLglMapGrid2dCallback));

     Gl->Set(String::NewSymbol("MapGrid2f"), FunctionTemplate::New(GLglMapGrid2fCallback));

     Gl->Set(String::NewSymbol("EvalPoint1"), FunctionTemplate::New(GLglEvalPoint1Callback));

     Gl->Set(String::NewSymbol("EvalPoint2"), FunctionTemplate::New(GLglEvalPoint2Callback));

     Gl->Set(String::NewSymbol("EvalMesh1"), FunctionTemplate::New(GLglEvalMesh1Callback));

     Gl->Set(String::NewSymbol("EvalMesh2"), FunctionTemplate::New(GLglEvalMesh2Callback));

     Gl->Set(String::NewSymbol("Fogf"), FunctionTemplate::New(GLglFogfCallback));

     Gl->Set(String::NewSymbol("Fogi"), FunctionTemplate::New(GLglFogiCallback));

     Gl->Set(String::NewSymbol("Fogfv"), FunctionTemplate::New(GLglFogfvCallback));

     Gl->Set(String::NewSymbol("Fogiv"), FunctionTemplate::New(GLglFogivCallback));

     Gl->Set(String::NewSymbol("FeedbackBuffer"), FunctionTemplate::New(GLglFeedbackBufferCallback));

     Gl->Set(String::NewSymbol("PassThrough"), FunctionTemplate::New(GLglPassThroughCallback));

     Gl->Set(String::NewSymbol("SelectBuffer"), FunctionTemplate::New(GLglSelectBufferCallback));

     Gl->Set(String::NewSymbol("InitNames"), FunctionTemplate::New(GLglInitNamesCallback));

     Gl->Set(String::NewSymbol("LoadName"), FunctionTemplate::New(GLglLoadNameCallback));

     Gl->Set(String::NewSymbol("PushName"), FunctionTemplate::New(GLglPushNameCallback));

     Gl->Set(String::NewSymbol("PopName"), FunctionTemplate::New(GLglPopNameCallback));

     Gl->Set(String::NewSymbol("CopyTexSubImage3D"), FunctionTemplate::New(GLglCopyTexSubImage3DCallback));

     Gl->Set(String::NewSymbol("ColorTableParameteriv"), FunctionTemplate::New(GLglColorTableParameterivCallback));

     Gl->Set(String::NewSymbol("ColorTableParameterfv"), FunctionTemplate::New(GLglColorTableParameterfvCallback));

     Gl->Set(String::NewSymbol("CopyColorSubTable"), FunctionTemplate::New(GLglCopyColorSubTableCallback));

     Gl->Set(String::NewSymbol("CopyColorTable"), FunctionTemplate::New(GLglCopyColorTableCallback));

     Gl->Set(String::NewSymbol("GetColorTableParameterfv"), FunctionTemplate::New(GLglGetColorTableParameterfvCallback));

     Gl->Set(String::NewSymbol("GetColorTableParameteriv"), FunctionTemplate::New(GLglGetColorTableParameterivCallback));

     Gl->Set(String::NewSymbol("BlendEquation"), FunctionTemplate::New(GLglBlendEquationCallback));

     Gl->Set(String::NewSymbol("BlendColor"), FunctionTemplate::New(GLglBlendColorCallback));

     Gl->Set(String::NewSymbol("Histogram"), FunctionTemplate::New(GLglHistogramCallback));

     Gl->Set(String::NewSymbol("ResetHistogram"), FunctionTemplate::New(GLglResetHistogramCallback));

     Gl->Set(String::NewSymbol("GetHistogramParameterfv"), FunctionTemplate::New(GLglGetHistogramParameterfvCallback));

     Gl->Set(String::NewSymbol("GetHistogramParameteriv"), FunctionTemplate::New(GLglGetHistogramParameterivCallback));

     Gl->Set(String::NewSymbol("Minmax"), FunctionTemplate::New(GLglMinmaxCallback));

     Gl->Set(String::NewSymbol("ResetMinmax"), FunctionTemplate::New(GLglResetMinmaxCallback));

     Gl->Set(String::NewSymbol("GetMinmaxParameterfv"), FunctionTemplate::New(GLglGetMinmaxParameterfvCallback));

     Gl->Set(String::NewSymbol("GetMinmaxParameteriv"), FunctionTemplate::New(GLglGetMinmaxParameterivCallback));

     Gl->Set(String::NewSymbol("ConvolutionParameterf"), FunctionTemplate::New(GLglConvolutionParameterfCallback));

     Gl->Set(String::NewSymbol("ConvolutionParameterfv"), FunctionTemplate::New(GLglConvolutionParameterfvCallback));

     Gl->Set(String::NewSymbol("ConvolutionParameteri"), FunctionTemplate::New(GLglConvolutionParameteriCallback));

     Gl->Set(String::NewSymbol("ConvolutionParameteriv"), FunctionTemplate::New(GLglConvolutionParameterivCallback));

     Gl->Set(String::NewSymbol("CopyConvolutionFilter1D"), FunctionTemplate::New(GLglCopyConvolutionFilter1DCallback));

     Gl->Set(String::NewSymbol("CopyConvolutionFilter2D"), FunctionTemplate::New(GLglCopyConvolutionFilter2DCallback));

     Gl->Set(String::NewSymbol("GetConvolutionParameterfv"), FunctionTemplate::New(GLglGetConvolutionParameterfvCallback));

     Gl->Set(String::NewSymbol("GetConvolutionParameteriv"), FunctionTemplate::New(GLglGetConvolutionParameterivCallback));

     Gl->Set(String::NewSymbol("ActiveTexture"), FunctionTemplate::New(GLglActiveTextureCallback));

     Gl->Set(String::NewSymbol("ClientActiveTexture"), FunctionTemplate::New(GLglClientActiveTextureCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1d"), FunctionTemplate::New(GLglMultiTexCoord1dCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1dv"), FunctionTemplate::New(GLglMultiTexCoord1dvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1f"), FunctionTemplate::New(GLglMultiTexCoord1fCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1fv"), FunctionTemplate::New(GLglMultiTexCoord1fvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1i"), FunctionTemplate::New(GLglMultiTexCoord1iCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1iv"), FunctionTemplate::New(GLglMultiTexCoord1ivCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1s"), FunctionTemplate::New(GLglMultiTexCoord1sCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1sv"), FunctionTemplate::New(GLglMultiTexCoord1svCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2d"), FunctionTemplate::New(GLglMultiTexCoord2dCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2dv"), FunctionTemplate::New(GLglMultiTexCoord2dvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2f"), FunctionTemplate::New(GLglMultiTexCoord2fCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2fv"), FunctionTemplate::New(GLglMultiTexCoord2fvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2i"), FunctionTemplate::New(GLglMultiTexCoord2iCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2iv"), FunctionTemplate::New(GLglMultiTexCoord2ivCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2s"), FunctionTemplate::New(GLglMultiTexCoord2sCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2sv"), FunctionTemplate::New(GLglMultiTexCoord2svCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3d"), FunctionTemplate::New(GLglMultiTexCoord3dCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3dv"), FunctionTemplate::New(GLglMultiTexCoord3dvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3f"), FunctionTemplate::New(GLglMultiTexCoord3fCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3fv"), FunctionTemplate::New(GLglMultiTexCoord3fvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3i"), FunctionTemplate::New(GLglMultiTexCoord3iCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3iv"), FunctionTemplate::New(GLglMultiTexCoord3ivCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3s"), FunctionTemplate::New(GLglMultiTexCoord3sCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3sv"), FunctionTemplate::New(GLglMultiTexCoord3svCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4d"), FunctionTemplate::New(GLglMultiTexCoord4dCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4dv"), FunctionTemplate::New(GLglMultiTexCoord4dvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4f"), FunctionTemplate::New(GLglMultiTexCoord4fCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4fv"), FunctionTemplate::New(GLglMultiTexCoord4fvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4i"), FunctionTemplate::New(GLglMultiTexCoord4iCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4iv"), FunctionTemplate::New(GLglMultiTexCoord4ivCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4s"), FunctionTemplate::New(GLglMultiTexCoord4sCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4sv"), FunctionTemplate::New(GLglMultiTexCoord4svCallback));

     Gl->Set(String::NewSymbol("LoadTransposeMatrixd"), FunctionTemplate::New(GLglLoadTransposeMatrixdCallback));

     Gl->Set(String::NewSymbol("LoadTransposeMatrixf"), FunctionTemplate::New(GLglLoadTransposeMatrixfCallback));

     Gl->Set(String::NewSymbol("MultTransposeMatrixd"), FunctionTemplate::New(GLglMultTransposeMatrixdCallback));

     Gl->Set(String::NewSymbol("MultTransposeMatrixf"), FunctionTemplate::New(GLglMultTransposeMatrixfCallback));

     Gl->Set(String::NewSymbol("SampleCoverage"), FunctionTemplate::New(GLglSampleCoverageCallback));

     Gl->Set(String::NewSymbol("ActiveTextureARB"), FunctionTemplate::New(GLglActiveTextureARBCallback));

     Gl->Set(String::NewSymbol("ClientActiveTextureARB"), FunctionTemplate::New(GLglClientActiveTextureARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1dARB"), FunctionTemplate::New(GLglMultiTexCoord1dARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1dvARB"), FunctionTemplate::New(GLglMultiTexCoord1dvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1fARB"), FunctionTemplate::New(GLglMultiTexCoord1fARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1fvARB"), FunctionTemplate::New(GLglMultiTexCoord1fvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1iARB"), FunctionTemplate::New(GLglMultiTexCoord1iARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1ivARB"), FunctionTemplate::New(GLglMultiTexCoord1ivARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1sARB"), FunctionTemplate::New(GLglMultiTexCoord1sARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1svARB"), FunctionTemplate::New(GLglMultiTexCoord1svARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2dARB"), FunctionTemplate::New(GLglMultiTexCoord2dARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2dvARB"), FunctionTemplate::New(GLglMultiTexCoord2dvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2fARB"), FunctionTemplate::New(GLglMultiTexCoord2fARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2fvARB"), FunctionTemplate::New(GLglMultiTexCoord2fvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2iARB"), FunctionTemplate::New(GLglMultiTexCoord2iARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2ivARB"), FunctionTemplate::New(GLglMultiTexCoord2ivARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2sARB"), FunctionTemplate::New(GLglMultiTexCoord2sARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2svARB"), FunctionTemplate::New(GLglMultiTexCoord2svARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3dARB"), FunctionTemplate::New(GLglMultiTexCoord3dARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3dvARB"), FunctionTemplate::New(GLglMultiTexCoord3dvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3fARB"), FunctionTemplate::New(GLglMultiTexCoord3fARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3fvARB"), FunctionTemplate::New(GLglMultiTexCoord3fvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3iARB"), FunctionTemplate::New(GLglMultiTexCoord3iARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3ivARB"), FunctionTemplate::New(GLglMultiTexCoord3ivARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3sARB"), FunctionTemplate::New(GLglMultiTexCoord3sARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3svARB"), FunctionTemplate::New(GLglMultiTexCoord3svARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4dARB"), FunctionTemplate::New(GLglMultiTexCoord4dARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4dvARB"), FunctionTemplate::New(GLglMultiTexCoord4dvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4fARB"), FunctionTemplate::New(GLglMultiTexCoord4fARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4fvARB"), FunctionTemplate::New(GLglMultiTexCoord4fvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4iARB"), FunctionTemplate::New(GLglMultiTexCoord4iARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4ivARB"), FunctionTemplate::New(GLglMultiTexCoord4ivARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4sARB"), FunctionTemplate::New(GLglMultiTexCoord4sARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4svARB"), FunctionTemplate::New(GLglMultiTexCoord4svARBCallback));


      // Again, return the result through the current handle scope.
      return handle_scope.Close(Gl);
}    
