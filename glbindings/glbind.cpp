

#include "glbind.h"
    
    

Handle<Value> GetGL_VERSION_1_1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERSION_1_1);
}




Handle<Value> GetGL_VERSION_1_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERSION_1_2);
}




Handle<Value> GetGL_VERSION_1_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERSION_1_3);
}




Handle<Value> GetGL_ARB_imaging(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ARB_imaging);
}




Handle<Value> GetGL_FALSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FALSE);
}




Handle<Value> GetGL_TRUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRUE);
}




Handle<Value> GetGL_BYTE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BYTE);
}




Handle<Value> GetGL_UNSIGNED_BYTE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_BYTE);
}




Handle<Value> GetGL_SHORT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SHORT);
}




Handle<Value> GetGL_UNSIGNED_SHORT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT);
}




Handle<Value> GetGL_INT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INT);
}




Handle<Value> GetGL_UNSIGNED_INT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT);
}




Handle<Value> GetGL_FLOAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FLOAT);
}




Handle<Value> GetGL_2_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_2_BYTES);
}




Handle<Value> GetGL_3_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_3_BYTES);
}




Handle<Value> GetGL_4_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_4_BYTES);
}




Handle<Value> GetGL_DOUBLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOUBLE);
}




Handle<Value> GetGL_POINTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINTS);
}




Handle<Value> GetGL_LINES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINES);
}




Handle<Value> GetGL_LINE_LOOP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_LOOP);
}




Handle<Value> GetGL_LINE_STRIP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_STRIP);
}




Handle<Value> GetGL_TRIANGLES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRIANGLES);
}




Handle<Value> GetGL_TRIANGLE_STRIP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRIANGLE_STRIP);
}




Handle<Value> GetGL_TRIANGLE_FAN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRIANGLE_FAN);
}




Handle<Value> GetGL_QUADS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_QUADS);
}




Handle<Value> GetGL_QUAD_STRIP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_QUAD_STRIP);
}




Handle<Value> GetGL_POLYGON(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON);
}




Handle<Value> GetGL_VERTEX_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY);
}




Handle<Value> GetGL_NORMAL_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_ARRAY);
}




Handle<Value> GetGL_COLOR_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY);
}




Handle<Value> GetGL_INDEX_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_ARRAY);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY);
}




Handle<Value> GetGL_EDGE_FLAG_ARRAY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EDGE_FLAG_ARRAY);
}




Handle<Value> GetGL_VERTEX_ARRAY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY_SIZE);
}




Handle<Value> GetGL_VERTEX_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY_TYPE);
}




Handle<Value> GetGL_VERTEX_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY_STRIDE);
}




Handle<Value> GetGL_NORMAL_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_ARRAY_TYPE);
}




Handle<Value> GetGL_NORMAL_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_ARRAY_STRIDE);
}




Handle<Value> GetGL_COLOR_ARRAY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY_SIZE);
}




Handle<Value> GetGL_COLOR_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY_TYPE);
}




Handle<Value> GetGL_COLOR_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY_STRIDE);
}




Handle<Value> GetGL_INDEX_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_ARRAY_TYPE);
}




Handle<Value> GetGL_INDEX_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_ARRAY_STRIDE);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY_SIZE);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY_TYPE);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY_STRIDE);
}




Handle<Value> GetGL_EDGE_FLAG_ARRAY_STRIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EDGE_FLAG_ARRAY_STRIDE);
}




Handle<Value> GetGL_VERTEX_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_ARRAY_POINTER);
}




Handle<Value> GetGL_NORMAL_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_ARRAY_POINTER);
}




Handle<Value> GetGL_COLOR_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_ARRAY_POINTER);
}




Handle<Value> GetGL_INDEX_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_ARRAY_POINTER);
}




Handle<Value> GetGL_TEXTURE_COORD_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COORD_ARRAY_POINTER);
}




Handle<Value> GetGL_EDGE_FLAG_ARRAY_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EDGE_FLAG_ARRAY_POINTER);
}




Handle<Value> GetGL_V2F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_V2F);
}




Handle<Value> GetGL_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_V3F);
}




Handle<Value> GetGL_C4UB_V2F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_C4UB_V2F);
}




Handle<Value> GetGL_C4UB_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_C4UB_V3F);
}




Handle<Value> GetGL_C3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_C3F_V3F);
}




Handle<Value> GetGL_N3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_N3F_V3F);
}




Handle<Value> GetGL_C4F_N3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_C4F_N3F_V3F);
}




Handle<Value> GetGL_T2F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_V3F);
}




Handle<Value> GetGL_T4F_V4F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T4F_V4F);
}




Handle<Value> GetGL_T2F_C4UB_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_C4UB_V3F);
}




Handle<Value> GetGL_T2F_C3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_C3F_V3F);
}




Handle<Value> GetGL_T2F_N3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_N3F_V3F);
}




Handle<Value> GetGL_T2F_C4F_N3F_V3F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T2F_C4F_N3F_V3F);
}




Handle<Value> GetGL_T4F_C4F_N3F_V4F(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T4F_C4F_N3F_V4F);
}




Handle<Value> GetGL_MATRIX_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MATRIX_MODE);
}




Handle<Value> GetGL_MODELVIEW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MODELVIEW);
}




Handle<Value> GetGL_PROJECTION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROJECTION);
}




Handle<Value> GetGL_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE);
}




Handle<Value> GetGL_POINT_SMOOTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SMOOTH);
}




Handle<Value> GetGL_POINT_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SIZE);
}




Handle<Value> GetGL_POINT_SIZE_GRANULARITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SIZE_GRANULARITY);
}




Handle<Value> GetGL_POINT_SIZE_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SIZE_RANGE);
}




Handle<Value> GetGL_LINE_SMOOTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_SMOOTH);
}




Handle<Value> GetGL_LINE_STIPPLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_STIPPLE);
}




Handle<Value> GetGL_LINE_STIPPLE_PATTERN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_STIPPLE_PATTERN);
}




Handle<Value> GetGL_LINE_STIPPLE_REPEAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_STIPPLE_REPEAT);
}




Handle<Value> GetGL_LINE_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_WIDTH);
}




Handle<Value> GetGL_LINE_WIDTH_GRANULARITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_WIDTH_GRANULARITY);
}




Handle<Value> GetGL_LINE_WIDTH_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_WIDTH_RANGE);
}




Handle<Value> GetGL_POINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT);
}




Handle<Value> GetGL_LINE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE);
}




Handle<Value> GetGL_FILL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FILL);
}




Handle<Value> GetGL_CW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CW);
}




Handle<Value> GetGL_CCW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CCW);
}




Handle<Value> GetGL_FRONT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT);
}




Handle<Value> GetGL_BACK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BACK);
}




Handle<Value> GetGL_POLYGON_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_MODE);
}




Handle<Value> GetGL_POLYGON_SMOOTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_SMOOTH);
}




Handle<Value> GetGL_POLYGON_STIPPLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_STIPPLE);
}




Handle<Value> GetGL_EDGE_FLAG(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EDGE_FLAG);
}




Handle<Value> GetGL_CULL_FACE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CULL_FACE);
}




Handle<Value> GetGL_CULL_FACE_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CULL_FACE_MODE);
}




Handle<Value> GetGL_FRONT_FACE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT_FACE);
}




Handle<Value> GetGL_POLYGON_OFFSET_FACTOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_FACTOR);
}




Handle<Value> GetGL_POLYGON_OFFSET_UNITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_UNITS);
}




Handle<Value> GetGL_POLYGON_OFFSET_POINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_POINT);
}




Handle<Value> GetGL_POLYGON_OFFSET_LINE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_LINE);
}




Handle<Value> GetGL_POLYGON_OFFSET_FILL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_OFFSET_FILL);
}




Handle<Value> GetGL_COMPILE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPILE);
}




Handle<Value> GetGL_COMPILE_AND_EXECUTE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPILE_AND_EXECUTE);
}




Handle<Value> GetGL_LIST_BASE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIST_BASE);
}




Handle<Value> GetGL_LIST_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIST_INDEX);
}




Handle<Value> GetGL_LIST_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIST_MODE);
}




Handle<Value> GetGL_NEVER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NEVER);
}




Handle<Value> GetGL_LESS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LESS);
}




Handle<Value> GetGL_EQUAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EQUAL);
}




Handle<Value> GetGL_LEQUAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LEQUAL);
}




Handle<Value> GetGL_GREATER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREATER);
}




Handle<Value> GetGL_NOTEQUAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NOTEQUAL);
}




Handle<Value> GetGL_GEQUAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GEQUAL);
}




Handle<Value> GetGL_ALWAYS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALWAYS);
}




Handle<Value> GetGL_DEPTH_TEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_TEST);
}




Handle<Value> GetGL_DEPTH_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_BITS);
}




Handle<Value> GetGL_DEPTH_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_CLEAR_VALUE);
}




Handle<Value> GetGL_DEPTH_FUNC(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_FUNC);
}




Handle<Value> GetGL_DEPTH_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_RANGE);
}




Handle<Value> GetGL_DEPTH_WRITEMASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_WRITEMASK);
}




Handle<Value> GetGL_DEPTH_COMPONENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_COMPONENT);
}




Handle<Value> GetGL_LIGHTING(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHTING);
}




Handle<Value> GetGL_LIGHT0(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT0);
}




Handle<Value> GetGL_LIGHT1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT1);
}




Handle<Value> GetGL_LIGHT2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT2);
}




Handle<Value> GetGL_LIGHT3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT3);
}




Handle<Value> GetGL_LIGHT4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT4);
}




Handle<Value> GetGL_LIGHT5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT5);
}




Handle<Value> GetGL_LIGHT6(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT6);
}




Handle<Value> GetGL_LIGHT7(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT7);
}




Handle<Value> GetGL_SPOT_EXPONENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPOT_EXPONENT);
}




Handle<Value> GetGL_SPOT_CUTOFF(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPOT_CUTOFF);
}




Handle<Value> GetGL_CONSTANT_ATTENUATION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT_ATTENUATION);
}




Handle<Value> GetGL_LINEAR_ATTENUATION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINEAR_ATTENUATION);
}




Handle<Value> GetGL_QUADRATIC_ATTENUATION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_QUADRATIC_ATTENUATION);
}




Handle<Value> GetGL_AMBIENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AMBIENT);
}




Handle<Value> GetGL_DIFFUSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DIFFUSE);
}




Handle<Value> GetGL_SPECULAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPECULAR);
}




Handle<Value> GetGL_SHININESS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SHININESS);
}




Handle<Value> GetGL_EMISSION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EMISSION);
}




Handle<Value> GetGL_POSITION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POSITION);
}




Handle<Value> GetGL_SPOT_DIRECTION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPOT_DIRECTION);
}




Handle<Value> GetGL_AMBIENT_AND_DIFFUSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AMBIENT_AND_DIFFUSE);
}




Handle<Value> GetGL_COLOR_INDEXES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_INDEXES);
}




Handle<Value> GetGL_LIGHT_MODEL_TWO_SIDE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT_MODEL_TWO_SIDE);
}




Handle<Value> GetGL_LIGHT_MODEL_LOCAL_VIEWER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT_MODEL_LOCAL_VIEWER);
}




Handle<Value> GetGL_LIGHT_MODEL_AMBIENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT_MODEL_AMBIENT);
}




Handle<Value> GetGL_FRONT_AND_BACK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT_AND_BACK);
}




Handle<Value> GetGL_SHADE_MODEL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SHADE_MODEL);
}




Handle<Value> GetGL_FLAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FLAT);
}




Handle<Value> GetGL_SMOOTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH);
}




Handle<Value> GetGL_COLOR_MATERIAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATERIAL);
}




Handle<Value> GetGL_COLOR_MATERIAL_FACE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATERIAL_FACE);
}




Handle<Value> GetGL_COLOR_MATERIAL_PARAMETER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATERIAL_PARAMETER);
}




Handle<Value> GetGL_NORMALIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMALIZE);
}




Handle<Value> GetGL_CLIP_PLANE0(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE0);
}




Handle<Value> GetGL_CLIP_PLANE1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE1);
}




Handle<Value> GetGL_CLIP_PLANE2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE2);
}




Handle<Value> GetGL_CLIP_PLANE3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE3);
}




Handle<Value> GetGL_CLIP_PLANE4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE4);
}




Handle<Value> GetGL_CLIP_PLANE5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIP_PLANE5);
}




Handle<Value> GetGL_ACCUM_RED_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_RED_BITS);
}




Handle<Value> GetGL_ACCUM_GREEN_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_GREEN_BITS);
}




Handle<Value> GetGL_ACCUM_BLUE_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_BLUE_BITS);
}




Handle<Value> GetGL_ACCUM_ALPHA_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_ALPHA_BITS);
}




Handle<Value> GetGL_ACCUM_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_CLEAR_VALUE);
}




Handle<Value> GetGL_ACCUM(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM);
}




Handle<Value> GetGL_ADD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ADD);
}




Handle<Value> GetGL_LOAD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LOAD);
}




Handle<Value> GetGL_MULT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MULT);
}




Handle<Value> GetGL_RETURN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RETURN);
}




Handle<Value> GetGL_ALPHA_TEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_TEST);
}




Handle<Value> GetGL_ALPHA_TEST_REF(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_TEST_REF);
}




Handle<Value> GetGL_ALPHA_TEST_FUNC(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_TEST_FUNC);
}




Handle<Value> GetGL_BLEND(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND);
}




Handle<Value> GetGL_BLEND_SRC(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND_SRC);
}




Handle<Value> GetGL_BLEND_DST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND_DST);
}




Handle<Value> GetGL_ZERO(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ZERO);
}




Handle<Value> GetGL_ONE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE);
}




Handle<Value> GetGL_SRC_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SRC_COLOR);
}




Handle<Value> GetGL_ONE_MINUS_SRC_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_SRC_COLOR);
}




Handle<Value> GetGL_SRC_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SRC_ALPHA);
}




Handle<Value> GetGL_ONE_MINUS_SRC_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_SRC_ALPHA);
}




Handle<Value> GetGL_DST_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DST_ALPHA);
}




Handle<Value> GetGL_ONE_MINUS_DST_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_DST_ALPHA);
}




Handle<Value> GetGL_DST_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DST_COLOR);
}




Handle<Value> GetGL_ONE_MINUS_DST_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_DST_COLOR);
}




Handle<Value> GetGL_SRC_ALPHA_SATURATE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SRC_ALPHA_SATURATE);
}




Handle<Value> GetGL_FEEDBACK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FEEDBACK);
}




Handle<Value> GetGL_RENDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RENDER);
}




Handle<Value> GetGL_SELECT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SELECT);
}




Handle<Value> GetGL_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_2D);
}




Handle<Value> GetGL_3D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_3D);
}




Handle<Value> GetGL_3D_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_3D_COLOR);
}




Handle<Value> GetGL_3D_COLOR_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_3D_COLOR_TEXTURE);
}




Handle<Value> GetGL_4D_COLOR_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_4D_COLOR_TEXTURE);
}




Handle<Value> GetGL_POINT_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_TOKEN);
}




Handle<Value> GetGL_LINE_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_TOKEN);
}




Handle<Value> GetGL_LINE_RESET_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_RESET_TOKEN);
}




Handle<Value> GetGL_POLYGON_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_TOKEN);
}




Handle<Value> GetGL_BITMAP_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BITMAP_TOKEN);
}




Handle<Value> GetGL_DRAW_PIXEL_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DRAW_PIXEL_TOKEN);
}




Handle<Value> GetGL_COPY_PIXEL_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COPY_PIXEL_TOKEN);
}




Handle<Value> GetGL_PASS_THROUGH_TOKEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PASS_THROUGH_TOKEN);
}




Handle<Value> GetGL_FEEDBACK_BUFFER_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FEEDBACK_BUFFER_POINTER);
}




Handle<Value> GetGL_FEEDBACK_BUFFER_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FEEDBACK_BUFFER_SIZE);
}




Handle<Value> GetGL_FEEDBACK_BUFFER_TYPE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FEEDBACK_BUFFER_TYPE);
}




Handle<Value> GetGL_SELECTION_BUFFER_POINTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SELECTION_BUFFER_POINTER);
}




Handle<Value> GetGL_SELECTION_BUFFER_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SELECTION_BUFFER_SIZE);
}




Handle<Value> GetGL_FOG(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG);
}




Handle<Value> GetGL_FOG_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_MODE);
}




Handle<Value> GetGL_FOG_DENSITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_DENSITY);
}




Handle<Value> GetGL_FOG_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_COLOR);
}




Handle<Value> GetGL_FOG_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_INDEX);
}




Handle<Value> GetGL_FOG_START(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_START);
}




Handle<Value> GetGL_FOG_END(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_END);
}




Handle<Value> GetGL_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINEAR);
}




Handle<Value> GetGL_EXP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EXP);
}




Handle<Value> GetGL_EXP2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EXP2);
}




Handle<Value> GetGL_LOGIC_OP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LOGIC_OP);
}




Handle<Value> GetGL_INDEX_LOGIC_OP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_LOGIC_OP);
}




Handle<Value> GetGL_COLOR_LOGIC_OP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_LOGIC_OP);
}




Handle<Value> GetGL_LOGIC_OP_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LOGIC_OP_MODE);
}




Handle<Value> GetGL_CLEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLEAR);
}




Handle<Value> GetGL_SET(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SET);
}




Handle<Value> GetGL_COPY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COPY);
}




Handle<Value> GetGL_COPY_INVERTED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COPY_INVERTED);
}




Handle<Value> GetGL_NOOP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NOOP);
}




Handle<Value> GetGL_INVERT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INVERT);
}




Handle<Value> GetGL_AND(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AND);
}




Handle<Value> GetGL_NAND(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NAND);
}




Handle<Value> GetGL_OR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OR);
}




Handle<Value> GetGL_NOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NOR);
}




Handle<Value> GetGL_XOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_XOR);
}




Handle<Value> GetGL_EQUIV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EQUIV);
}




Handle<Value> GetGL_AND_REVERSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AND_REVERSE);
}




Handle<Value> GetGL_AND_INVERTED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AND_INVERTED);
}




Handle<Value> GetGL_OR_REVERSE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OR_REVERSE);
}




Handle<Value> GetGL_OR_INVERTED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OR_INVERTED);
}




Handle<Value> GetGL_STENCIL_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_BITS);
}




Handle<Value> GetGL_STENCIL_TEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_TEST);
}




Handle<Value> GetGL_STENCIL_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_CLEAR_VALUE);
}




Handle<Value> GetGL_STENCIL_FUNC(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_FUNC);
}




Handle<Value> GetGL_STENCIL_VALUE_MASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_VALUE_MASK);
}




Handle<Value> GetGL_STENCIL_FAIL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_FAIL);
}




Handle<Value> GetGL_STENCIL_PASS_DEPTH_FAIL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_PASS_DEPTH_FAIL);
}




Handle<Value> GetGL_STENCIL_PASS_DEPTH_PASS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_PASS_DEPTH_PASS);
}




Handle<Value> GetGL_STENCIL_REF(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_REF);
}




Handle<Value> GetGL_STENCIL_WRITEMASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_WRITEMASK);
}




Handle<Value> GetGL_STENCIL_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_INDEX);
}




Handle<Value> GetGL_KEEP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_KEEP);
}




Handle<Value> GetGL_REPLACE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REPLACE);
}




Handle<Value> GetGL_INCR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INCR);
}




Handle<Value> GetGL_DECR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DECR);
}




Handle<Value> GetGL_NONE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NONE);
}




Handle<Value> GetGL_LEFT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LEFT);
}




Handle<Value> GetGL_RIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RIGHT);
}




Handle<Value> GetGL_FRONT_LEFT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT_LEFT);
}




Handle<Value> GetGL_FRONT_RIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRONT_RIGHT);
}




Handle<Value> GetGL_BACK_LEFT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BACK_LEFT);
}




Handle<Value> GetGL_BACK_RIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BACK_RIGHT);
}




Handle<Value> GetGL_AUX0(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX0);
}




Handle<Value> GetGL_AUX1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX1);
}




Handle<Value> GetGL_AUX2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX2);
}




Handle<Value> GetGL_AUX3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX3);
}




Handle<Value> GetGL_COLOR_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_INDEX);
}




Handle<Value> GetGL_RED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RED);
}




Handle<Value> GetGL_GREEN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREEN);
}




Handle<Value> GetGL_BLUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLUE);
}




Handle<Value> GetGL_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA);
}




Handle<Value> GetGL_LUMINANCE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE);
}




Handle<Value> GetGL_LUMINANCE_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE_ALPHA);
}




Handle<Value> GetGL_ALPHA_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_BITS);
}




Handle<Value> GetGL_RED_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RED_BITS);
}




Handle<Value> GetGL_GREEN_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREEN_BITS);
}




Handle<Value> GetGL_BLUE_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLUE_BITS);
}




Handle<Value> GetGL_INDEX_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_BITS);
}




Handle<Value> GetGL_SUBPIXEL_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SUBPIXEL_BITS);
}




Handle<Value> GetGL_AUX_BUFFERS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUX_BUFFERS);
}




Handle<Value> GetGL_READ_BUFFER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_READ_BUFFER);
}




Handle<Value> GetGL_DRAW_BUFFER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DRAW_BUFFER);
}




Handle<Value> GetGL_DOUBLEBUFFER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOUBLEBUFFER);
}




Handle<Value> GetGL_STEREO(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STEREO);
}




Handle<Value> GetGL_BITMAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BITMAP);
}




Handle<Value> GetGL_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR);
}




Handle<Value> GetGL_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH);
}




Handle<Value> GetGL_STENCIL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL);
}




Handle<Value> GetGL_DITHER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DITHER);
}




Handle<Value> GetGL_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB);
}




Handle<Value> GetGL_RGBA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA);
}




Handle<Value> GetGL_MAX_LIST_NESTING(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_LIST_NESTING);
}




Handle<Value> GetGL_MAX_EVAL_ORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_EVAL_ORDER);
}




Handle<Value> GetGL_MAX_LIGHTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_LIGHTS);
}




Handle<Value> GetGL_MAX_CLIP_PLANES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CLIP_PLANES);
}




Handle<Value> GetGL_MAX_TEXTURE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_TEXTURE_SIZE);
}




Handle<Value> GetGL_MAX_PIXEL_MAP_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_PIXEL_MAP_TABLE);
}




Handle<Value> GetGL_MAX_ATTRIB_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_ATTRIB_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_MODELVIEW_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_MODELVIEW_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_NAME_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_NAME_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_PROJECTION_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_PROJECTION_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_TEXTURE_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_TEXTURE_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_VIEWPORT_DIMS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_VIEWPORT_DIMS);
}




Handle<Value> GetGL_MAX_CLIENT_ATTRIB_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CLIENT_ATTRIB_STACK_DEPTH);
}




Handle<Value> GetGL_ATTRIB_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ATTRIB_STACK_DEPTH);
}




Handle<Value> GetGL_CLIENT_ATTRIB_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_ATTRIB_STACK_DEPTH);
}




Handle<Value> GetGL_COLOR_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_CLEAR_VALUE);
}




Handle<Value> GetGL_COLOR_WRITEMASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_WRITEMASK);
}




Handle<Value> GetGL_CURRENT_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_INDEX);
}




Handle<Value> GetGL_CURRENT_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_COLOR);
}




Handle<Value> GetGL_CURRENT_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_NORMAL);
}




Handle<Value> GetGL_CURRENT_RASTER_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_COLOR);
}




Handle<Value> GetGL_CURRENT_RASTER_DISTANCE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_DISTANCE);
}




Handle<Value> GetGL_CURRENT_RASTER_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_INDEX);
}




Handle<Value> GetGL_CURRENT_RASTER_POSITION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_POSITION);
}




Handle<Value> GetGL_CURRENT_RASTER_TEXTURE_COORDS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_TEXTURE_COORDS);
}




Handle<Value> GetGL_CURRENT_RASTER_POSITION_VALID(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_RASTER_POSITION_VALID);
}




Handle<Value> GetGL_CURRENT_TEXTURE_COORDS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_TEXTURE_COORDS);
}




Handle<Value> GetGL_INDEX_CLEAR_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_CLEAR_VALUE);
}




Handle<Value> GetGL_INDEX_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_MODE);
}




Handle<Value> GetGL_INDEX_WRITEMASK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_WRITEMASK);
}




Handle<Value> GetGL_MODELVIEW_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MODELVIEW_MATRIX);
}




Handle<Value> GetGL_MODELVIEW_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MODELVIEW_STACK_DEPTH);
}




Handle<Value> GetGL_NAME_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NAME_STACK_DEPTH);
}




Handle<Value> GetGL_PROJECTION_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROJECTION_MATRIX);
}




Handle<Value> GetGL_PROJECTION_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROJECTION_STACK_DEPTH);
}




Handle<Value> GetGL_RENDER_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RENDER_MODE);
}




Handle<Value> GetGL_RGBA_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA_MODE);
}




Handle<Value> GetGL_TEXTURE_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MATRIX);
}




Handle<Value> GetGL_TEXTURE_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_STACK_DEPTH);
}




Handle<Value> GetGL_VIEWPORT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VIEWPORT);
}




Handle<Value> GetGL_AUTO_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_AUTO_NORMAL);
}




Handle<Value> GetGL_MAP1_COLOR_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_COLOR_4);
}




Handle<Value> GetGL_MAP1_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_INDEX);
}




Handle<Value> GetGL_MAP1_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_NORMAL);
}




Handle<Value> GetGL_MAP1_TEXTURE_COORD_1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_TEXTURE_COORD_1);
}




Handle<Value> GetGL_MAP1_TEXTURE_COORD_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_TEXTURE_COORD_2);
}




Handle<Value> GetGL_MAP1_TEXTURE_COORD_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_TEXTURE_COORD_3);
}




Handle<Value> GetGL_MAP1_TEXTURE_COORD_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_TEXTURE_COORD_4);
}




Handle<Value> GetGL_MAP1_VERTEX_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_VERTEX_3);
}




Handle<Value> GetGL_MAP1_VERTEX_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_VERTEX_4);
}




Handle<Value> GetGL_MAP2_COLOR_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_COLOR_4);
}




Handle<Value> GetGL_MAP2_INDEX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_INDEX);
}




Handle<Value> GetGL_MAP2_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_NORMAL);
}




Handle<Value> GetGL_MAP2_TEXTURE_COORD_1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_TEXTURE_COORD_1);
}




Handle<Value> GetGL_MAP2_TEXTURE_COORD_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_TEXTURE_COORD_2);
}




Handle<Value> GetGL_MAP2_TEXTURE_COORD_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_TEXTURE_COORD_3);
}




Handle<Value> GetGL_MAP2_TEXTURE_COORD_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_TEXTURE_COORD_4);
}




Handle<Value> GetGL_MAP2_VERTEX_3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_VERTEX_3);
}




Handle<Value> GetGL_MAP2_VERTEX_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_VERTEX_4);
}




Handle<Value> GetGL_MAP1_GRID_DOMAIN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_GRID_DOMAIN);
}




Handle<Value> GetGL_MAP1_GRID_SEGMENTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP1_GRID_SEGMENTS);
}




Handle<Value> GetGL_MAP2_GRID_DOMAIN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_GRID_DOMAIN);
}




Handle<Value> GetGL_MAP2_GRID_SEGMENTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP2_GRID_SEGMENTS);
}




Handle<Value> GetGL_COEFF(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COEFF);
}




Handle<Value> GetGL_ORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ORDER);
}




Handle<Value> GetGL_DOMAIN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOMAIN);
}




Handle<Value> GetGL_PERSPECTIVE_CORRECTION_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PERSPECTIVE_CORRECTION_HINT);
}




Handle<Value> GetGL_POINT_SMOOTH_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_SMOOTH_HINT);
}




Handle<Value> GetGL_LINE_SMOOTH_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_SMOOTH_HINT);
}




Handle<Value> GetGL_POLYGON_SMOOTH_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_SMOOTH_HINT);
}




Handle<Value> GetGL_FOG_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_HINT);
}




Handle<Value> GetGL_DONT_CARE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DONT_CARE);
}




Handle<Value> GetGL_FASTEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FASTEST);
}




Handle<Value> GetGL_NICEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NICEST);
}




Handle<Value> GetGL_SCISSOR_BOX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SCISSOR_BOX);
}




Handle<Value> GetGL_SCISSOR_TEST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SCISSOR_TEST);
}




Handle<Value> GetGL_MAP_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP_COLOR);
}




Handle<Value> GetGL_MAP_STENCIL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAP_STENCIL);
}




Handle<Value> GetGL_INDEX_SHIFT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_SHIFT);
}




Handle<Value> GetGL_INDEX_OFFSET(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INDEX_OFFSET);
}




Handle<Value> GetGL_RED_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RED_SCALE);
}




Handle<Value> GetGL_RED_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RED_BIAS);
}




Handle<Value> GetGL_GREEN_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREEN_SCALE);
}




Handle<Value> GetGL_GREEN_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_GREEN_BIAS);
}




Handle<Value> GetGL_BLUE_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLUE_SCALE);
}




Handle<Value> GetGL_BLUE_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLUE_BIAS);
}




Handle<Value> GetGL_ALPHA_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_SCALE);
}




Handle<Value> GetGL_ALPHA_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_BIAS);
}




Handle<Value> GetGL_DEPTH_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_SCALE);
}




Handle<Value> GetGL_DEPTH_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_BIAS);
}




Handle<Value> GetGL_PIXEL_MAP_S_TO_S_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_S_TO_S_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_I_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_I_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_R_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_R_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_G_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_G_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_B_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_B_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_A_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_A_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_R_TO_R_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_R_TO_R_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_G_TO_G_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_G_TO_G_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_B_TO_B_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_B_TO_B_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_A_TO_A_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_A_TO_A_SIZE);
}




Handle<Value> GetGL_PIXEL_MAP_S_TO_S(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_S_TO_S);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_I(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_I);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_R);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_G(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_G);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_B(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_B);
}




Handle<Value> GetGL_PIXEL_MAP_I_TO_A(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_I_TO_A);
}




Handle<Value> GetGL_PIXEL_MAP_R_TO_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_R_TO_R);
}




Handle<Value> GetGL_PIXEL_MAP_G_TO_G(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_G_TO_G);
}




Handle<Value> GetGL_PIXEL_MAP_B_TO_B(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_B_TO_B);
}




Handle<Value> GetGL_PIXEL_MAP_A_TO_A(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MAP_A_TO_A);
}




Handle<Value> GetGL_PACK_ALIGNMENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_ALIGNMENT);
}




Handle<Value> GetGL_PACK_LSB_FIRST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_LSB_FIRST);
}




Handle<Value> GetGL_PACK_ROW_LENGTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_ROW_LENGTH);
}




Handle<Value> GetGL_PACK_SKIP_PIXELS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_SKIP_PIXELS);
}




Handle<Value> GetGL_PACK_SKIP_ROWS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_SKIP_ROWS);
}




Handle<Value> GetGL_PACK_SWAP_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_SWAP_BYTES);
}




Handle<Value> GetGL_UNPACK_ALIGNMENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_ALIGNMENT);
}




Handle<Value> GetGL_UNPACK_LSB_FIRST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_LSB_FIRST);
}




Handle<Value> GetGL_UNPACK_ROW_LENGTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_ROW_LENGTH);
}




Handle<Value> GetGL_UNPACK_SKIP_PIXELS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_SKIP_PIXELS);
}




Handle<Value> GetGL_UNPACK_SKIP_ROWS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_SKIP_ROWS);
}




Handle<Value> GetGL_UNPACK_SWAP_BYTES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_SWAP_BYTES);
}




Handle<Value> GetGL_ZOOM_X(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ZOOM_X);
}




Handle<Value> GetGL_ZOOM_Y(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ZOOM_Y);
}




Handle<Value> GetGL_TEXTURE_ENV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_ENV);
}




Handle<Value> GetGL_TEXTURE_ENV_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_ENV_MODE);
}




Handle<Value> GetGL_TEXTURE_1D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_1D);
}




Handle<Value> GetGL_TEXTURE_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_2D);
}




Handle<Value> GetGL_TEXTURE_WRAP_S(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_WRAP_S);
}




Handle<Value> GetGL_TEXTURE_WRAP_T(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_WRAP_T);
}




Handle<Value> GetGL_TEXTURE_MAG_FILTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MAG_FILTER);
}




Handle<Value> GetGL_TEXTURE_MIN_FILTER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MIN_FILTER);
}




Handle<Value> GetGL_TEXTURE_ENV_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_ENV_COLOR);
}




Handle<Value> GetGL_TEXTURE_GEN_S(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_S);
}




Handle<Value> GetGL_TEXTURE_GEN_T(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_T);
}




Handle<Value> GetGL_TEXTURE_GEN_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_MODE);
}




Handle<Value> GetGL_TEXTURE_BORDER_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BORDER_COLOR);
}




Handle<Value> GetGL_TEXTURE_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_WIDTH);
}




Handle<Value> GetGL_TEXTURE_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_HEIGHT);
}




Handle<Value> GetGL_TEXTURE_BORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BORDER);
}




Handle<Value> GetGL_TEXTURE_COMPONENTS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COMPONENTS);
}




Handle<Value> GetGL_TEXTURE_RED_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_RED_SIZE);
}




Handle<Value> GetGL_TEXTURE_GREEN_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GREEN_SIZE);
}




Handle<Value> GetGL_TEXTURE_BLUE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BLUE_SIZE);
}




Handle<Value> GetGL_TEXTURE_ALPHA_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_ALPHA_SIZE);
}




Handle<Value> GetGL_TEXTURE_LUMINANCE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_LUMINANCE_SIZE);
}




Handle<Value> GetGL_TEXTURE_INTENSITY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_INTENSITY_SIZE);
}




Handle<Value> GetGL_NEAREST_MIPMAP_NEAREST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NEAREST_MIPMAP_NEAREST);
}




Handle<Value> GetGL_NEAREST_MIPMAP_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NEAREST_MIPMAP_LINEAR);
}




Handle<Value> GetGL_LINEAR_MIPMAP_NEAREST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINEAR_MIPMAP_NEAREST);
}




Handle<Value> GetGL_LINEAR_MIPMAP_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINEAR_MIPMAP_LINEAR);
}




Handle<Value> GetGL_OBJECT_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OBJECT_LINEAR);
}




Handle<Value> GetGL_OBJECT_PLANE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OBJECT_PLANE);
}




Handle<Value> GetGL_EYE_LINEAR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EYE_LINEAR);
}




Handle<Value> GetGL_EYE_PLANE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EYE_PLANE);
}




Handle<Value> GetGL_SPHERE_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SPHERE_MAP);
}




Handle<Value> GetGL_DECAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DECAL);
}




Handle<Value> GetGL_MODULATE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MODULATE);
}




Handle<Value> GetGL_NEAREST(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NEAREST);
}




Handle<Value> GetGL_REPEAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REPEAT);
}




Handle<Value> GetGL_CLAMP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLAMP);
}




Handle<Value> GetGL_S(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_S);
}




Handle<Value> GetGL_T(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_T);
}




Handle<Value> GetGL_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_R);
}




Handle<Value> GetGL_Q(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_Q);
}




Handle<Value> GetGL_TEXTURE_GEN_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_R);
}




Handle<Value> GetGL_TEXTURE_GEN_Q(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_GEN_Q);
}




Handle<Value> GetGL_VENDOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VENDOR);
}




Handle<Value> GetGL_RENDERER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RENDERER);
}




Handle<Value> GetGL_VERSION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERSION);
}




Handle<Value> GetGL_EXTENSIONS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EXTENSIONS);
}




Handle<Value> GetGL_NO_ERROR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NO_ERROR);
}




Handle<Value> GetGL_INVALID_ENUM(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INVALID_ENUM);
}




Handle<Value> GetGL_INVALID_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INVALID_VALUE);
}




Handle<Value> GetGL_INVALID_OPERATION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INVALID_OPERATION);
}




Handle<Value> GetGL_STACK_OVERFLOW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STACK_OVERFLOW);
}




Handle<Value> GetGL_STACK_UNDERFLOW(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STACK_UNDERFLOW);
}




Handle<Value> GetGL_OUT_OF_MEMORY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OUT_OF_MEMORY);
}




Handle<Value> GetGL_CURRENT_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CURRENT_BIT);
}




Handle<Value> GetGL_POINT_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POINT_BIT);
}




Handle<Value> GetGL_LINE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LINE_BIT);
}




Handle<Value> GetGL_POLYGON_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_BIT);
}




Handle<Value> GetGL_POLYGON_STIPPLE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POLYGON_STIPPLE_BIT);
}




Handle<Value> GetGL_PIXEL_MODE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PIXEL_MODE_BIT);
}




Handle<Value> GetGL_LIGHTING_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHTING_BIT);
}




Handle<Value> GetGL_FOG_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FOG_BIT);
}




Handle<Value> GetGL_DEPTH_BUFFER_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_BUFFER_BIT);
}




Handle<Value> GetGL_ACCUM_BUFFER_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACCUM_BUFFER_BIT);
}




Handle<Value> GetGL_STENCIL_BUFFER_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_STENCIL_BUFFER_BIT);
}




Handle<Value> GetGL_VIEWPORT_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VIEWPORT_BIT);
}




Handle<Value> GetGL_TRANSFORM_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSFORM_BIT);
}




Handle<Value> GetGL_ENABLE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ENABLE_BIT);
}




Handle<Value> GetGL_COLOR_BUFFER_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_BUFFER_BIT);
}




Handle<Value> GetGL_HINT_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HINT_BIT);
}




Handle<Value> GetGL_EVAL_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_EVAL_BIT);
}




Handle<Value> GetGL_LIST_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIST_BIT);
}




Handle<Value> GetGL_TEXTURE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BIT);
}




Handle<Value> GetGL_SCISSOR_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SCISSOR_BIT);
}




Handle<Value> GetGL_ALL_ATTRIB_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALL_ATTRIB_BITS);
}




Handle<Value> GetGL_PROXY_TEXTURE_1D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_1D);
}




Handle<Value> GetGL_PROXY_TEXTURE_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_2D);
}




Handle<Value> GetGL_TEXTURE_PRIORITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_PRIORITY);
}




Handle<Value> GetGL_TEXTURE_RESIDENT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_RESIDENT);
}




Handle<Value> GetGL_TEXTURE_BINDING_1D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_1D);
}




Handle<Value> GetGL_TEXTURE_BINDING_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_2D);
}




Handle<Value> GetGL_TEXTURE_INTERNAL_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_INTERNAL_FORMAT);
}




Handle<Value> GetGL_ALPHA4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA4);
}




Handle<Value> GetGL_ALPHA8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA8);
}




Handle<Value> GetGL_ALPHA12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA12);
}




Handle<Value> GetGL_ALPHA16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA16);
}




Handle<Value> GetGL_LUMINANCE4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE4);
}




Handle<Value> GetGL_LUMINANCE8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE8);
}




Handle<Value> GetGL_LUMINANCE12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE12);
}




Handle<Value> GetGL_LUMINANCE16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE16);
}




Handle<Value> GetGL_LUMINANCE4_ALPHA4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE4_ALPHA4);
}




Handle<Value> GetGL_LUMINANCE6_ALPHA2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE6_ALPHA2);
}




Handle<Value> GetGL_LUMINANCE8_ALPHA8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE8_ALPHA8);
}




Handle<Value> GetGL_LUMINANCE12_ALPHA4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE12_ALPHA4);
}




Handle<Value> GetGL_LUMINANCE12_ALPHA12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE12_ALPHA12);
}




Handle<Value> GetGL_LUMINANCE16_ALPHA16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LUMINANCE16_ALPHA16);
}




Handle<Value> GetGL_INTENSITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY);
}




Handle<Value> GetGL_INTENSITY4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY4);
}




Handle<Value> GetGL_INTENSITY8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY8);
}




Handle<Value> GetGL_INTENSITY12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY12);
}




Handle<Value> GetGL_INTENSITY16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTENSITY16);
}




Handle<Value> GetGL_R3_G3_B2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_R3_G3_B2);
}




Handle<Value> GetGL_RGB4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB4);
}




Handle<Value> GetGL_RGB5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB5);
}




Handle<Value> GetGL_RGB8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB8);
}




Handle<Value> GetGL_RGB10(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB10);
}




Handle<Value> GetGL_RGB12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB12);
}




Handle<Value> GetGL_RGB16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB16);
}




Handle<Value> GetGL_RGBA2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA2);
}




Handle<Value> GetGL_RGBA4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA4);
}




Handle<Value> GetGL_RGB5_A1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB5_A1);
}




Handle<Value> GetGL_RGBA8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA8);
}




Handle<Value> GetGL_RGB10_A2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB10_A2);
}




Handle<Value> GetGL_RGBA12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA12);
}




Handle<Value> GetGL_RGBA16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGBA16);
}




Handle<Value> GetGL_CLIENT_PIXEL_STORE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_PIXEL_STORE_BIT);
}




Handle<Value> GetGL_CLIENT_VERTEX_ARRAY_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_VERTEX_ARRAY_BIT);
}




Handle<Value> GetGL_ALL_CLIENT_ATTRIB_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALL_CLIENT_ATTRIB_BITS);
}




Handle<Value> GetGL_CLIENT_ALL_ATTRIB_BITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_ALL_ATTRIB_BITS);
}




Handle<Value> GLClearIndexCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glClearIndex(( GLfloat ) arg0);
  return v8::Undefined();
}




Handle<Value> GLClearColorCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glClearColor(( GLclampf ) arg0, ( GLclampf ) arg1, ( GLclampf ) arg2, ( GLclampf ) arg3);
  return v8::Undefined();
}




Handle<Value> GLClearCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glClear(( GLbitfield ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexMaskCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glIndexMask(( GLuint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColorMaskCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glColorMask(( GLboolean ) arg0, ( GLboolean ) arg1, ( GLboolean ) arg2, ( GLboolean ) arg3);
  return v8::Undefined();
}




Handle<Value> GLAlphaFuncCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glAlphaFunc(( GLenum ) arg0, ( GLclampf ) arg1);
  return v8::Undefined();
}




Handle<Value> GLBlendFuncCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glBlendFunc(( GLenum ) arg0, ( GLenum ) arg1);
  return v8::Undefined();
}




Handle<Value> GLLogicOpCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glLogicOp(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLCullFaceCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glCullFace(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLFrontFaceCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glFrontFace(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLPointSizeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glPointSize(( GLfloat ) arg0);
  return v8::Undefined();
}




Handle<Value> GLLineWidthCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glLineWidth(( GLfloat ) arg0);
  return v8::Undefined();
}




Handle<Value> GLLineStippleCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  unsigned int arg1 = args[1]->Uint32Value();

  //make call
  glLineStipple(( GLint ) arg0, ( GLushort ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPolygonModeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glPolygonMode(( GLenum ) arg0, ( GLenum ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPolygonOffsetCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glPolygonOffset(( GLfloat ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPolygonStippleCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLubyte*   arg0 = new   GLubyte  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLubyte   aux = (  GLubyte  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glPolygonStipple(( const GLubyte* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLGetPolygonStippleCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
 GLubyte*   arg0 = new  GLubyte  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
     GLubyte   aux = ( GLubyte  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glGetPolygonStipple(( GLubyte* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEdgeFlagCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glEdgeFlag(( GLboolean ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEdgeFlagvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLboolean*   arg0 = new   GLboolean  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLboolean   aux = (  GLboolean  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glEdgeFlagv(( const GLboolean* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLScissorCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glScissor(( GLint ) arg0, ( GLint ) arg1, ( GLsizei ) arg2, ( GLsizei ) arg3);
  return v8::Undefined();
}




Handle<Value> GLClipPlaneCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glClipPlane(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLGetClipPlaneCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLdouble*   arg1 = new  GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLdouble   aux = ( GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glGetClipPlane(( GLenum ) arg0, ( GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLDrawBufferCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glDrawBuffer(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLReadBufferCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glReadBuffer(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEnableCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glEnable(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLDisableCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glDisable(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIsEnabledCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glIsEnabled(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEnableClientStateCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glEnableClientState(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLDisableClientStateCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glDisableClientState(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLGetBooleanvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLboolean*   arg1 = new  GLboolean  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLboolean   aux = ( GLboolean  )arg->Uint32Value();
    arg1[j] = aux; 
}
    
    
  //make call
  glGetBooleanv(( GLenum ) arg0, ( GLboolean* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLGetDoublevCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLdouble*   arg1 = new  GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLdouble   aux = ( GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glGetDoublev(( GLenum ) arg0, ( GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLGetFloatvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLfloat*   arg1 = new  GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glGetFloatv(( GLenum ) arg0, ( GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLGetIntegervCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLint*   arg1 = new  GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glGetIntegerv(( GLenum ) arg0, ( GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPushAttribCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glPushAttrib(( GLbitfield ) arg0);
  return v8::Undefined();
}




Handle<Value> GLPopAttribCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPopAttrib();
  return v8::Undefined();
}




Handle<Value> GLPushClientAttribCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glPushClientAttrib(( GLbitfield ) arg0);
  return v8::Undefined();
}




Handle<Value> GLPopClientAttribCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPopClientAttrib();
  return v8::Undefined();
}




Handle<Value> GLRenderModeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glRenderMode(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLGetErrorCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glGetError();
  return v8::Undefined();
}




Handle<Value> GLFinishCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glFinish();
  return v8::Undefined();
}




Handle<Value> GLFlushCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glFlush();
  return v8::Undefined();
}




Handle<Value> GLHintCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glHint(( GLenum ) arg0, ( GLenum ) arg1);
  return v8::Undefined();
}




Handle<Value> GLClearDepthCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glClearDepth(( GLclampd ) arg0);
  return v8::Undefined();
}




Handle<Value> GLDepthFuncCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glDepthFunc(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLDepthMaskCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glDepthMask(( GLboolean ) arg0);
  return v8::Undefined();
}




Handle<Value> GLDepthRangeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glDepthRange(( GLclampd ) arg0, ( GLclampd ) arg1);
  return v8::Undefined();
}




Handle<Value> GLClearAccumCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glClearAccum(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLAccumCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glAccum(( GLenum ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMatrixModeCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glMatrixMode(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLOrthoCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

  //make call
  glOrtho(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3, ( GLdouble ) arg4, ( GLdouble ) arg5);
  return v8::Undefined();
}




Handle<Value> GLFrustumCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

  //make call
  glFrustum(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3, ( GLdouble ) arg4, ( GLdouble ) arg5);
  return v8::Undefined();
}




Handle<Value> GLViewportCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glViewport(( GLint ) arg0, ( GLint ) arg1, ( GLsizei ) arg2, ( GLsizei ) arg3);
  return v8::Undefined();
}




Handle<Value> GLPushMatrixCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPushMatrix();
  return v8::Undefined();
}




Handle<Value> GLPopMatrixCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPopMatrix();
  return v8::Undefined();
}




Handle<Value> GLLoadIdentityCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glLoadIdentity();
  return v8::Undefined();
}




Handle<Value> GLLoadMatrixdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glLoadMatrixd(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLLoadMatrixfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glLoadMatrixf(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLMultMatrixdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glMultMatrixd(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLMultMatrixfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glMultMatrixf(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRotatedCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRotated(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRotatefCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRotatef(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLScaledCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glScaled(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLScalefCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glScalef(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTranslatedCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTranslated(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTranslatefCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTranslatef(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLIsListCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glIsList(( GLuint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLDeleteListsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  int arg1 = args[1]->IntegerValue();

  //make call
  glDeleteLists(( GLuint ) arg0, ( GLsizei ) arg1);
  return v8::Undefined();
}




Handle<Value> GLGenListsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glGenLists(( GLsizei ) arg0);
  return v8::Undefined();
}




Handle<Value> GLNewListCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  int arg1 = args[1]->IntegerValue();

  //make call
  glNewList(( GLuint ) arg0, ( GLenum ) arg1);
  return v8::Undefined();
}




Handle<Value> GLEndListCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glEndList();
  return v8::Undefined();
}




Handle<Value> GLCallListCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glCallList(( GLuint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLListBaseCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glListBase(( GLuint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLBeginCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glBegin(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEndCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glEnd();
  return v8::Undefined();
}




Handle<Value> GLVertex2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glVertex2d(( GLdouble ) arg0, ( GLdouble ) arg1);
  return v8::Undefined();
}




Handle<Value> GLVertex2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glVertex2f(( GLfloat ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLVertex2iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glVertex2i(( GLint ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLVertex2sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glVertex2s(( GLshort ) arg0, ( GLshort ) arg1);
  return v8::Undefined();
}




Handle<Value> GLVertex3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glVertex3d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLVertex3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glVertex3f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLVertex3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glVertex3i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLVertex3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glVertex3s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2);
  return v8::Undefined();
}




Handle<Value> GLVertex4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glVertex4d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3);
  return v8::Undefined();
}




Handle<Value> GLVertex4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glVertex4f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLVertex4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glVertex4i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3);
  return v8::Undefined();
}




Handle<Value> GLVertex4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glVertex4s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3);
  return v8::Undefined();
}




Handle<Value> GLVertex2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex2dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex2fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex2ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex2iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex2svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex2sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex3dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex3fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex3iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex3sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex4dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex4fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex4iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLVertex4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glVertex4sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLNormal3bCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glNormal3b(( GLbyte ) arg0, ( GLbyte ) arg1, ( GLbyte ) arg2);
  return v8::Undefined();
}




Handle<Value> GLNormal3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glNormal3d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLNormal3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glNormal3f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLNormal3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glNormal3i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLNormal3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glNormal3s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2);
  return v8::Undefined();
}




Handle<Value> GLNormal3bvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLbyte*   arg0 = new   GLbyte  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLbyte   aux = (  GLbyte  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glNormal3bv(( const GLbyte* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLNormal3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glNormal3dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLNormal3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glNormal3fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLNormal3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glNormal3iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLNormal3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glNormal3sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glIndexd(( GLdouble ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glIndexf(( GLfloat ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glIndexi(( GLint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glIndexs(( GLshort ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexubCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glIndexub(( GLubyte ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexdvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glIndexdv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glIndexfv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glIndexiv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexsvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glIndexsv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLIndexubvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLubyte*   arg0 = new   GLubyte  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLubyte   aux = (  GLubyte  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glIndexubv(( const GLubyte* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor3bCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glColor3b(( GLbyte ) arg0, ( GLbyte ) arg1, ( GLbyte ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColor3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glColor3d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColor3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glColor3f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColor3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glColor3i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColor3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glColor3s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColor3ubCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glColor3ub(( GLubyte ) arg0, ( GLubyte ) arg1, ( GLubyte ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColor3uiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glColor3ui(( GLuint ) arg0, ( GLuint ) arg1, ( GLuint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColor3usCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glColor3us(( GLushort ) arg0, ( GLushort ) arg1, ( GLushort ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColor4bCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glColor4b(( GLbyte ) arg0, ( GLbyte ) arg1, ( GLbyte ) arg2, ( GLbyte ) arg3);
  return v8::Undefined();
}




Handle<Value> GLColor4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glColor4d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3);
  return v8::Undefined();
}




Handle<Value> GLColor4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glColor4f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLColor4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glColor4i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3);
  return v8::Undefined();
}




Handle<Value> GLColor4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glColor4s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3);
  return v8::Undefined();
}




Handle<Value> GLColor4ubCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glColor4ub(( GLubyte ) arg0, ( GLubyte ) arg1, ( GLubyte ) arg2, ( GLubyte ) arg3);
  return v8::Undefined();
}




Handle<Value> GLColor4uiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glColor4ui(( GLuint ) arg0, ( GLuint ) arg1, ( GLuint ) arg2, ( GLuint ) arg3);
  return v8::Undefined();
}




Handle<Value> GLColor4usCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();
  unsigned int arg1 = args[1]->Uint32Value();
  unsigned int arg2 = args[2]->Uint32Value();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glColor4us(( GLushort ) arg0, ( GLushort ) arg1, ( GLushort ) arg2, ( GLushort ) arg3);
  return v8::Undefined();
}




Handle<Value> GLColor3bvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLbyte*   arg0 = new   GLbyte  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLbyte   aux = (  GLbyte  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor3bv(( const GLbyte* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor3dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor3fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor3iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor3sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor3ubvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLubyte*   arg0 = new   GLubyte  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLubyte   aux = (  GLubyte  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor3ubv(( const GLubyte* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor3uivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLuint*   arg0 = new   GLuint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLuint   aux = (  GLuint  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor3uiv(( const GLuint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor3usvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLushort*   arg0 = new   GLushort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLushort   aux = (  GLushort  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor3usv(( const GLushort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor4bvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLbyte*   arg0 = new   GLbyte  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLbyte   aux = (  GLbyte  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor4bv(( const GLbyte* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor4dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor4fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor4iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor4sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor4ubvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLubyte*   arg0 = new   GLubyte  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLubyte   aux = (  GLubyte  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor4ubv(( const GLubyte* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor4uivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLuint*   arg0 = new   GLuint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLuint   aux = (  GLuint  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor4uiv(( const GLuint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLColor4usvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLushort*   arg0 = new   GLushort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLushort   aux = (  GLushort  )arg->Uint32Value();
    arg0[j] = aux; 
}
    
    
  //make call
  glColor4usv(( const GLushort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glTexCoord1d(( GLdouble ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glTexCoord1f(( GLfloat ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord1iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glTexCoord1i(( GLint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord1sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glTexCoord1s(( GLshort ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glTexCoord2d(( GLdouble ) arg0, ( GLdouble ) arg1);
  return v8::Undefined();
}




Handle<Value> GLTexCoord2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glTexCoord2f(( GLfloat ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLTexCoord2iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glTexCoord2i(( GLint ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLTexCoord2sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glTexCoord2s(( GLshort ) arg0, ( GLshort ) arg1);
  return v8::Undefined();
}




Handle<Value> GLTexCoord3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexCoord3d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexCoord3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexCoord3f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexCoord3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexCoord3i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexCoord3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexCoord3s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexCoord4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glTexCoord4d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3);
  return v8::Undefined();
}




Handle<Value> GLTexCoord4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glTexCoord4f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLTexCoord4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glTexCoord4i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3);
  return v8::Undefined();
}




Handle<Value> GLTexCoord4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glTexCoord4s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3);
  return v8::Undefined();
}




Handle<Value> GLTexCoord1dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord1dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord1fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord1fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord1ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord1iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord1svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord1sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord2dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord2fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord2ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord2iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord2svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord2sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord3dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord3fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord3iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord3sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord4dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord4fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord4iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexCoord4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glTexCoord4sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glRasterPos2d(( GLdouble ) arg0, ( GLdouble ) arg1);
  return v8::Undefined();
}




Handle<Value> GLRasterPos2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glRasterPos2f(( GLfloat ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLRasterPos2iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glRasterPos2i(( GLint ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLRasterPos2sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glRasterPos2s(( GLshort ) arg0, ( GLshort ) arg1);
  return v8::Undefined();
}




Handle<Value> GLRasterPos3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glRasterPos3d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLRasterPos3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glRasterPos3f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLRasterPos3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glRasterPos3i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLRasterPos3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glRasterPos3s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2);
  return v8::Undefined();
}




Handle<Value> GLRasterPos4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRasterPos4d(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRasterPos4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRasterPos4f(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRasterPos4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glRasterPos4i(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRasterPos4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glRasterPos4s(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRasterPos2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos2dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos2fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos2ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos2iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos2svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos2sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos3dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos3fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos3iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos3sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos4dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos4fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos4iv(( const GLint* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRasterPos4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glRasterPos4sv(( const GLshort* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLRectdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRectd(( GLdouble ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRectfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glRectf(( GLfloat ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRectiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glRecti(( GLint ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRectsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glRects(( GLshort ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3);
  return v8::Undefined();
}




Handle<Value> GLRectdvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glRectdv(( const GLdouble* ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLRectfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glRectfv(( const GLfloat* ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLRectivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLint*   arg0 = new   GLint  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glRectiv(( const GLint* ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLRectsvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLshort*   arg0 = new   GLshort  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg0[j] = aux; 
}
    
    
    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glRectsv(( const GLshort* ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLArrayElementCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glArrayElement(( GLint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLDrawArraysCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glDrawArrays(( GLenum ) arg0, ( GLint ) arg1, ( GLsizei ) arg2);
  return v8::Undefined();
}




Handle<Value> GLShadeModelCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glShadeModel(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLLightfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glLightf(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLLightiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glLighti(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLLightfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat*   arg2 = new   GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glLightfv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLLightivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint*   arg2 = new   GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glLightiv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetLightfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetLightfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetLightivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetLightiv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLLightModelfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glLightModelf(( GLenum ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLLightModeliCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glLightModeli(( GLenum ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLLightModelfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glLightModelfv(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLLightModelivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glLightModeliv(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMaterialfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMaterialf(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMaterialiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMateriali(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMaterialfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat*   arg2 = new   GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glMaterialfv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMaterialivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint*   arg2 = new   GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glMaterialiv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetMaterialfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetMaterialfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetMaterialivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetMaterialiv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColorMaterialCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glColorMaterial(( GLenum ) arg0, ( GLenum ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPixelZoomCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glPixelZoom(( GLfloat ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPixelStorefCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glPixelStoref(( GLenum ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPixelStoreiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glPixelStorei(( GLenum ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPixelTransferfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glPixelTransferf(( GLenum ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPixelTransferiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glPixelTransferi(( GLenum ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPixelMapfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat*   arg2 = new   GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glPixelMapfv(( GLenum ) arg0, ( GLsizei ) arg1, ( const GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLPixelMapuivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLuint*   arg2 = new   GLuint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLuint   aux = (  GLuint  )arg->Uint32Value();
    arg2[j] = aux; 
}
    
    
  //make call
  glPixelMapuiv(( GLenum ) arg0, ( GLsizei ) arg1, ( const GLuint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLPixelMapusvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLushort*   arg2 = new   GLushort  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLushort   aux = (  GLushort  )arg->Uint32Value();
    arg2[j] = aux; 
}
    
    
  //make call
  glPixelMapusv(( GLenum ) arg0, ( GLsizei ) arg1, ( const GLushort* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetPixelMapfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLfloat*   arg1 = new  GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glGetPixelMapfv(( GLenum ) arg0, ( GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLGetPixelMapuivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLuint*   arg1 = new  GLuint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLuint   aux = ( GLuint  )arg->Uint32Value();
    arg1[j] = aux; 
}
    
    
  //make call
  glGetPixelMapuiv(( GLenum ) arg0, ( GLuint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLGetPixelMapusvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLushort*   arg1 = new  GLushort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLushort   aux = ( GLushort  )arg->Uint32Value();
    arg1[j] = aux; 
}
    
    
  //make call
  glGetPixelMapusv(( GLenum ) arg0, ( GLushort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLBitmapCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 7) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

    

Handle<Array> arrHandle6 = Handle<Array>::Cast(args[6]);
  GLubyte*   arg6 = new   GLubyte  [arrHandle6->Length()];
for (unsigned j = 0; j < arrHandle6->Length(); j++) {
    Handle<Value> arg(arrHandle6->Get(Integer::New(j)));
      GLubyte   aux = (  GLubyte  )arg->Uint32Value();
    arg6[j] = aux; 
}
    
    
  //make call
  glBitmap(( GLsizei ) arg0, ( GLsizei ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3, ( GLfloat ) arg4, ( GLfloat ) arg5, ( const GLubyte* ) arg6);
  return v8::Undefined();
}




Handle<Value> GLCopyPixelsCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glCopyPixels(( GLint ) arg0, ( GLint ) arg1, ( GLsizei ) arg2, ( GLsizei ) arg3, ( GLenum ) arg4);
  return v8::Undefined();
}




Handle<Value> GLStencilFuncCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glStencilFunc(( GLenum ) arg0, ( GLint ) arg1, ( GLuint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLStencilMaskCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glStencilMask(( GLuint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLStencilOpCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glStencilOp(( GLenum ) arg0, ( GLenum ) arg1, ( GLenum ) arg2);
  return v8::Undefined();
}




Handle<Value> GLClearStencilCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glClearStencil(( GLint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLTexGendCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexGend(( GLenum ) arg0, ( GLenum ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexGenfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexGenf(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexGeniCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexGeni(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexGendvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLdouble*   arg2 = new   GLdouble  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glTexGendv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLdouble* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexGenfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat*   arg2 = new   GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glTexGenfv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexGenivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint*   arg2 = new   GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glTexGeniv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetTexGendvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLdouble*   arg2 = new  GLdouble  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLdouble   aux = ( GLdouble  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetTexGendv(( GLenum ) arg0, ( GLenum ) arg1, ( GLdouble* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetTexGenfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetTexGenfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetTexGenivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetTexGeniv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexEnvfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexEnvf(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexEnviCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexEnvi(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexEnvfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat*   arg2 = new   GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glTexEnvfv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexEnvivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint*   arg2 = new   GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glTexEnviv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetTexEnvfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetTexEnvfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetTexEnvivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetTexEnviv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexParameterfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glTexParameterf(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexParameteriCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glTexParameteri(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat*   arg2 = new   GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glTexParameterfv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLTexParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint*   arg2 = new   GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glTexParameteriv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetTexParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetTexParameterfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetTexParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetTexParameteriv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetTexLevelParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

    

Handle<Array> arrHandle3 = Handle<Array>::Cast(args[3]);
 GLfloat*   arg3 = new  GLfloat  [arrHandle3->Length()];
for (unsigned j = 0; j < arrHandle3->Length(); j++) {
    Handle<Value> arg(arrHandle3->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg3[j] = aux; 
}
    
    
  //make call
  glGetTexLevelParameterfv(( GLenum ) arg0, ( GLint ) arg1, ( GLenum ) arg2, ( GLfloat* ) arg3);
  return v8::Undefined();
}




Handle<Value> GLGetTexLevelParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

    

Handle<Array> arrHandle3 = Handle<Array>::Cast(args[3]);
 GLint*   arg3 = new  GLint  [arrHandle3->Length()];
for (unsigned j = 0; j < arrHandle3->Length(); j++) {
    Handle<Value> arg(arrHandle3->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg3[j] = aux; 
}
    
    
  //make call
  glGetTexLevelParameteriv(( GLenum ) arg0, ( GLint ) arg1, ( GLenum ) arg2, ( GLint* ) arg3);
  return v8::Undefined();
}




Handle<Value> GLGenTexturesCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLuint*   arg1 = new  GLuint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLuint   aux = ( GLuint  )arg->Uint32Value();
    arg1[j] = aux; 
}
    
    
  //make call
  glGenTextures(( GLsizei ) arg0, ( GLuint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLDeleteTexturesCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLuint*   arg1 = new   GLuint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLuint   aux = (  GLuint  )arg->Uint32Value();
    arg1[j] = aux; 
}
    
    
  //make call
  glDeleteTextures(( GLsizei ) arg0, ( const GLuint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLBindTextureCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  unsigned int arg1 = args[1]->Uint32Value();

  //make call
  glBindTexture(( GLenum ) arg0, ( GLuint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLPrioritizeTexturesCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLuint*   arg1 = new   GLuint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLuint   aux = (  GLuint  )arg->Uint32Value();
    arg1[j] = aux; 
}
    
    
    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLclampf*   arg2 = new   GLclampf  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLclampf   aux = (  GLclampf  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glPrioritizeTextures(( GLsizei ) arg0, ( const GLuint* ) arg1, ( const GLclampf* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLAreTexturesResidentCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLuint*   arg1 = new   GLuint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLuint   aux = (  GLuint  )arg->Uint32Value();
    arg1[j] = aux; 
}
    
    
    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLboolean*   arg2 = new  GLboolean  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLboolean   aux = ( GLboolean  )arg->Uint32Value();
    arg2[j] = aux; 
}
    
    
  //make call
  glAreTexturesResident(( GLsizei ) arg0, ( const GLuint* ) arg1, ( GLboolean* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLIsTextureCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glIsTexture(( GLuint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLCopyTexImage1DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 7) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();
  int arg6 = args[6]->IntegerValue();

  //make call
  glCopyTexImage1D(( GLenum ) arg0, ( GLint ) arg1, ( GLenum ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( GLsizei ) arg5, ( GLint ) arg6);
  return v8::Undefined();
}




Handle<Value> GLCopyTexImage2DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 8) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();
  int arg6 = args[6]->IntegerValue();
  int arg7 = args[7]->IntegerValue();

  //make call
  glCopyTexImage2D(( GLenum ) arg0, ( GLint ) arg1, ( GLenum ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( GLsizei ) arg5, ( GLsizei ) arg6, ( GLint ) arg7);
  return v8::Undefined();
}




Handle<Value> GLCopyTexSubImage1DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();

  //make call
  glCopyTexSubImage1D(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( GLsizei ) arg5);
  return v8::Undefined();
}




Handle<Value> GLCopyTexSubImage2DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 8) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();
  int arg6 = args[6]->IntegerValue();
  int arg7 = args[7]->IntegerValue();

  //make call
  glCopyTexSubImage2D(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( GLint ) arg5, ( GLsizei ) arg6, ( GLsizei ) arg7);
  return v8::Undefined();
}




Handle<Value> GLMap1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

    

Handle<Array> arrHandle5 = Handle<Array>::Cast(args[5]);
  GLdouble*   arg5 = new   GLdouble  [arrHandle5->Length()];
for (unsigned j = 0; j < arrHandle5->Length(); j++) {
    Handle<Value> arg(arrHandle5->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg5[j] = aux; 
}
    
    
  //make call
  glMap1d(( GLenum ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( const GLdouble* ) arg5);
  return v8::Undefined();
}




Handle<Value> GLMap1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

    

Handle<Array> arrHandle5 = Handle<Array>::Cast(args[5]);
  GLfloat*   arg5 = new   GLfloat  [arrHandle5->Length()];
for (unsigned j = 0; j < arrHandle5->Length(); j++) {
    Handle<Value> arg(arrHandle5->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg5[j] = aux; 
}
    
    
  //make call
  glMap1f(( GLenum ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( const GLfloat* ) arg5);
  return v8::Undefined();
}




Handle<Value> GLMap2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 10) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  double arg5 = args[5]->NumberValue();
  double arg6 = args[6]->NumberValue();
  int arg7 = args[7]->IntegerValue();
  int arg8 = args[8]->IntegerValue();

    

Handle<Array> arrHandle9 = Handle<Array>::Cast(args[9]);
  GLdouble*   arg9 = new   GLdouble  [arrHandle9->Length()];
for (unsigned j = 0; j < arrHandle9->Length(); j++) {
    Handle<Value> arg(arrHandle9->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg9[j] = aux; 
}
    
    
  //make call
  glMap2d(( GLenum ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( GLdouble ) arg5, ( GLdouble ) arg6, ( GLint ) arg7, ( GLint ) arg8, ( const GLdouble* ) arg9);
  return v8::Undefined();
}




Handle<Value> GLMap2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 10) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  double arg5 = args[5]->NumberValue();
  double arg6 = args[6]->NumberValue();
  int arg7 = args[7]->IntegerValue();
  int arg8 = args[8]->IntegerValue();

    

Handle<Array> arrHandle9 = Handle<Array>::Cast(args[9]);
  GLfloat*   arg9 = new   GLfloat  [arrHandle9->Length()];
for (unsigned j = 0; j < arrHandle9->Length(); j++) {
    Handle<Value> arg(arrHandle9->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg9[j] = aux; 
}
    
    
  //make call
  glMap2f(( GLenum ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( GLfloat ) arg5, ( GLfloat ) arg6, ( GLint ) arg7, ( GLint ) arg8, ( const GLfloat* ) arg9);
  return v8::Undefined();
}




Handle<Value> GLGetMapdvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLdouble*   arg2 = new  GLdouble  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLdouble   aux = ( GLdouble  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetMapdv(( GLenum ) arg0, ( GLenum ) arg1, ( GLdouble* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetMapfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetMapfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetMapivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetMapiv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLEvalCoord1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glEvalCoord1d(( GLdouble ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEvalCoord1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glEvalCoord1f(( GLfloat ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEvalCoord1dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glEvalCoord1dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEvalCoord1fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glEvalCoord1fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEvalCoord2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glEvalCoord2d(( GLdouble ) arg0, ( GLdouble ) arg1);
  return v8::Undefined();
}




Handle<Value> GLEvalCoord2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glEvalCoord2f(( GLfloat ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLEvalCoord2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glEvalCoord2dv(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEvalCoord2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glEvalCoord2fv(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLMapGrid1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMapGrid1d(( GLint ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMapGrid1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMapGrid1f(( GLint ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMapGrid2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

  //make call
  glMapGrid2d(( GLint ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLint ) arg3, ( GLdouble ) arg4, ( GLdouble ) arg5);
  return v8::Undefined();
}




Handle<Value> GLMapGrid2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  int arg3 = args[3]->IntegerValue();
  double arg4 = args[4]->NumberValue();
  double arg5 = args[5]->NumberValue();

  //make call
  glMapGrid2f(( GLint ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLint ) arg3, ( GLfloat ) arg4, ( GLfloat ) arg5);
  return v8::Undefined();
}




Handle<Value> GLEvalPoint1Callback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glEvalPoint1(( GLint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLEvalPoint2Callback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glEvalPoint2(( GLint ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLEvalMesh1Callback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glEvalMesh1(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLEvalMesh2Callback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glEvalMesh2(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLint ) arg4);
  return v8::Undefined();
}




Handle<Value> GLFogfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glFogf(( GLenum ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLFogiCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glFogi(( GLenum ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLFogfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glFogfv(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLFogivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glFogiv(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLFeedbackBufferCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glFeedbackBuffer(( GLsizei ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLPassThroughCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();

  //make call
  glPassThrough(( GLfloat ) arg0);
  return v8::Undefined();
}




Handle<Value> GLSelectBufferCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
 GLuint*   arg1 = new  GLuint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
     GLuint   aux = ( GLuint  )arg->Uint32Value();
    arg1[j] = aux; 
}
    
    
  //make call
  glSelectBuffer(( GLsizei ) arg0, ( GLuint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLInitNamesCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glInitNames();
  return v8::Undefined();
}




Handle<Value> GLLoadNameCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glLoadName(( GLuint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLPushNameCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  unsigned int arg0 = args[0]->Uint32Value();

  //make call
  glPushName(( GLuint ) arg0);
  return v8::Undefined();
}




Handle<Value> GLPopNameCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 0) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

  //make call
  glPopName();
  return v8::Undefined();
}




Handle<Value> GetGL_RESCALE_NORMAL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RESCALE_NORMAL);
}




Handle<Value> GetGL_CLAMP_TO_EDGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLAMP_TO_EDGE);
}




Handle<Value> GetGL_MAX_ELEMENTS_VERTICES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_ELEMENTS_VERTICES);
}




Handle<Value> GetGL_MAX_ELEMENTS_INDICES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_ELEMENTS_INDICES);
}




Handle<Value> GetGL_BGR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BGR);
}




Handle<Value> GetGL_BGRA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BGRA);
}




Handle<Value> GetGL_UNSIGNED_BYTE_3_3_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_BYTE_3_3_2);
}




Handle<Value> GetGL_UNSIGNED_BYTE_2_3_3_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_BYTE_2_3_3_REV);
}




Handle<Value> GetGL_UNSIGNED_SHORT_5_6_5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_5_6_5);
}




Handle<Value> GetGL_UNSIGNED_SHORT_5_6_5_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_5_6_5_REV);
}




Handle<Value> GetGL_UNSIGNED_SHORT_4_4_4_4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_4_4_4_4);
}




Handle<Value> GetGL_UNSIGNED_SHORT_4_4_4_4_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_4_4_4_4_REV);
}




Handle<Value> GetGL_UNSIGNED_SHORT_5_5_5_1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_5_5_5_1);
}




Handle<Value> GetGL_UNSIGNED_SHORT_1_5_5_5_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_1_5_5_5_REV);
}




Handle<Value> GetGL_UNSIGNED_INT_8_8_8_8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_8_8_8_8);
}




Handle<Value> GetGL_UNSIGNED_INT_8_8_8_8_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_8_8_8_8_REV);
}




Handle<Value> GetGL_UNSIGNED_INT_10_10_10_2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_10_10_10_2);
}




Handle<Value> GetGL_UNSIGNED_INT_2_10_10_10_REV(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_2_10_10_10_REV);
}




Handle<Value> GetGL_LIGHT_MODEL_COLOR_CONTROL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_LIGHT_MODEL_COLOR_CONTROL);
}




Handle<Value> GetGL_SINGLE_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SINGLE_COLOR);
}




Handle<Value> GetGL_SEPARATE_SPECULAR_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SEPARATE_SPECULAR_COLOR);
}




Handle<Value> GetGL_TEXTURE_MIN_LOD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MIN_LOD);
}




Handle<Value> GetGL_TEXTURE_MAX_LOD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MAX_LOD);
}




Handle<Value> GetGL_TEXTURE_BASE_LEVEL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BASE_LEVEL);
}




Handle<Value> GetGL_TEXTURE_MAX_LEVEL(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_MAX_LEVEL);
}




Handle<Value> GetGL_SMOOTH_POINT_SIZE_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH_POINT_SIZE_RANGE);
}




Handle<Value> GetGL_SMOOTH_POINT_SIZE_GRANULARITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH_POINT_SIZE_GRANULARITY);
}




Handle<Value> GetGL_SMOOTH_LINE_WIDTH_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH_LINE_WIDTH_RANGE);
}




Handle<Value> GetGL_SMOOTH_LINE_WIDTH_GRANULARITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SMOOTH_LINE_WIDTH_GRANULARITY);
}




Handle<Value> GetGL_ALIASED_POINT_SIZE_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALIASED_POINT_SIZE_RANGE);
}




Handle<Value> GetGL_ALIASED_LINE_WIDTH_RANGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALIASED_LINE_WIDTH_RANGE);
}




Handle<Value> GetGL_PACK_SKIP_IMAGES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_SKIP_IMAGES);
}




Handle<Value> GetGL_PACK_IMAGE_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PACK_IMAGE_HEIGHT);
}




Handle<Value> GetGL_UNPACK_SKIP_IMAGES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_SKIP_IMAGES);
}




Handle<Value> GetGL_UNPACK_IMAGE_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNPACK_IMAGE_HEIGHT);
}




Handle<Value> GetGL_TEXTURE_3D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_3D);
}




Handle<Value> GetGL_PROXY_TEXTURE_3D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_3D);
}




Handle<Value> GetGL_TEXTURE_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_DEPTH);
}




Handle<Value> GetGL_TEXTURE_WRAP_R(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_WRAP_R);
}




Handle<Value> GetGL_MAX_3D_TEXTURE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_3D_TEXTURE_SIZE);
}




Handle<Value> GetGL_TEXTURE_BINDING_3D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_3D);
}




Handle<Value> GLCopyTexSubImage3DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 9) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();
  int arg6 = args[6]->IntegerValue();
  int arg7 = args[7]->IntegerValue();
  int arg8 = args[8]->IntegerValue();

  //make call
  glCopyTexSubImage3D(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLint ) arg4, ( GLint ) arg5, ( GLint ) arg6, ( GLsizei ) arg7, ( GLsizei ) arg8);
  return v8::Undefined();
}




Handle<Value> GetGL_CONSTANT_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT_COLOR);
}




Handle<Value> GetGL_ONE_MINUS_CONSTANT_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_CONSTANT_COLOR);
}




Handle<Value> GetGL_CONSTANT_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT_ALPHA);
}




Handle<Value> GetGL_ONE_MINUS_CONSTANT_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ONE_MINUS_CONSTANT_ALPHA);
}




Handle<Value> GetGL_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE);
}




Handle<Value> GetGL_POST_CONVOLUTION_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_COLOR_TABLE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_COLOR_TABLE);
}




Handle<Value> GetGL_PROXY_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_COLOR_TABLE);
}




Handle<Value> GetGL_PROXY_POST_CONVOLUTION_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_POST_CONVOLUTION_COLOR_TABLE);
}




Handle<Value> GetGL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE);
}




Handle<Value> GetGL_COLOR_TABLE_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_SCALE);
}




Handle<Value> GetGL_COLOR_TABLE_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_BIAS);
}




Handle<Value> GetGL_COLOR_TABLE_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_FORMAT);
}




Handle<Value> GetGL_COLOR_TABLE_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_WIDTH);
}




Handle<Value> GetGL_COLOR_TABLE_RED_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_RED_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_GREEN_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_GREEN_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_BLUE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_BLUE_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_ALPHA_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_ALPHA_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_LUMINANCE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_LUMINANCE_SIZE);
}




Handle<Value> GetGL_COLOR_TABLE_INTENSITY_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_TABLE_INTENSITY_SIZE);
}




Handle<Value> GetGL_CONVOLUTION_1D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_1D);
}




Handle<Value> GetGL_CONVOLUTION_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_2D);
}




Handle<Value> GetGL_SEPARABLE_2D(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SEPARABLE_2D);
}




Handle<Value> GetGL_CONVOLUTION_BORDER_MODE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_BORDER_MODE);
}




Handle<Value> GetGL_CONVOLUTION_FILTER_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_FILTER_SCALE);
}




Handle<Value> GetGL_CONVOLUTION_FILTER_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_FILTER_BIAS);
}




Handle<Value> GetGL_REDUCE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REDUCE);
}




Handle<Value> GetGL_CONVOLUTION_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_FORMAT);
}




Handle<Value> GetGL_CONVOLUTION_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_WIDTH);
}




Handle<Value> GetGL_CONVOLUTION_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_HEIGHT);
}




Handle<Value> GetGL_MAX_CONVOLUTION_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CONVOLUTION_WIDTH);
}




Handle<Value> GetGL_MAX_CONVOLUTION_HEIGHT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CONVOLUTION_HEIGHT);
}




Handle<Value> GetGL_POST_CONVOLUTION_RED_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_RED_SCALE);
}




Handle<Value> GetGL_POST_CONVOLUTION_GREEN_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_GREEN_SCALE);
}




Handle<Value> GetGL_POST_CONVOLUTION_BLUE_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_BLUE_SCALE);
}




Handle<Value> GetGL_POST_CONVOLUTION_ALPHA_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_ALPHA_SCALE);
}




Handle<Value> GetGL_POST_CONVOLUTION_RED_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_RED_BIAS);
}




Handle<Value> GetGL_POST_CONVOLUTION_GREEN_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_GREEN_BIAS);
}




Handle<Value> GetGL_POST_CONVOLUTION_BLUE_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_BLUE_BIAS);
}




Handle<Value> GetGL_POST_CONVOLUTION_ALPHA_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_CONVOLUTION_ALPHA_BIAS);
}




Handle<Value> GetGL_CONSTANT_BORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT_BORDER);
}




Handle<Value> GetGL_REPLICATE_BORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REPLICATE_BORDER);
}




Handle<Value> GetGL_CONVOLUTION_BORDER_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONVOLUTION_BORDER_COLOR);
}




Handle<Value> GetGL_COLOR_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATRIX);
}




Handle<Value> GetGL_COLOR_MATRIX_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COLOR_MATRIX_STACK_DEPTH);
}




Handle<Value> GetGL_MAX_COLOR_MATRIX_STACK_DEPTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_COLOR_MATRIX_STACK_DEPTH);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_RED_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_RED_SCALE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_GREEN_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_GREEN_SCALE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_BLUE_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_BLUE_SCALE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_ALPHA_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_ALPHA_SCALE);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_RED_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_RED_BIAS);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_GREEN_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_GREEN_BIAS);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_BLUE_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_BLUE_BIAS);
}




Handle<Value> GetGL_POST_COLOR_MATRIX_ALPHA_BIAS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_POST_COLOR_MATRIX_ALPHA_BIAS);
}




Handle<Value> GetGL_HISTOGRAM(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM);
}




Handle<Value> GetGL_PROXY_HISTOGRAM(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_HISTOGRAM);
}




Handle<Value> GetGL_HISTOGRAM_WIDTH(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_WIDTH);
}




Handle<Value> GetGL_HISTOGRAM_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_FORMAT);
}




Handle<Value> GetGL_HISTOGRAM_RED_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_RED_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_GREEN_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_GREEN_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_BLUE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_BLUE_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_ALPHA_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_ALPHA_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_LUMINANCE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_LUMINANCE_SIZE);
}




Handle<Value> GetGL_HISTOGRAM_SINK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_HISTOGRAM_SINK);
}




Handle<Value> GetGL_MINMAX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MINMAX);
}




Handle<Value> GetGL_MINMAX_FORMAT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MINMAX_FORMAT);
}




Handle<Value> GetGL_MINMAX_SINK(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MINMAX_SINK);
}




Handle<Value> GetGL_TABLE_TOO_LARGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TABLE_TOO_LARGE);
}




Handle<Value> GetGL_BLEND_EQUATION(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND_EQUATION);
}




Handle<Value> GetGL_MIN(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MIN);
}




Handle<Value> GetGL_MAX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX);
}




Handle<Value> GetGL_FUNC_ADD(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FUNC_ADD);
}




Handle<Value> GetGL_FUNC_SUBTRACT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FUNC_SUBTRACT);
}




Handle<Value> GetGL_FUNC_REVERSE_SUBTRACT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FUNC_REVERSE_SUBTRACT);
}




Handle<Value> GetGL_BLEND_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_BLEND_COLOR);
}




Handle<Value> GLColorTableParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint*   arg2 = new   GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glColorTableParameteriv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLColorTableParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat*   arg2 = new   GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glColorTableParameterfv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLCopyColorSubTableCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glCopyColorSubTable(( GLenum ) arg0, ( GLsizei ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLsizei ) arg4);
  return v8::Undefined();
}




Handle<Value> GLCopyColorTableCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glCopyColorTable(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLsizei ) arg4);
  return v8::Undefined();
}




Handle<Value> GLGetColorTableParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetColorTableParameterfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetColorTableParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetColorTableParameteriv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLBlendEquationCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glBlendEquation(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLBlendColorCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glBlendColor(( GLclampf ) arg0, ( GLclampf ) arg1, ( GLclampf ) arg2, ( GLclampf ) arg3);
  return v8::Undefined();
}




Handle<Value> GLHistogramCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  unsigned int arg3 = args[3]->Uint32Value();

  //make call
  glHistogram(( GLenum ) arg0, ( GLsizei ) arg1, ( GLenum ) arg2, ( GLboolean ) arg3);
  return v8::Undefined();
}




Handle<Value> GLResetHistogramCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glResetHistogram(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLGetHistogramParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetHistogramParameterfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetHistogramParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetHistogramParameteriv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMinmaxCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  unsigned int arg2 = args[2]->Uint32Value();

  //make call
  glMinmax(( GLenum ) arg0, ( GLenum ) arg1, ( GLboolean ) arg2);
  return v8::Undefined();
}




Handle<Value> GLResetMinmaxCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glResetMinmax(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLGetMinmaxParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetMinmaxParameterfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetMinmaxParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetMinmaxParameteriv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLConvolutionParameterfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glConvolutionParameterf(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLConvolutionParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLfloat*   arg2 = new   GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glConvolutionParameterfv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLConvolutionParameteriCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glConvolutionParameteri(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLConvolutionParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
  GLint*   arg2 = new   GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glConvolutionParameteriv(( GLenum ) arg0, ( GLenum ) arg1, ( const GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLCopyConvolutionFilter1DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glCopyConvolutionFilter1D(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLsizei ) arg4);
  return v8::Undefined();
}




Handle<Value> GLCopyConvolutionFilter2DCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 6) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();
  int arg5 = args[5]->IntegerValue();

  //make call
  glCopyConvolutionFilter2D(( GLenum ) arg0, ( GLenum ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLsizei ) arg4, ( GLsizei ) arg5);
  return v8::Undefined();
}




Handle<Value> GLGetConvolutionParameterfvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLfloat*   arg2 = new  GLfloat  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLfloat   aux = ( GLfloat  )arg->NumberValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetConvolutionParameterfv(( GLenum ) arg0, ( GLenum ) arg1, ( GLfloat* ) arg2);
  return v8::Undefined();
}




Handle<Value> GLGetConvolutionParameterivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

    

Handle<Array> arrHandle2 = Handle<Array>::Cast(args[2]);
 GLint*   arg2 = new  GLint  [arrHandle2->Length()];
for (unsigned j = 0; j < arrHandle2->Length(); j++) {
    Handle<Value> arg(arrHandle2->Get(Integer::New(j)));
     GLint   aux = ( GLint  )arg->IntegerValue();
    arg2[j] = aux; 
}
    
    
  //make call
  glGetConvolutionParameteriv(( GLenum ) arg0, ( GLenum ) arg1, ( GLint* ) arg2);
  return v8::Undefined();
}




Handle<Value> GetGL_TEXTURE0(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE0);
}




Handle<Value> GetGL_TEXTURE1(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE1);
}




Handle<Value> GetGL_TEXTURE2(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE2);
}




Handle<Value> GetGL_TEXTURE3(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE3);
}




Handle<Value> GetGL_TEXTURE4(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE4);
}




Handle<Value> GetGL_TEXTURE5(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE5);
}




Handle<Value> GetGL_TEXTURE6(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE6);
}




Handle<Value> GetGL_TEXTURE7(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE7);
}




Handle<Value> GetGL_TEXTURE8(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE8);
}




Handle<Value> GetGL_TEXTURE9(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE9);
}




Handle<Value> GetGL_TEXTURE10(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE10);
}




Handle<Value> GetGL_TEXTURE11(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE11);
}




Handle<Value> GetGL_TEXTURE12(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE12);
}




Handle<Value> GetGL_TEXTURE13(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE13);
}




Handle<Value> GetGL_TEXTURE14(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE14);
}




Handle<Value> GetGL_TEXTURE15(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE15);
}




Handle<Value> GetGL_TEXTURE16(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE16);
}




Handle<Value> GetGL_TEXTURE17(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE17);
}




Handle<Value> GetGL_TEXTURE18(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE18);
}




Handle<Value> GetGL_TEXTURE19(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE19);
}




Handle<Value> GetGL_TEXTURE20(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE20);
}




Handle<Value> GetGL_TEXTURE21(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE21);
}




Handle<Value> GetGL_TEXTURE22(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE22);
}




Handle<Value> GetGL_TEXTURE23(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE23);
}




Handle<Value> GetGL_TEXTURE24(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE24);
}




Handle<Value> GetGL_TEXTURE25(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE25);
}




Handle<Value> GetGL_TEXTURE26(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE26);
}




Handle<Value> GetGL_TEXTURE27(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE27);
}




Handle<Value> GetGL_TEXTURE28(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE28);
}




Handle<Value> GetGL_TEXTURE29(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE29);
}




Handle<Value> GetGL_TEXTURE30(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE30);
}




Handle<Value> GetGL_TEXTURE31(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE31);
}




Handle<Value> GetGL_ACTIVE_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACTIVE_TEXTURE);
}




Handle<Value> GetGL_CLIENT_ACTIVE_TEXTURE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_ACTIVE_TEXTURE);
}




Handle<Value> GetGL_MAX_TEXTURE_UNITS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_TEXTURE_UNITS);
}




Handle<Value> GetGL_NORMAL_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NORMAL_MAP);
}




Handle<Value> GetGL_REFLECTION_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_REFLECTION_MAP);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP);
}




Handle<Value> GetGL_TEXTURE_BINDING_CUBE_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_BINDING_CUBE_MAP);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_POSITIVE_X(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_POSITIVE_X);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_NEGATIVE_X(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_NEGATIVE_X);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_POSITIVE_Y(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_POSITIVE_Y);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_NEGATIVE_Y(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_NEGATIVE_Y);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_POSITIVE_Z(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_POSITIVE_Z);
}




Handle<Value> GetGL_TEXTURE_CUBE_MAP_NEGATIVE_Z(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_CUBE_MAP_NEGATIVE_Z);
}




Handle<Value> GetGL_PROXY_TEXTURE_CUBE_MAP(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PROXY_TEXTURE_CUBE_MAP);
}




Handle<Value> GetGL_MAX_CUBE_MAP_TEXTURE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_CUBE_MAP_TEXTURE_SIZE);
}




Handle<Value> GetGL_COMPRESSED_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_ALPHA);
}




Handle<Value> GetGL_COMPRESSED_LUMINANCE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_LUMINANCE);
}




Handle<Value> GetGL_COMPRESSED_LUMINANCE_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_LUMINANCE_ALPHA);
}




Handle<Value> GetGL_COMPRESSED_INTENSITY(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_INTENSITY);
}




Handle<Value> GetGL_COMPRESSED_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_RGB);
}




Handle<Value> GetGL_COMPRESSED_RGBA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_RGBA);
}




Handle<Value> GetGL_TEXTURE_COMPRESSION_HINT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COMPRESSION_HINT);
}




Handle<Value> GetGL_TEXTURE_COMPRESSED_IMAGE_SIZE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COMPRESSED_IMAGE_SIZE);
}




Handle<Value> GetGL_TEXTURE_COMPRESSED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE_COMPRESSED);
}




Handle<Value> GetGL_NUM_COMPRESSED_TEXTURE_FORMATS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_NUM_COMPRESSED_TEXTURE_FORMATS);
}




Handle<Value> GetGL_COMPRESSED_TEXTURE_FORMATS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMPRESSED_TEXTURE_FORMATS);
}




Handle<Value> GetGL_MULTISAMPLE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MULTISAMPLE);
}




Handle<Value> GetGL_SAMPLE_ALPHA_TO_COVERAGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_ALPHA_TO_COVERAGE);
}




Handle<Value> GetGL_SAMPLE_ALPHA_TO_ONE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_ALPHA_TO_ONE);
}




Handle<Value> GetGL_SAMPLE_COVERAGE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_COVERAGE);
}




Handle<Value> GetGL_SAMPLE_BUFFERS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_BUFFERS);
}




Handle<Value> GetGL_SAMPLES(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLES);
}




Handle<Value> GetGL_SAMPLE_COVERAGE_VALUE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_COVERAGE_VALUE);
}




Handle<Value> GetGL_SAMPLE_COVERAGE_INVERT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SAMPLE_COVERAGE_INVERT);
}




Handle<Value> GetGL_MULTISAMPLE_BIT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MULTISAMPLE_BIT);
}




Handle<Value> GetGL_TRANSPOSE_MODELVIEW_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSPOSE_MODELVIEW_MATRIX);
}




Handle<Value> GetGL_TRANSPOSE_PROJECTION_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSPOSE_PROJECTION_MATRIX);
}




Handle<Value> GetGL_TRANSPOSE_TEXTURE_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSPOSE_TEXTURE_MATRIX);
}




Handle<Value> GetGL_TRANSPOSE_COLOR_MATRIX(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TRANSPOSE_COLOR_MATRIX);
}




Handle<Value> GetGL_COMBINE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMBINE);
}




Handle<Value> GetGL_COMBINE_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMBINE_RGB);
}




Handle<Value> GetGL_COMBINE_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_COMBINE_ALPHA);
}




Handle<Value> GetGL_SOURCE0_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE0_RGB);
}




Handle<Value> GetGL_SOURCE1_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE1_RGB);
}




Handle<Value> GetGL_SOURCE2_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE2_RGB);
}




Handle<Value> GetGL_SOURCE0_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE0_ALPHA);
}




Handle<Value> GetGL_SOURCE1_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE1_ALPHA);
}




Handle<Value> GetGL_SOURCE2_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SOURCE2_ALPHA);
}




Handle<Value> GetGL_OPERAND0_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND0_RGB);
}




Handle<Value> GetGL_OPERAND1_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND1_RGB);
}




Handle<Value> GetGL_OPERAND2_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND2_RGB);
}




Handle<Value> GetGL_OPERAND0_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND0_ALPHA);
}




Handle<Value> GetGL_OPERAND1_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND1_ALPHA);
}




Handle<Value> GetGL_OPERAND2_ALPHA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_OPERAND2_ALPHA);
}




Handle<Value> GetGL_RGB_SCALE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_RGB_SCALE);
}




Handle<Value> GetGL_ADD_SIGNED(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ADD_SIGNED);
}




Handle<Value> GetGL_INTERPOLATE(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_INTERPOLATE);
}




Handle<Value> GetGL_SUBTRACT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_SUBTRACT);
}




Handle<Value> GetGL_CONSTANT(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CONSTANT);
}




Handle<Value> GetGL_PRIMARY_COLOR(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PRIMARY_COLOR);
}




Handle<Value> GetGL_PREVIOUS(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_PREVIOUS);
}




Handle<Value> GetGL_DOT3_RGB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOT3_RGB);
}




Handle<Value> GetGL_DOT3_RGBA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DOT3_RGBA);
}




Handle<Value> GetGL_CLAMP_TO_BORDER(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLAMP_TO_BORDER);
}




Handle<Value> GLActiveTextureCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glActiveTexture(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLClientActiveTextureCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glClientActiveTexture(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glMultiTexCoord1d(( GLenum ) arg0, ( GLdouble ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord1dv(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glMultiTexCoord1f(( GLenum ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord1fv(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glMultiTexCoord1i(( GLenum ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord1iv(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glMultiTexCoord1s(( GLenum ) arg0, ( GLshort ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord1sv(( GLenum ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMultiTexCoord2d(( GLenum ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord2dv(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMultiTexCoord2f(( GLenum ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord2fv(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMultiTexCoord2i(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord2iv(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMultiTexCoord2s(( GLenum ) arg0, ( GLshort ) arg1, ( GLshort ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord2sv(( GLenum ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glMultiTexCoord3d(( GLenum ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord3dv(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glMultiTexCoord3f(( GLenum ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord3fv(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glMultiTexCoord3i(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord3iv(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glMultiTexCoord3s(( GLenum ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord3sv(( GLenum ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4dCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();

  //make call
  glMultiTexCoord4d(( GLenum ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3, ( GLdouble ) arg4);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4dvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord4dv(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4fCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();

  //make call
  glMultiTexCoord4f(( GLenum ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3, ( GLfloat ) arg4);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4fvCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord4fv(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4iCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glMultiTexCoord4i(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLint ) arg4);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4ivCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord4iv(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4sCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glMultiTexCoord4s(( GLenum ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3, ( GLshort ) arg4);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4svCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord4sv(( GLenum ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLLoadTransposeMatrixdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glLoadTransposeMatrixd(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLLoadTransposeMatrixfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glLoadTransposeMatrixf(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLMultTransposeMatrixdCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLdouble*   arg0 = new   GLdouble  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glMultTransposeMatrixd(( const GLdouble* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLMultTransposeMatrixfCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments

    

Handle<Array> arrHandle0 = Handle<Array>::Cast(args[0]);
  GLfloat*   arg0 = new   GLfloat  [arrHandle0->Length()];
for (unsigned j = 0; j < arrHandle0->Length(); j++) {
    Handle<Value> arg(arrHandle0->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg0[j] = aux; 
}
    
    
  //make call
  glMultTransposeMatrixf(( const GLfloat* ) arg0);
  return v8::Undefined();
}




Handle<Value> GLSampleCoverageCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  double arg0 = args[0]->NumberValue();
  unsigned int arg1 = args[1]->Uint32Value();

  //make call
  glSampleCoverage(( GLclampf ) arg0, ( GLboolean ) arg1);
  return v8::Undefined();
}




Handle<Value> GetGL_ARB_multitexture(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ARB_multitexture);
}




Handle<Value> GetGL_TEXTURE0_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE0_ARB);
}




Handle<Value> GetGL_TEXTURE1_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE1_ARB);
}




Handle<Value> GetGL_TEXTURE2_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE2_ARB);
}




Handle<Value> GetGL_TEXTURE3_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE3_ARB);
}




Handle<Value> GetGL_TEXTURE4_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE4_ARB);
}




Handle<Value> GetGL_TEXTURE5_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE5_ARB);
}




Handle<Value> GetGL_TEXTURE6_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE6_ARB);
}




Handle<Value> GetGL_TEXTURE7_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE7_ARB);
}




Handle<Value> GetGL_TEXTURE8_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE8_ARB);
}




Handle<Value> GetGL_TEXTURE9_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE9_ARB);
}




Handle<Value> GetGL_TEXTURE10_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE10_ARB);
}




Handle<Value> GetGL_TEXTURE11_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE11_ARB);
}




Handle<Value> GetGL_TEXTURE12_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE12_ARB);
}




Handle<Value> GetGL_TEXTURE13_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE13_ARB);
}




Handle<Value> GetGL_TEXTURE14_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE14_ARB);
}




Handle<Value> GetGL_TEXTURE15_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE15_ARB);
}




Handle<Value> GetGL_TEXTURE16_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE16_ARB);
}




Handle<Value> GetGL_TEXTURE17_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE17_ARB);
}




Handle<Value> GetGL_TEXTURE18_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE18_ARB);
}




Handle<Value> GetGL_TEXTURE19_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE19_ARB);
}




Handle<Value> GetGL_TEXTURE20_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE20_ARB);
}




Handle<Value> GetGL_TEXTURE21_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE21_ARB);
}




Handle<Value> GetGL_TEXTURE22_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE22_ARB);
}




Handle<Value> GetGL_TEXTURE23_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE23_ARB);
}




Handle<Value> GetGL_TEXTURE24_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE24_ARB);
}




Handle<Value> GetGL_TEXTURE25_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE25_ARB);
}




Handle<Value> GetGL_TEXTURE26_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE26_ARB);
}




Handle<Value> GetGL_TEXTURE27_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE27_ARB);
}




Handle<Value> GetGL_TEXTURE28_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE28_ARB);
}




Handle<Value> GetGL_TEXTURE29_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE29_ARB);
}




Handle<Value> GetGL_TEXTURE30_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE30_ARB);
}




Handle<Value> GetGL_TEXTURE31_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_TEXTURE31_ARB);
}




Handle<Value> GetGL_ACTIVE_TEXTURE_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ACTIVE_TEXTURE_ARB);
}




Handle<Value> GetGL_CLIENT_ACTIVE_TEXTURE_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_CLIENT_ACTIVE_TEXTURE_ARB);
}




Handle<Value> GetGL_MAX_TEXTURE_UNITS_ARB(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MAX_TEXTURE_UNITS_ARB);
}




Handle<Value> GLActiveTextureARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glActiveTextureARB(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLClientActiveTextureARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 1) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

  //make call
  glClientActiveTextureARB(( GLenum ) arg0);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1dARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glMultiTexCoord1dARB(( GLenum ) arg0, ( GLdouble ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1dvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord1dvARB(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1fARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();

  //make call
  glMultiTexCoord1fARB(( GLenum ) arg0, ( GLfloat ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1fvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord1fvARB(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1iARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glMultiTexCoord1iARB(( GLenum ) arg0, ( GLint ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1ivARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord1ivARB(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1sARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();

  //make call
  glMultiTexCoord1sARB(( GLenum ) arg0, ( GLshort ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord1svARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord1svARB(( GLenum ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2dARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMultiTexCoord2dARB(( GLenum ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2dvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord2dvARB(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2fARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();

  //make call
  glMultiTexCoord2fARB(( GLenum ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2fvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord2fvARB(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2iARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMultiTexCoord2iARB(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2ivARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord2ivARB(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2sARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 3) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();

  //make call
  glMultiTexCoord2sARB(( GLenum ) arg0, ( GLshort ) arg1, ( GLshort ) arg2);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord2svARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord2svARB(( GLenum ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3dARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glMultiTexCoord3dARB(( GLenum ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3dvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord3dvARB(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3fARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();

  //make call
  glMultiTexCoord3fARB(( GLenum ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3fvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord3fvARB(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3iARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glMultiTexCoord3iARB(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3ivARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord3ivARB(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3sARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 4) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();

  //make call
  glMultiTexCoord3sARB(( GLenum ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord3svARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord3svARB(( GLenum ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4dARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();

  //make call
  glMultiTexCoord4dARB(( GLenum ) arg0, ( GLdouble ) arg1, ( GLdouble ) arg2, ( GLdouble ) arg3, ( GLdouble ) arg4);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4dvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLdouble*   arg1 = new   GLdouble  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLdouble   aux = (  GLdouble  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord4dvARB(( GLenum ) arg0, ( const GLdouble* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4fARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  double arg1 = args[1]->NumberValue();
  double arg2 = args[2]->NumberValue();
  double arg3 = args[3]->NumberValue();
  double arg4 = args[4]->NumberValue();

  //make call
  glMultiTexCoord4fARB(( GLenum ) arg0, ( GLfloat ) arg1, ( GLfloat ) arg2, ( GLfloat ) arg3, ( GLfloat ) arg4);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4fvARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLfloat*   arg1 = new   GLfloat  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLfloat   aux = (  GLfloat  )arg->NumberValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord4fvARB(( GLenum ) arg0, ( const GLfloat* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4iARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glMultiTexCoord4iARB(( GLenum ) arg0, ( GLint ) arg1, ( GLint ) arg2, ( GLint ) arg3, ( GLint ) arg4);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4ivARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLint*   arg1 = new   GLint  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLint   aux = (  GLint  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord4ivARB(( GLenum ) arg0, ( const GLint* ) arg1);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4sARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 5) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();
  int arg1 = args[1]->IntegerValue();
  int arg2 = args[2]->IntegerValue();
  int arg3 = args[3]->IntegerValue();
  int arg4 = args[4]->IntegerValue();

  //make call
  glMultiTexCoord4sARB(( GLenum ) arg0, ( GLshort ) arg1, ( GLshort ) arg2, ( GLshort ) arg3, ( GLshort ) arg4);
  return v8::Undefined();
}




Handle<Value> GLMultiTexCoord4svARBCallback(const Arguments& args) {
  //if less that nbr of formal parameters then do nothing
  if (args.Length() < 2) return v8::Undefined();
  //define handle scope
  HandleScope scope;
  //get arguments
  int arg0 = args[0]->IntegerValue();

    

Handle<Array> arrHandle1 = Handle<Array>::Cast(args[1]);
  GLshort*   arg1 = new   GLshort  [arrHandle1->Length()];
for (unsigned j = 0; j < arrHandle1->Length(); j++) {
    Handle<Value> arg(arrHandle1->Get(Integer::New(j)));
      GLshort   aux = (  GLshort  )arg->IntegerValue();
    arg1[j] = aux; 
}
    
    
  //make call
  glMultiTexCoord4svARB(( GLenum ) arg0, ( const GLshort* ) arg1);
  return v8::Undefined();
}




Handle<Value> GetGL_MESA_shader_debug(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MESA_shader_debug);
}




Handle<Value> GetGL_DEBUG_OBJECT_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEBUG_OBJECT_MESA);
}




Handle<Value> GetGL_DEBUG_PRINT_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEBUG_PRINT_MESA);
}




Handle<Value> GetGL_DEBUG_ASSERT_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEBUG_ASSERT_MESA);
}




Handle<Value> GetGL_MESA_packed_depth_stencil(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MESA_packed_depth_stencil);
}




Handle<Value> GetGL_DEPTH_STENCIL_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_DEPTH_STENCIL_MESA);
}




Handle<Value> GetGL_UNSIGNED_INT_24_8_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_24_8_MESA);
}




Handle<Value> GetGL_UNSIGNED_INT_8_24_REV_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_INT_8_24_REV_MESA);
}




Handle<Value> GetGL_UNSIGNED_SHORT_15_1_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_15_1_MESA);
}




Handle<Value> GetGL_UNSIGNED_SHORT_1_15_REV_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_UNSIGNED_SHORT_1_15_REV_MESA);
}




Handle<Value> GetGL_MESA_program_debug(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_MESA_program_debug);
}




Handle<Value> GetGL_FRAGMENT_PROGRAM_POSITION_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRAGMENT_PROGRAM_POSITION_MESA);
}




Handle<Value> GetGL_FRAGMENT_PROGRAM_CALLBACK_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRAGMENT_PROGRAM_CALLBACK_MESA);
}




Handle<Value> GetGL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA);
}




Handle<Value> GetGL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA);
}




Handle<Value> GetGL_VERTEX_PROGRAM_POSITION_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_PROGRAM_POSITION_MESA);
}




Handle<Value> GetGL_VERTEX_PROGRAM_CALLBACK_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_PROGRAM_CALLBACK_MESA);
}




Handle<Value> GetGL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA);
}




Handle<Value> GetGL_VERTEX_PROGRAM_CALLBACK_DATA_MESA(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_VERTEX_PROGRAM_CALLBACK_DATA_MESA);
}




Handle<Value> GetGL_ATI_blend_equation_separate(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ATI_blend_equation_separate);
}




Handle<Value> GetGL_ALPHA_BLEND_EQUATION_ATI(Local<String> property,
                      const AccessorInfo &info) {
    return Uint32::New(GL_ALPHA_BLEND_EQUATION_ATI);
}



Handle<ObjectTemplate> createGl(void) {
      HandleScope handle_scope;

      Handle<ObjectTemplate> Gl = ObjectTemplate::New();
      Gl->SetInternalFieldCount(1);

     Gl->SetAccessor(String::NewSymbol("VERSION_1_1"), GetGL_VERSION_1_1);

     Gl->SetAccessor(String::NewSymbol("VERSION_1_2"), GetGL_VERSION_1_2);

     Gl->SetAccessor(String::NewSymbol("VERSION_1_3"), GetGL_VERSION_1_3);

     Gl->SetAccessor(String::NewSymbol("ARB_imaging"), GetGL_ARB_imaging);

     Gl->SetAccessor(String::NewSymbol("FALSE"), GetGL_FALSE);

     Gl->SetAccessor(String::NewSymbol("TRUE"), GetGL_TRUE);

     Gl->SetAccessor(String::NewSymbol("BYTE"), GetGL_BYTE);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_BYTE"), GetGL_UNSIGNED_BYTE);

     Gl->SetAccessor(String::NewSymbol("SHORT"), GetGL_SHORT);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT"), GetGL_UNSIGNED_SHORT);

     Gl->SetAccessor(String::NewSymbol("INT"), GetGL_INT);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT"), GetGL_UNSIGNED_INT);

     Gl->SetAccessor(String::NewSymbol("FLOAT"), GetGL_FLOAT);

     Gl->SetAccessor(String::NewSymbol("2_BYTES"), GetGL_2_BYTES);

     Gl->SetAccessor(String::NewSymbol("3_BYTES"), GetGL_3_BYTES);

     Gl->SetAccessor(String::NewSymbol("4_BYTES"), GetGL_4_BYTES);

     Gl->SetAccessor(String::NewSymbol("DOUBLE"), GetGL_DOUBLE);

     Gl->SetAccessor(String::NewSymbol("POINTS"), GetGL_POINTS);

     Gl->SetAccessor(String::NewSymbol("LINES"), GetGL_LINES);

     Gl->SetAccessor(String::NewSymbol("LINE_LOOP"), GetGL_LINE_LOOP);

     Gl->SetAccessor(String::NewSymbol("LINE_STRIP"), GetGL_LINE_STRIP);

     Gl->SetAccessor(String::NewSymbol("TRIANGLES"), GetGL_TRIANGLES);

     Gl->SetAccessor(String::NewSymbol("TRIANGLE_STRIP"), GetGL_TRIANGLE_STRIP);

     Gl->SetAccessor(String::NewSymbol("TRIANGLE_FAN"), GetGL_TRIANGLE_FAN);

     Gl->SetAccessor(String::NewSymbol("QUADS"), GetGL_QUADS);

     Gl->SetAccessor(String::NewSymbol("QUAD_STRIP"), GetGL_QUAD_STRIP);

     Gl->SetAccessor(String::NewSymbol("POLYGON"), GetGL_POLYGON);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY"), GetGL_VERTEX_ARRAY);

     Gl->SetAccessor(String::NewSymbol("NORMAL_ARRAY"), GetGL_NORMAL_ARRAY);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY"), GetGL_COLOR_ARRAY);

     Gl->SetAccessor(String::NewSymbol("INDEX_ARRAY"), GetGL_INDEX_ARRAY);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY"), GetGL_TEXTURE_COORD_ARRAY);

     Gl->SetAccessor(String::NewSymbol("EDGE_FLAG_ARRAY"), GetGL_EDGE_FLAG_ARRAY);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY_SIZE"), GetGL_VERTEX_ARRAY_SIZE);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY_TYPE"), GetGL_VERTEX_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY_STRIDE"), GetGL_VERTEX_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("NORMAL_ARRAY_TYPE"), GetGL_NORMAL_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("NORMAL_ARRAY_STRIDE"), GetGL_NORMAL_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY_SIZE"), GetGL_COLOR_ARRAY_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY_TYPE"), GetGL_COLOR_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY_STRIDE"), GetGL_COLOR_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("INDEX_ARRAY_TYPE"), GetGL_INDEX_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("INDEX_ARRAY_STRIDE"), GetGL_INDEX_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY_SIZE"), GetGL_TEXTURE_COORD_ARRAY_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY_TYPE"), GetGL_TEXTURE_COORD_ARRAY_TYPE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY_STRIDE"), GetGL_TEXTURE_COORD_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("EDGE_FLAG_ARRAY_STRIDE"), GetGL_EDGE_FLAG_ARRAY_STRIDE);

     Gl->SetAccessor(String::NewSymbol("VERTEX_ARRAY_POINTER"), GetGL_VERTEX_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("NORMAL_ARRAY_POINTER"), GetGL_NORMAL_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("COLOR_ARRAY_POINTER"), GetGL_COLOR_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("INDEX_ARRAY_POINTER"), GetGL_INDEX_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COORD_ARRAY_POINTER"), GetGL_TEXTURE_COORD_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("EDGE_FLAG_ARRAY_POINTER"), GetGL_EDGE_FLAG_ARRAY_POINTER);

     Gl->SetAccessor(String::NewSymbol("V2F"), GetGL_V2F);

     Gl->SetAccessor(String::NewSymbol("V3F"), GetGL_V3F);

     Gl->SetAccessor(String::NewSymbol("C4UB_V2F"), GetGL_C4UB_V2F);

     Gl->SetAccessor(String::NewSymbol("C4UB_V3F"), GetGL_C4UB_V3F);

     Gl->SetAccessor(String::NewSymbol("C3F_V3F"), GetGL_C3F_V3F);

     Gl->SetAccessor(String::NewSymbol("N3F_V3F"), GetGL_N3F_V3F);

     Gl->SetAccessor(String::NewSymbol("C4F_N3F_V3F"), GetGL_C4F_N3F_V3F);

     Gl->SetAccessor(String::NewSymbol("T2F_V3F"), GetGL_T2F_V3F);

     Gl->SetAccessor(String::NewSymbol("T4F_V4F"), GetGL_T4F_V4F);

     Gl->SetAccessor(String::NewSymbol("T2F_C4UB_V3F"), GetGL_T2F_C4UB_V3F);

     Gl->SetAccessor(String::NewSymbol("T2F_C3F_V3F"), GetGL_T2F_C3F_V3F);

     Gl->SetAccessor(String::NewSymbol("T2F_N3F_V3F"), GetGL_T2F_N3F_V3F);

     Gl->SetAccessor(String::NewSymbol("T2F_C4F_N3F_V3F"), GetGL_T2F_C4F_N3F_V3F);

     Gl->SetAccessor(String::NewSymbol("T4F_C4F_N3F_V4F"), GetGL_T4F_C4F_N3F_V4F);

     Gl->SetAccessor(String::NewSymbol("MATRIX_MODE"), GetGL_MATRIX_MODE);

     Gl->SetAccessor(String::NewSymbol("MODELVIEW"), GetGL_MODELVIEW);

     Gl->SetAccessor(String::NewSymbol("PROJECTION"), GetGL_PROJECTION);

     Gl->SetAccessor(String::NewSymbol("TEXTURE"), GetGL_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("POINT_SMOOTH"), GetGL_POINT_SMOOTH);

     Gl->SetAccessor(String::NewSymbol("POINT_SIZE"), GetGL_POINT_SIZE);

     Gl->SetAccessor(String::NewSymbol("POINT_SIZE_GRANULARITY"), GetGL_POINT_SIZE_GRANULARITY);

     Gl->SetAccessor(String::NewSymbol("POINT_SIZE_RANGE"), GetGL_POINT_SIZE_RANGE);

     Gl->SetAccessor(String::NewSymbol("LINE_SMOOTH"), GetGL_LINE_SMOOTH);

     Gl->SetAccessor(String::NewSymbol("LINE_STIPPLE"), GetGL_LINE_STIPPLE);

     Gl->SetAccessor(String::NewSymbol("LINE_STIPPLE_PATTERN"), GetGL_LINE_STIPPLE_PATTERN);

     Gl->SetAccessor(String::NewSymbol("LINE_STIPPLE_REPEAT"), GetGL_LINE_STIPPLE_REPEAT);

     Gl->SetAccessor(String::NewSymbol("LINE_WIDTH"), GetGL_LINE_WIDTH);

     Gl->SetAccessor(String::NewSymbol("LINE_WIDTH_GRANULARITY"), GetGL_LINE_WIDTH_GRANULARITY);

     Gl->SetAccessor(String::NewSymbol("LINE_WIDTH_RANGE"), GetGL_LINE_WIDTH_RANGE);

     Gl->SetAccessor(String::NewSymbol("POINT"), GetGL_POINT);

     Gl->SetAccessor(String::NewSymbol("LINE"), GetGL_LINE);

     Gl->SetAccessor(String::NewSymbol("FILL"), GetGL_FILL);

     Gl->SetAccessor(String::NewSymbol("CW"), GetGL_CW);

     Gl->SetAccessor(String::NewSymbol("CCW"), GetGL_CCW);

     Gl->SetAccessor(String::NewSymbol("FRONT"), GetGL_FRONT);

     Gl->SetAccessor(String::NewSymbol("BACK"), GetGL_BACK);

     Gl->SetAccessor(String::NewSymbol("POLYGON_MODE"), GetGL_POLYGON_MODE);

     Gl->SetAccessor(String::NewSymbol("POLYGON_SMOOTH"), GetGL_POLYGON_SMOOTH);

     Gl->SetAccessor(String::NewSymbol("POLYGON_STIPPLE"), GetGL_POLYGON_STIPPLE);

     Gl->SetAccessor(String::NewSymbol("EDGE_FLAG"), GetGL_EDGE_FLAG);

     Gl->SetAccessor(String::NewSymbol("CULL_FACE"), GetGL_CULL_FACE);

     Gl->SetAccessor(String::NewSymbol("CULL_FACE_MODE"), GetGL_CULL_FACE_MODE);

     Gl->SetAccessor(String::NewSymbol("FRONT_FACE"), GetGL_FRONT_FACE);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_FACTOR"), GetGL_POLYGON_OFFSET_FACTOR);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_UNITS"), GetGL_POLYGON_OFFSET_UNITS);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_POINT"), GetGL_POLYGON_OFFSET_POINT);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_LINE"), GetGL_POLYGON_OFFSET_LINE);

     Gl->SetAccessor(String::NewSymbol("POLYGON_OFFSET_FILL"), GetGL_POLYGON_OFFSET_FILL);

     Gl->SetAccessor(String::NewSymbol("COMPILE"), GetGL_COMPILE);

     Gl->SetAccessor(String::NewSymbol("COMPILE_AND_EXECUTE"), GetGL_COMPILE_AND_EXECUTE);

     Gl->SetAccessor(String::NewSymbol("LIST_BASE"), GetGL_LIST_BASE);

     Gl->SetAccessor(String::NewSymbol("LIST_INDEX"), GetGL_LIST_INDEX);

     Gl->SetAccessor(String::NewSymbol("LIST_MODE"), GetGL_LIST_MODE);

     Gl->SetAccessor(String::NewSymbol("NEVER"), GetGL_NEVER);

     Gl->SetAccessor(String::NewSymbol("LESS"), GetGL_LESS);

     Gl->SetAccessor(String::NewSymbol("EQUAL"), GetGL_EQUAL);

     Gl->SetAccessor(String::NewSymbol("LEQUAL"), GetGL_LEQUAL);

     Gl->SetAccessor(String::NewSymbol("GREATER"), GetGL_GREATER);

     Gl->SetAccessor(String::NewSymbol("NOTEQUAL"), GetGL_NOTEQUAL);

     Gl->SetAccessor(String::NewSymbol("GEQUAL"), GetGL_GEQUAL);

     Gl->SetAccessor(String::NewSymbol("ALWAYS"), GetGL_ALWAYS);

     Gl->SetAccessor(String::NewSymbol("DEPTH_TEST"), GetGL_DEPTH_TEST);

     Gl->SetAccessor(String::NewSymbol("DEPTH_BITS"), GetGL_DEPTH_BITS);

     Gl->SetAccessor(String::NewSymbol("DEPTH_CLEAR_VALUE"), GetGL_DEPTH_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("DEPTH_FUNC"), GetGL_DEPTH_FUNC);

     Gl->SetAccessor(String::NewSymbol("DEPTH_RANGE"), GetGL_DEPTH_RANGE);

     Gl->SetAccessor(String::NewSymbol("DEPTH_WRITEMASK"), GetGL_DEPTH_WRITEMASK);

     Gl->SetAccessor(String::NewSymbol("DEPTH_COMPONENT"), GetGL_DEPTH_COMPONENT);

     Gl->SetAccessor(String::NewSymbol("LIGHTING"), GetGL_LIGHTING);

     Gl->SetAccessor(String::NewSymbol("LIGHT0"), GetGL_LIGHT0);

     Gl->SetAccessor(String::NewSymbol("LIGHT1"), GetGL_LIGHT1);

     Gl->SetAccessor(String::NewSymbol("LIGHT2"), GetGL_LIGHT2);

     Gl->SetAccessor(String::NewSymbol("LIGHT3"), GetGL_LIGHT3);

     Gl->SetAccessor(String::NewSymbol("LIGHT4"), GetGL_LIGHT4);

     Gl->SetAccessor(String::NewSymbol("LIGHT5"), GetGL_LIGHT5);

     Gl->SetAccessor(String::NewSymbol("LIGHT6"), GetGL_LIGHT6);

     Gl->SetAccessor(String::NewSymbol("LIGHT7"), GetGL_LIGHT7);

     Gl->SetAccessor(String::NewSymbol("SPOT_EXPONENT"), GetGL_SPOT_EXPONENT);

     Gl->SetAccessor(String::NewSymbol("SPOT_CUTOFF"), GetGL_SPOT_CUTOFF);

     Gl->SetAccessor(String::NewSymbol("CONSTANT_ATTENUATION"), GetGL_CONSTANT_ATTENUATION);

     Gl->SetAccessor(String::NewSymbol("LINEAR_ATTENUATION"), GetGL_LINEAR_ATTENUATION);

     Gl->SetAccessor(String::NewSymbol("QUADRATIC_ATTENUATION"), GetGL_QUADRATIC_ATTENUATION);

     Gl->SetAccessor(String::NewSymbol("AMBIENT"), GetGL_AMBIENT);

     Gl->SetAccessor(String::NewSymbol("DIFFUSE"), GetGL_DIFFUSE);

     Gl->SetAccessor(String::NewSymbol("SPECULAR"), GetGL_SPECULAR);

     Gl->SetAccessor(String::NewSymbol("SHININESS"), GetGL_SHININESS);

     Gl->SetAccessor(String::NewSymbol("EMISSION"), GetGL_EMISSION);

     Gl->SetAccessor(String::NewSymbol("POSITION"), GetGL_POSITION);

     Gl->SetAccessor(String::NewSymbol("SPOT_DIRECTION"), GetGL_SPOT_DIRECTION);

     Gl->SetAccessor(String::NewSymbol("AMBIENT_AND_DIFFUSE"), GetGL_AMBIENT_AND_DIFFUSE);

     Gl->SetAccessor(String::NewSymbol("COLOR_INDEXES"), GetGL_COLOR_INDEXES);

     Gl->SetAccessor(String::NewSymbol("LIGHT_MODEL_TWO_SIDE"), GetGL_LIGHT_MODEL_TWO_SIDE);

     Gl->SetAccessor(String::NewSymbol("LIGHT_MODEL_LOCAL_VIEWER"), GetGL_LIGHT_MODEL_LOCAL_VIEWER);

     Gl->SetAccessor(String::NewSymbol("LIGHT_MODEL_AMBIENT"), GetGL_LIGHT_MODEL_AMBIENT);

     Gl->SetAccessor(String::NewSymbol("FRONT_AND_BACK"), GetGL_FRONT_AND_BACK);

     Gl->SetAccessor(String::NewSymbol("SHADE_MODEL"), GetGL_SHADE_MODEL);

     Gl->SetAccessor(String::NewSymbol("FLAT"), GetGL_FLAT);

     Gl->SetAccessor(String::NewSymbol("SMOOTH"), GetGL_SMOOTH);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATERIAL"), GetGL_COLOR_MATERIAL);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATERIAL_FACE"), GetGL_COLOR_MATERIAL_FACE);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATERIAL_PARAMETER"), GetGL_COLOR_MATERIAL_PARAMETER);

     Gl->SetAccessor(String::NewSymbol("NORMALIZE"), GetGL_NORMALIZE);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE0"), GetGL_CLIP_PLANE0);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE1"), GetGL_CLIP_PLANE1);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE2"), GetGL_CLIP_PLANE2);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE3"), GetGL_CLIP_PLANE3);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE4"), GetGL_CLIP_PLANE4);

     Gl->SetAccessor(String::NewSymbol("CLIP_PLANE5"), GetGL_CLIP_PLANE5);

     Gl->SetAccessor(String::NewSymbol("ACCUM_RED_BITS"), GetGL_ACCUM_RED_BITS);

     Gl->SetAccessor(String::NewSymbol("ACCUM_GREEN_BITS"), GetGL_ACCUM_GREEN_BITS);

     Gl->SetAccessor(String::NewSymbol("ACCUM_BLUE_BITS"), GetGL_ACCUM_BLUE_BITS);

     Gl->SetAccessor(String::NewSymbol("ACCUM_ALPHA_BITS"), GetGL_ACCUM_ALPHA_BITS);

     Gl->SetAccessor(String::NewSymbol("ACCUM_CLEAR_VALUE"), GetGL_ACCUM_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("ACCUM"), GetGL_ACCUM);

     Gl->SetAccessor(String::NewSymbol("ADD"), GetGL_ADD);

     Gl->SetAccessor(String::NewSymbol("LOAD"), GetGL_LOAD);

     Gl->SetAccessor(String::NewSymbol("MULT"), GetGL_MULT);

     Gl->SetAccessor(String::NewSymbol("RETURN"), GetGL_RETURN);

     Gl->SetAccessor(String::NewSymbol("ALPHA_TEST"), GetGL_ALPHA_TEST);

     Gl->SetAccessor(String::NewSymbol("ALPHA_TEST_REF"), GetGL_ALPHA_TEST_REF);

     Gl->SetAccessor(String::NewSymbol("ALPHA_TEST_FUNC"), GetGL_ALPHA_TEST_FUNC);

     Gl->SetAccessor(String::NewSymbol("BLEND"), GetGL_BLEND);

     Gl->SetAccessor(String::NewSymbol("BLEND_SRC"), GetGL_BLEND_SRC);

     Gl->SetAccessor(String::NewSymbol("BLEND_DST"), GetGL_BLEND_DST);

     Gl->SetAccessor(String::NewSymbol("ZERO"), GetGL_ZERO);

     Gl->SetAccessor(String::NewSymbol("ONE"), GetGL_ONE);

     Gl->SetAccessor(String::NewSymbol("SRC_COLOR"), GetGL_SRC_COLOR);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_SRC_COLOR"), GetGL_ONE_MINUS_SRC_COLOR);

     Gl->SetAccessor(String::NewSymbol("SRC_ALPHA"), GetGL_SRC_ALPHA);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_SRC_ALPHA"), GetGL_ONE_MINUS_SRC_ALPHA);

     Gl->SetAccessor(String::NewSymbol("DST_ALPHA"), GetGL_DST_ALPHA);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_DST_ALPHA"), GetGL_ONE_MINUS_DST_ALPHA);

     Gl->SetAccessor(String::NewSymbol("DST_COLOR"), GetGL_DST_COLOR);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_DST_COLOR"), GetGL_ONE_MINUS_DST_COLOR);

     Gl->SetAccessor(String::NewSymbol("SRC_ALPHA_SATURATE"), GetGL_SRC_ALPHA_SATURATE);

     Gl->SetAccessor(String::NewSymbol("FEEDBACK"), GetGL_FEEDBACK);

     Gl->SetAccessor(String::NewSymbol("RENDER"), GetGL_RENDER);

     Gl->SetAccessor(String::NewSymbol("SELECT"), GetGL_SELECT);

     Gl->SetAccessor(String::NewSymbol("2D"), GetGL_2D);

     Gl->SetAccessor(String::NewSymbol("3D"), GetGL_3D);

     Gl->SetAccessor(String::NewSymbol("3D_COLOR"), GetGL_3D_COLOR);

     Gl->SetAccessor(String::NewSymbol("3D_COLOR_TEXTURE"), GetGL_3D_COLOR_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("4D_COLOR_TEXTURE"), GetGL_4D_COLOR_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("POINT_TOKEN"), GetGL_POINT_TOKEN);

     Gl->SetAccessor(String::NewSymbol("LINE_TOKEN"), GetGL_LINE_TOKEN);

     Gl->SetAccessor(String::NewSymbol("LINE_RESET_TOKEN"), GetGL_LINE_RESET_TOKEN);

     Gl->SetAccessor(String::NewSymbol("POLYGON_TOKEN"), GetGL_POLYGON_TOKEN);

     Gl->SetAccessor(String::NewSymbol("BITMAP_TOKEN"), GetGL_BITMAP_TOKEN);

     Gl->SetAccessor(String::NewSymbol("DRAW_PIXEL_TOKEN"), GetGL_DRAW_PIXEL_TOKEN);

     Gl->SetAccessor(String::NewSymbol("COPY_PIXEL_TOKEN"), GetGL_COPY_PIXEL_TOKEN);

     Gl->SetAccessor(String::NewSymbol("PASS_THROUGH_TOKEN"), GetGL_PASS_THROUGH_TOKEN);

     Gl->SetAccessor(String::NewSymbol("FEEDBACK_BUFFER_POINTER"), GetGL_FEEDBACK_BUFFER_POINTER);

     Gl->SetAccessor(String::NewSymbol("FEEDBACK_BUFFER_SIZE"), GetGL_FEEDBACK_BUFFER_SIZE);

     Gl->SetAccessor(String::NewSymbol("FEEDBACK_BUFFER_TYPE"), GetGL_FEEDBACK_BUFFER_TYPE);

     Gl->SetAccessor(String::NewSymbol("SELECTION_BUFFER_POINTER"), GetGL_SELECTION_BUFFER_POINTER);

     Gl->SetAccessor(String::NewSymbol("SELECTION_BUFFER_SIZE"), GetGL_SELECTION_BUFFER_SIZE);

     Gl->SetAccessor(String::NewSymbol("FOG"), GetGL_FOG);

     Gl->SetAccessor(String::NewSymbol("FOG_MODE"), GetGL_FOG_MODE);

     Gl->SetAccessor(String::NewSymbol("FOG_DENSITY"), GetGL_FOG_DENSITY);

     Gl->SetAccessor(String::NewSymbol("FOG_COLOR"), GetGL_FOG_COLOR);

     Gl->SetAccessor(String::NewSymbol("FOG_INDEX"), GetGL_FOG_INDEX);

     Gl->SetAccessor(String::NewSymbol("FOG_START"), GetGL_FOG_START);

     Gl->SetAccessor(String::NewSymbol("FOG_END"), GetGL_FOG_END);

     Gl->SetAccessor(String::NewSymbol("LINEAR"), GetGL_LINEAR);

     Gl->SetAccessor(String::NewSymbol("EXP"), GetGL_EXP);

     Gl->SetAccessor(String::NewSymbol("EXP2"), GetGL_EXP2);

     Gl->SetAccessor(String::NewSymbol("LOGIC_OP"), GetGL_LOGIC_OP);

     Gl->SetAccessor(String::NewSymbol("INDEX_LOGIC_OP"), GetGL_INDEX_LOGIC_OP);

     Gl->SetAccessor(String::NewSymbol("COLOR_LOGIC_OP"), GetGL_COLOR_LOGIC_OP);

     Gl->SetAccessor(String::NewSymbol("LOGIC_OP_MODE"), GetGL_LOGIC_OP_MODE);

     Gl->SetAccessor(String::NewSymbol("CLEAR"), GetGL_CLEAR);

     Gl->SetAccessor(String::NewSymbol("SET"), GetGL_SET);

     Gl->SetAccessor(String::NewSymbol("COPY"), GetGL_COPY);

     Gl->SetAccessor(String::NewSymbol("COPY_INVERTED"), GetGL_COPY_INVERTED);

     Gl->SetAccessor(String::NewSymbol("NOOP"), GetGL_NOOP);

     Gl->SetAccessor(String::NewSymbol("INVERT"), GetGL_INVERT);

     Gl->SetAccessor(String::NewSymbol("AND"), GetGL_AND);

     Gl->SetAccessor(String::NewSymbol("NAND"), GetGL_NAND);

     Gl->SetAccessor(String::NewSymbol("OR"), GetGL_OR);

     Gl->SetAccessor(String::NewSymbol("NOR"), GetGL_NOR);

     Gl->SetAccessor(String::NewSymbol("XOR"), GetGL_XOR);

     Gl->SetAccessor(String::NewSymbol("EQUIV"), GetGL_EQUIV);

     Gl->SetAccessor(String::NewSymbol("AND_REVERSE"), GetGL_AND_REVERSE);

     Gl->SetAccessor(String::NewSymbol("AND_INVERTED"), GetGL_AND_INVERTED);

     Gl->SetAccessor(String::NewSymbol("OR_REVERSE"), GetGL_OR_REVERSE);

     Gl->SetAccessor(String::NewSymbol("OR_INVERTED"), GetGL_OR_INVERTED);

     Gl->SetAccessor(String::NewSymbol("STENCIL_BITS"), GetGL_STENCIL_BITS);

     Gl->SetAccessor(String::NewSymbol("STENCIL_TEST"), GetGL_STENCIL_TEST);

     Gl->SetAccessor(String::NewSymbol("STENCIL_CLEAR_VALUE"), GetGL_STENCIL_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("STENCIL_FUNC"), GetGL_STENCIL_FUNC);

     Gl->SetAccessor(String::NewSymbol("STENCIL_VALUE_MASK"), GetGL_STENCIL_VALUE_MASK);

     Gl->SetAccessor(String::NewSymbol("STENCIL_FAIL"), GetGL_STENCIL_FAIL);

     Gl->SetAccessor(String::NewSymbol("STENCIL_PASS_DEPTH_FAIL"), GetGL_STENCIL_PASS_DEPTH_FAIL);

     Gl->SetAccessor(String::NewSymbol("STENCIL_PASS_DEPTH_PASS"), GetGL_STENCIL_PASS_DEPTH_PASS);

     Gl->SetAccessor(String::NewSymbol("STENCIL_REF"), GetGL_STENCIL_REF);

     Gl->SetAccessor(String::NewSymbol("STENCIL_WRITEMASK"), GetGL_STENCIL_WRITEMASK);

     Gl->SetAccessor(String::NewSymbol("STENCIL_INDEX"), GetGL_STENCIL_INDEX);

     Gl->SetAccessor(String::NewSymbol("KEEP"), GetGL_KEEP);

     Gl->SetAccessor(String::NewSymbol("REPLACE"), GetGL_REPLACE);

     Gl->SetAccessor(String::NewSymbol("INCR"), GetGL_INCR);

     Gl->SetAccessor(String::NewSymbol("DECR"), GetGL_DECR);

     Gl->SetAccessor(String::NewSymbol("NONE"), GetGL_NONE);

     Gl->SetAccessor(String::NewSymbol("LEFT"), GetGL_LEFT);

     Gl->SetAccessor(String::NewSymbol("RIGHT"), GetGL_RIGHT);

     Gl->SetAccessor(String::NewSymbol("FRONT_LEFT"), GetGL_FRONT_LEFT);

     Gl->SetAccessor(String::NewSymbol("FRONT_RIGHT"), GetGL_FRONT_RIGHT);

     Gl->SetAccessor(String::NewSymbol("BACK_LEFT"), GetGL_BACK_LEFT);

     Gl->SetAccessor(String::NewSymbol("BACK_RIGHT"), GetGL_BACK_RIGHT);

     Gl->SetAccessor(String::NewSymbol("AUX0"), GetGL_AUX0);

     Gl->SetAccessor(String::NewSymbol("AUX1"), GetGL_AUX1);

     Gl->SetAccessor(String::NewSymbol("AUX2"), GetGL_AUX2);

     Gl->SetAccessor(String::NewSymbol("AUX3"), GetGL_AUX3);

     Gl->SetAccessor(String::NewSymbol("COLOR_INDEX"), GetGL_COLOR_INDEX);

     Gl->SetAccessor(String::NewSymbol("RED"), GetGL_RED);

     Gl->SetAccessor(String::NewSymbol("GREEN"), GetGL_GREEN);

     Gl->SetAccessor(String::NewSymbol("BLUE"), GetGL_BLUE);

     Gl->SetAccessor(String::NewSymbol("ALPHA"), GetGL_ALPHA);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE"), GetGL_LUMINANCE);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE_ALPHA"), GetGL_LUMINANCE_ALPHA);

     Gl->SetAccessor(String::NewSymbol("ALPHA_BITS"), GetGL_ALPHA_BITS);

     Gl->SetAccessor(String::NewSymbol("RED_BITS"), GetGL_RED_BITS);

     Gl->SetAccessor(String::NewSymbol("GREEN_BITS"), GetGL_GREEN_BITS);

     Gl->SetAccessor(String::NewSymbol("BLUE_BITS"), GetGL_BLUE_BITS);

     Gl->SetAccessor(String::NewSymbol("INDEX_BITS"), GetGL_INDEX_BITS);

     Gl->SetAccessor(String::NewSymbol("SUBPIXEL_BITS"), GetGL_SUBPIXEL_BITS);

     Gl->SetAccessor(String::NewSymbol("AUX_BUFFERS"), GetGL_AUX_BUFFERS);

     Gl->SetAccessor(String::NewSymbol("READ_BUFFER"), GetGL_READ_BUFFER);

     Gl->SetAccessor(String::NewSymbol("DRAW_BUFFER"), GetGL_DRAW_BUFFER);

     Gl->SetAccessor(String::NewSymbol("DOUBLEBUFFER"), GetGL_DOUBLEBUFFER);

     Gl->SetAccessor(String::NewSymbol("STEREO"), GetGL_STEREO);

     Gl->SetAccessor(String::NewSymbol("BITMAP"), GetGL_BITMAP);

     Gl->SetAccessor(String::NewSymbol("COLOR"), GetGL_COLOR);

     Gl->SetAccessor(String::NewSymbol("DEPTH"), GetGL_DEPTH);

     Gl->SetAccessor(String::NewSymbol("STENCIL"), GetGL_STENCIL);

     Gl->SetAccessor(String::NewSymbol("DITHER"), GetGL_DITHER);

     Gl->SetAccessor(String::NewSymbol("RGB"), GetGL_RGB);

     Gl->SetAccessor(String::NewSymbol("RGBA"), GetGL_RGBA);

     Gl->SetAccessor(String::NewSymbol("MAX_LIST_NESTING"), GetGL_MAX_LIST_NESTING);

     Gl->SetAccessor(String::NewSymbol("MAX_EVAL_ORDER"), GetGL_MAX_EVAL_ORDER);

     Gl->SetAccessor(String::NewSymbol("MAX_LIGHTS"), GetGL_MAX_LIGHTS);

     Gl->SetAccessor(String::NewSymbol("MAX_CLIP_PLANES"), GetGL_MAX_CLIP_PLANES);

     Gl->SetAccessor(String::NewSymbol("MAX_TEXTURE_SIZE"), GetGL_MAX_TEXTURE_SIZE);

     Gl->SetAccessor(String::NewSymbol("MAX_PIXEL_MAP_TABLE"), GetGL_MAX_PIXEL_MAP_TABLE);

     Gl->SetAccessor(String::NewSymbol("MAX_ATTRIB_STACK_DEPTH"), GetGL_MAX_ATTRIB_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_MODELVIEW_STACK_DEPTH"), GetGL_MAX_MODELVIEW_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_NAME_STACK_DEPTH"), GetGL_MAX_NAME_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_PROJECTION_STACK_DEPTH"), GetGL_MAX_PROJECTION_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_TEXTURE_STACK_DEPTH"), GetGL_MAX_TEXTURE_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_VIEWPORT_DIMS"), GetGL_MAX_VIEWPORT_DIMS);

     Gl->SetAccessor(String::NewSymbol("MAX_CLIENT_ATTRIB_STACK_DEPTH"), GetGL_MAX_CLIENT_ATTRIB_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("ATTRIB_STACK_DEPTH"), GetGL_ATTRIB_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("CLIENT_ATTRIB_STACK_DEPTH"), GetGL_CLIENT_ATTRIB_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("COLOR_CLEAR_VALUE"), GetGL_COLOR_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("COLOR_WRITEMASK"), GetGL_COLOR_WRITEMASK);

     Gl->SetAccessor(String::NewSymbol("CURRENT_INDEX"), GetGL_CURRENT_INDEX);

     Gl->SetAccessor(String::NewSymbol("CURRENT_COLOR"), GetGL_CURRENT_COLOR);

     Gl->SetAccessor(String::NewSymbol("CURRENT_NORMAL"), GetGL_CURRENT_NORMAL);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_COLOR"), GetGL_CURRENT_RASTER_COLOR);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_DISTANCE"), GetGL_CURRENT_RASTER_DISTANCE);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_INDEX"), GetGL_CURRENT_RASTER_INDEX);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_POSITION"), GetGL_CURRENT_RASTER_POSITION);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_TEXTURE_COORDS"), GetGL_CURRENT_RASTER_TEXTURE_COORDS);

     Gl->SetAccessor(String::NewSymbol("CURRENT_RASTER_POSITION_VALID"), GetGL_CURRENT_RASTER_POSITION_VALID);

     Gl->SetAccessor(String::NewSymbol("CURRENT_TEXTURE_COORDS"), GetGL_CURRENT_TEXTURE_COORDS);

     Gl->SetAccessor(String::NewSymbol("INDEX_CLEAR_VALUE"), GetGL_INDEX_CLEAR_VALUE);

     Gl->SetAccessor(String::NewSymbol("INDEX_MODE"), GetGL_INDEX_MODE);

     Gl->SetAccessor(String::NewSymbol("INDEX_WRITEMASK"), GetGL_INDEX_WRITEMASK);

     Gl->SetAccessor(String::NewSymbol("MODELVIEW_MATRIX"), GetGL_MODELVIEW_MATRIX);

     Gl->SetAccessor(String::NewSymbol("MODELVIEW_STACK_DEPTH"), GetGL_MODELVIEW_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("NAME_STACK_DEPTH"), GetGL_NAME_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("PROJECTION_MATRIX"), GetGL_PROJECTION_MATRIX);

     Gl->SetAccessor(String::NewSymbol("PROJECTION_STACK_DEPTH"), GetGL_PROJECTION_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("RENDER_MODE"), GetGL_RENDER_MODE);

     Gl->SetAccessor(String::NewSymbol("RGBA_MODE"), GetGL_RGBA_MODE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MATRIX"), GetGL_TEXTURE_MATRIX);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_STACK_DEPTH"), GetGL_TEXTURE_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("VIEWPORT"), GetGL_VIEWPORT);

     Gl->SetAccessor(String::NewSymbol("AUTO_NORMAL"), GetGL_AUTO_NORMAL);

     Gl->SetAccessor(String::NewSymbol("MAP1_COLOR_4"), GetGL_MAP1_COLOR_4);

     Gl->SetAccessor(String::NewSymbol("MAP1_INDEX"), GetGL_MAP1_INDEX);

     Gl->SetAccessor(String::NewSymbol("MAP1_NORMAL"), GetGL_MAP1_NORMAL);

     Gl->SetAccessor(String::NewSymbol("MAP1_TEXTURE_COORD_1"), GetGL_MAP1_TEXTURE_COORD_1);

     Gl->SetAccessor(String::NewSymbol("MAP1_TEXTURE_COORD_2"), GetGL_MAP1_TEXTURE_COORD_2);

     Gl->SetAccessor(String::NewSymbol("MAP1_TEXTURE_COORD_3"), GetGL_MAP1_TEXTURE_COORD_3);

     Gl->SetAccessor(String::NewSymbol("MAP1_TEXTURE_COORD_4"), GetGL_MAP1_TEXTURE_COORD_4);

     Gl->SetAccessor(String::NewSymbol("MAP1_VERTEX_3"), GetGL_MAP1_VERTEX_3);

     Gl->SetAccessor(String::NewSymbol("MAP1_VERTEX_4"), GetGL_MAP1_VERTEX_4);

     Gl->SetAccessor(String::NewSymbol("MAP2_COLOR_4"), GetGL_MAP2_COLOR_4);

     Gl->SetAccessor(String::NewSymbol("MAP2_INDEX"), GetGL_MAP2_INDEX);

     Gl->SetAccessor(String::NewSymbol("MAP2_NORMAL"), GetGL_MAP2_NORMAL);

     Gl->SetAccessor(String::NewSymbol("MAP2_TEXTURE_COORD_1"), GetGL_MAP2_TEXTURE_COORD_1);

     Gl->SetAccessor(String::NewSymbol("MAP2_TEXTURE_COORD_2"), GetGL_MAP2_TEXTURE_COORD_2);

     Gl->SetAccessor(String::NewSymbol("MAP2_TEXTURE_COORD_3"), GetGL_MAP2_TEXTURE_COORD_3);

     Gl->SetAccessor(String::NewSymbol("MAP2_TEXTURE_COORD_4"), GetGL_MAP2_TEXTURE_COORD_4);

     Gl->SetAccessor(String::NewSymbol("MAP2_VERTEX_3"), GetGL_MAP2_VERTEX_3);

     Gl->SetAccessor(String::NewSymbol("MAP2_VERTEX_4"), GetGL_MAP2_VERTEX_4);

     Gl->SetAccessor(String::NewSymbol("MAP1_GRID_DOMAIN"), GetGL_MAP1_GRID_DOMAIN);

     Gl->SetAccessor(String::NewSymbol("MAP1_GRID_SEGMENTS"), GetGL_MAP1_GRID_SEGMENTS);

     Gl->SetAccessor(String::NewSymbol("MAP2_GRID_DOMAIN"), GetGL_MAP2_GRID_DOMAIN);

     Gl->SetAccessor(String::NewSymbol("MAP2_GRID_SEGMENTS"), GetGL_MAP2_GRID_SEGMENTS);

     Gl->SetAccessor(String::NewSymbol("COEFF"), GetGL_COEFF);

     Gl->SetAccessor(String::NewSymbol("ORDER"), GetGL_ORDER);

     Gl->SetAccessor(String::NewSymbol("DOMAIN"), GetGL_DOMAIN);

     Gl->SetAccessor(String::NewSymbol("PERSPECTIVE_CORRECTION_HINT"), GetGL_PERSPECTIVE_CORRECTION_HINT);

     Gl->SetAccessor(String::NewSymbol("POINT_SMOOTH_HINT"), GetGL_POINT_SMOOTH_HINT);

     Gl->SetAccessor(String::NewSymbol("LINE_SMOOTH_HINT"), GetGL_LINE_SMOOTH_HINT);

     Gl->SetAccessor(String::NewSymbol("POLYGON_SMOOTH_HINT"), GetGL_POLYGON_SMOOTH_HINT);

     Gl->SetAccessor(String::NewSymbol("FOG_HINT"), GetGL_FOG_HINT);

     Gl->SetAccessor(String::NewSymbol("DONT_CARE"), GetGL_DONT_CARE);

     Gl->SetAccessor(String::NewSymbol("FASTEST"), GetGL_FASTEST);

     Gl->SetAccessor(String::NewSymbol("NICEST"), GetGL_NICEST);

     Gl->SetAccessor(String::NewSymbol("SCISSOR_BOX"), GetGL_SCISSOR_BOX);

     Gl->SetAccessor(String::NewSymbol("SCISSOR_TEST"), GetGL_SCISSOR_TEST);

     Gl->SetAccessor(String::NewSymbol("MAP_COLOR"), GetGL_MAP_COLOR);

     Gl->SetAccessor(String::NewSymbol("MAP_STENCIL"), GetGL_MAP_STENCIL);

     Gl->SetAccessor(String::NewSymbol("INDEX_SHIFT"), GetGL_INDEX_SHIFT);

     Gl->SetAccessor(String::NewSymbol("INDEX_OFFSET"), GetGL_INDEX_OFFSET);

     Gl->SetAccessor(String::NewSymbol("RED_SCALE"), GetGL_RED_SCALE);

     Gl->SetAccessor(String::NewSymbol("RED_BIAS"), GetGL_RED_BIAS);

     Gl->SetAccessor(String::NewSymbol("GREEN_SCALE"), GetGL_GREEN_SCALE);

     Gl->SetAccessor(String::NewSymbol("GREEN_BIAS"), GetGL_GREEN_BIAS);

     Gl->SetAccessor(String::NewSymbol("BLUE_SCALE"), GetGL_BLUE_SCALE);

     Gl->SetAccessor(String::NewSymbol("BLUE_BIAS"), GetGL_BLUE_BIAS);

     Gl->SetAccessor(String::NewSymbol("ALPHA_SCALE"), GetGL_ALPHA_SCALE);

     Gl->SetAccessor(String::NewSymbol("ALPHA_BIAS"), GetGL_ALPHA_BIAS);

     Gl->SetAccessor(String::NewSymbol("DEPTH_SCALE"), GetGL_DEPTH_SCALE);

     Gl->SetAccessor(String::NewSymbol("DEPTH_BIAS"), GetGL_DEPTH_BIAS);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_S_TO_S_SIZE"), GetGL_PIXEL_MAP_S_TO_S_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_I_SIZE"), GetGL_PIXEL_MAP_I_TO_I_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_R_SIZE"), GetGL_PIXEL_MAP_I_TO_R_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_G_SIZE"), GetGL_PIXEL_MAP_I_TO_G_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_B_SIZE"), GetGL_PIXEL_MAP_I_TO_B_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_A_SIZE"), GetGL_PIXEL_MAP_I_TO_A_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_R_TO_R_SIZE"), GetGL_PIXEL_MAP_R_TO_R_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_G_TO_G_SIZE"), GetGL_PIXEL_MAP_G_TO_G_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_B_TO_B_SIZE"), GetGL_PIXEL_MAP_B_TO_B_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_A_TO_A_SIZE"), GetGL_PIXEL_MAP_A_TO_A_SIZE);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_S_TO_S"), GetGL_PIXEL_MAP_S_TO_S);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_I"), GetGL_PIXEL_MAP_I_TO_I);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_R"), GetGL_PIXEL_MAP_I_TO_R);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_G"), GetGL_PIXEL_MAP_I_TO_G);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_B"), GetGL_PIXEL_MAP_I_TO_B);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_I_TO_A"), GetGL_PIXEL_MAP_I_TO_A);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_R_TO_R"), GetGL_PIXEL_MAP_R_TO_R);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_G_TO_G"), GetGL_PIXEL_MAP_G_TO_G);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_B_TO_B"), GetGL_PIXEL_MAP_B_TO_B);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MAP_A_TO_A"), GetGL_PIXEL_MAP_A_TO_A);

     Gl->SetAccessor(String::NewSymbol("PACK_ALIGNMENT"), GetGL_PACK_ALIGNMENT);

     Gl->SetAccessor(String::NewSymbol("PACK_LSB_FIRST"), GetGL_PACK_LSB_FIRST);

     Gl->SetAccessor(String::NewSymbol("PACK_ROW_LENGTH"), GetGL_PACK_ROW_LENGTH);

     Gl->SetAccessor(String::NewSymbol("PACK_SKIP_PIXELS"), GetGL_PACK_SKIP_PIXELS);

     Gl->SetAccessor(String::NewSymbol("PACK_SKIP_ROWS"), GetGL_PACK_SKIP_ROWS);

     Gl->SetAccessor(String::NewSymbol("PACK_SWAP_BYTES"), GetGL_PACK_SWAP_BYTES);

     Gl->SetAccessor(String::NewSymbol("UNPACK_ALIGNMENT"), GetGL_UNPACK_ALIGNMENT);

     Gl->SetAccessor(String::NewSymbol("UNPACK_LSB_FIRST"), GetGL_UNPACK_LSB_FIRST);

     Gl->SetAccessor(String::NewSymbol("UNPACK_ROW_LENGTH"), GetGL_UNPACK_ROW_LENGTH);

     Gl->SetAccessor(String::NewSymbol("UNPACK_SKIP_PIXELS"), GetGL_UNPACK_SKIP_PIXELS);

     Gl->SetAccessor(String::NewSymbol("UNPACK_SKIP_ROWS"), GetGL_UNPACK_SKIP_ROWS);

     Gl->SetAccessor(String::NewSymbol("UNPACK_SWAP_BYTES"), GetGL_UNPACK_SWAP_BYTES);

     Gl->SetAccessor(String::NewSymbol("ZOOM_X"), GetGL_ZOOM_X);

     Gl->SetAccessor(String::NewSymbol("ZOOM_Y"), GetGL_ZOOM_Y);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_ENV"), GetGL_TEXTURE_ENV);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_ENV_MODE"), GetGL_TEXTURE_ENV_MODE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_1D"), GetGL_TEXTURE_1D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_2D"), GetGL_TEXTURE_2D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_WRAP_S"), GetGL_TEXTURE_WRAP_S);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_WRAP_T"), GetGL_TEXTURE_WRAP_T);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MAG_FILTER"), GetGL_TEXTURE_MAG_FILTER);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MIN_FILTER"), GetGL_TEXTURE_MIN_FILTER);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_ENV_COLOR"), GetGL_TEXTURE_ENV_COLOR);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_S"), GetGL_TEXTURE_GEN_S);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_T"), GetGL_TEXTURE_GEN_T);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_MODE"), GetGL_TEXTURE_GEN_MODE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BORDER_COLOR"), GetGL_TEXTURE_BORDER_COLOR);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_WIDTH"), GetGL_TEXTURE_WIDTH);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_HEIGHT"), GetGL_TEXTURE_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BORDER"), GetGL_TEXTURE_BORDER);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COMPONENTS"), GetGL_TEXTURE_COMPONENTS);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_RED_SIZE"), GetGL_TEXTURE_RED_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GREEN_SIZE"), GetGL_TEXTURE_GREEN_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BLUE_SIZE"), GetGL_TEXTURE_BLUE_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_ALPHA_SIZE"), GetGL_TEXTURE_ALPHA_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_LUMINANCE_SIZE"), GetGL_TEXTURE_LUMINANCE_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_INTENSITY_SIZE"), GetGL_TEXTURE_INTENSITY_SIZE);

     Gl->SetAccessor(String::NewSymbol("NEAREST_MIPMAP_NEAREST"), GetGL_NEAREST_MIPMAP_NEAREST);

     Gl->SetAccessor(String::NewSymbol("NEAREST_MIPMAP_LINEAR"), GetGL_NEAREST_MIPMAP_LINEAR);

     Gl->SetAccessor(String::NewSymbol("LINEAR_MIPMAP_NEAREST"), GetGL_LINEAR_MIPMAP_NEAREST);

     Gl->SetAccessor(String::NewSymbol("LINEAR_MIPMAP_LINEAR"), GetGL_LINEAR_MIPMAP_LINEAR);

     Gl->SetAccessor(String::NewSymbol("OBJECT_LINEAR"), GetGL_OBJECT_LINEAR);

     Gl->SetAccessor(String::NewSymbol("OBJECT_PLANE"), GetGL_OBJECT_PLANE);

     Gl->SetAccessor(String::NewSymbol("EYE_LINEAR"), GetGL_EYE_LINEAR);

     Gl->SetAccessor(String::NewSymbol("EYE_PLANE"), GetGL_EYE_PLANE);

     Gl->SetAccessor(String::NewSymbol("SPHERE_MAP"), GetGL_SPHERE_MAP);

     Gl->SetAccessor(String::NewSymbol("DECAL"), GetGL_DECAL);

     Gl->SetAccessor(String::NewSymbol("MODULATE"), GetGL_MODULATE);

     Gl->SetAccessor(String::NewSymbol("NEAREST"), GetGL_NEAREST);

     Gl->SetAccessor(String::NewSymbol("REPEAT"), GetGL_REPEAT);

     Gl->SetAccessor(String::NewSymbol("CLAMP"), GetGL_CLAMP);

     Gl->SetAccessor(String::NewSymbol("S"), GetGL_S);

     Gl->SetAccessor(String::NewSymbol("T"), GetGL_T);

     Gl->SetAccessor(String::NewSymbol("R"), GetGL_R);

     Gl->SetAccessor(String::NewSymbol("Q"), GetGL_Q);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_R"), GetGL_TEXTURE_GEN_R);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_GEN_Q"), GetGL_TEXTURE_GEN_Q);

     Gl->SetAccessor(String::NewSymbol("VENDOR"), GetGL_VENDOR);

     Gl->SetAccessor(String::NewSymbol("RENDERER"), GetGL_RENDERER);

     Gl->SetAccessor(String::NewSymbol("VERSION"), GetGL_VERSION);

     Gl->SetAccessor(String::NewSymbol("EXTENSIONS"), GetGL_EXTENSIONS);

     Gl->SetAccessor(String::NewSymbol("NO_ERROR"), GetGL_NO_ERROR);

     Gl->SetAccessor(String::NewSymbol("INVALID_ENUM"), GetGL_INVALID_ENUM);

     Gl->SetAccessor(String::NewSymbol("INVALID_VALUE"), GetGL_INVALID_VALUE);

     Gl->SetAccessor(String::NewSymbol("INVALID_OPERATION"), GetGL_INVALID_OPERATION);

     Gl->SetAccessor(String::NewSymbol("STACK_OVERFLOW"), GetGL_STACK_OVERFLOW);

     Gl->SetAccessor(String::NewSymbol("STACK_UNDERFLOW"), GetGL_STACK_UNDERFLOW);

     Gl->SetAccessor(String::NewSymbol("OUT_OF_MEMORY"), GetGL_OUT_OF_MEMORY);

     Gl->SetAccessor(String::NewSymbol("CURRENT_BIT"), GetGL_CURRENT_BIT);

     Gl->SetAccessor(String::NewSymbol("POINT_BIT"), GetGL_POINT_BIT);

     Gl->SetAccessor(String::NewSymbol("LINE_BIT"), GetGL_LINE_BIT);

     Gl->SetAccessor(String::NewSymbol("POLYGON_BIT"), GetGL_POLYGON_BIT);

     Gl->SetAccessor(String::NewSymbol("POLYGON_STIPPLE_BIT"), GetGL_POLYGON_STIPPLE_BIT);

     Gl->SetAccessor(String::NewSymbol("PIXEL_MODE_BIT"), GetGL_PIXEL_MODE_BIT);

     Gl->SetAccessor(String::NewSymbol("LIGHTING_BIT"), GetGL_LIGHTING_BIT);

     Gl->SetAccessor(String::NewSymbol("FOG_BIT"), GetGL_FOG_BIT);

     Gl->SetAccessor(String::NewSymbol("DEPTH_BUFFER_BIT"), GetGL_DEPTH_BUFFER_BIT);

     Gl->SetAccessor(String::NewSymbol("ACCUM_BUFFER_BIT"), GetGL_ACCUM_BUFFER_BIT);

     Gl->SetAccessor(String::NewSymbol("STENCIL_BUFFER_BIT"), GetGL_STENCIL_BUFFER_BIT);

     Gl->SetAccessor(String::NewSymbol("VIEWPORT_BIT"), GetGL_VIEWPORT_BIT);

     Gl->SetAccessor(String::NewSymbol("TRANSFORM_BIT"), GetGL_TRANSFORM_BIT);

     Gl->SetAccessor(String::NewSymbol("ENABLE_BIT"), GetGL_ENABLE_BIT);

     Gl->SetAccessor(String::NewSymbol("COLOR_BUFFER_BIT"), GetGL_COLOR_BUFFER_BIT);

     Gl->SetAccessor(String::NewSymbol("HINT_BIT"), GetGL_HINT_BIT);

     Gl->SetAccessor(String::NewSymbol("EVAL_BIT"), GetGL_EVAL_BIT);

     Gl->SetAccessor(String::NewSymbol("LIST_BIT"), GetGL_LIST_BIT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BIT"), GetGL_TEXTURE_BIT);

     Gl->SetAccessor(String::NewSymbol("SCISSOR_BIT"), GetGL_SCISSOR_BIT);

     Gl->SetAccessor(String::NewSymbol("ALL_ATTRIB_BITS"), GetGL_ALL_ATTRIB_BITS);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_1D"), GetGL_PROXY_TEXTURE_1D);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_2D"), GetGL_PROXY_TEXTURE_2D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_PRIORITY"), GetGL_TEXTURE_PRIORITY);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_RESIDENT"), GetGL_TEXTURE_RESIDENT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_1D"), GetGL_TEXTURE_BINDING_1D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_2D"), GetGL_TEXTURE_BINDING_2D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_INTERNAL_FORMAT"), GetGL_TEXTURE_INTERNAL_FORMAT);

     Gl->SetAccessor(String::NewSymbol("ALPHA4"), GetGL_ALPHA4);

     Gl->SetAccessor(String::NewSymbol("ALPHA8"), GetGL_ALPHA8);

     Gl->SetAccessor(String::NewSymbol("ALPHA12"), GetGL_ALPHA12);

     Gl->SetAccessor(String::NewSymbol("ALPHA16"), GetGL_ALPHA16);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE4"), GetGL_LUMINANCE4);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE8"), GetGL_LUMINANCE8);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE12"), GetGL_LUMINANCE12);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE16"), GetGL_LUMINANCE16);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE4_ALPHA4"), GetGL_LUMINANCE4_ALPHA4);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE6_ALPHA2"), GetGL_LUMINANCE6_ALPHA2);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE8_ALPHA8"), GetGL_LUMINANCE8_ALPHA8);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE12_ALPHA4"), GetGL_LUMINANCE12_ALPHA4);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE12_ALPHA12"), GetGL_LUMINANCE12_ALPHA12);

     Gl->SetAccessor(String::NewSymbol("LUMINANCE16_ALPHA16"), GetGL_LUMINANCE16_ALPHA16);

     Gl->SetAccessor(String::NewSymbol("INTENSITY"), GetGL_INTENSITY);

     Gl->SetAccessor(String::NewSymbol("INTENSITY4"), GetGL_INTENSITY4);

     Gl->SetAccessor(String::NewSymbol("INTENSITY8"), GetGL_INTENSITY8);

     Gl->SetAccessor(String::NewSymbol("INTENSITY12"), GetGL_INTENSITY12);

     Gl->SetAccessor(String::NewSymbol("INTENSITY16"), GetGL_INTENSITY16);

     Gl->SetAccessor(String::NewSymbol("R3_G3_B2"), GetGL_R3_G3_B2);

     Gl->SetAccessor(String::NewSymbol("RGB4"), GetGL_RGB4);

     Gl->SetAccessor(String::NewSymbol("RGB5"), GetGL_RGB5);

     Gl->SetAccessor(String::NewSymbol("RGB8"), GetGL_RGB8);

     Gl->SetAccessor(String::NewSymbol("RGB10"), GetGL_RGB10);

     Gl->SetAccessor(String::NewSymbol("RGB12"), GetGL_RGB12);

     Gl->SetAccessor(String::NewSymbol("RGB16"), GetGL_RGB16);

     Gl->SetAccessor(String::NewSymbol("RGBA2"), GetGL_RGBA2);

     Gl->SetAccessor(String::NewSymbol("RGBA4"), GetGL_RGBA4);

     Gl->SetAccessor(String::NewSymbol("RGB5_A1"), GetGL_RGB5_A1);

     Gl->SetAccessor(String::NewSymbol("RGBA8"), GetGL_RGBA8);

     Gl->SetAccessor(String::NewSymbol("RGB10_A2"), GetGL_RGB10_A2);

     Gl->SetAccessor(String::NewSymbol("RGBA12"), GetGL_RGBA12);

     Gl->SetAccessor(String::NewSymbol("RGBA16"), GetGL_RGBA16);

     Gl->SetAccessor(String::NewSymbol("CLIENT_PIXEL_STORE_BIT"), GetGL_CLIENT_PIXEL_STORE_BIT);

     Gl->SetAccessor(String::NewSymbol("CLIENT_VERTEX_ARRAY_BIT"), GetGL_CLIENT_VERTEX_ARRAY_BIT);

     Gl->SetAccessor(String::NewSymbol("ALL_CLIENT_ATTRIB_BITS"), GetGL_ALL_CLIENT_ATTRIB_BITS);

     Gl->SetAccessor(String::NewSymbol("CLIENT_ALL_ATTRIB_BITS"), GetGL_CLIENT_ALL_ATTRIB_BITS);

     Gl->SetAccessor(String::NewSymbol("RESCALE_NORMAL"), GetGL_RESCALE_NORMAL);

     Gl->SetAccessor(String::NewSymbol("CLAMP_TO_EDGE"), GetGL_CLAMP_TO_EDGE);

     Gl->SetAccessor(String::NewSymbol("MAX_ELEMENTS_VERTICES"), GetGL_MAX_ELEMENTS_VERTICES);

     Gl->SetAccessor(String::NewSymbol("MAX_ELEMENTS_INDICES"), GetGL_MAX_ELEMENTS_INDICES);

     Gl->SetAccessor(String::NewSymbol("BGR"), GetGL_BGR);

     Gl->SetAccessor(String::NewSymbol("BGRA"), GetGL_BGRA);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_BYTE_3_3_2"), GetGL_UNSIGNED_BYTE_3_3_2);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_BYTE_2_3_3_REV"), GetGL_UNSIGNED_BYTE_2_3_3_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_5_6_5"), GetGL_UNSIGNED_SHORT_5_6_5);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_5_6_5_REV"), GetGL_UNSIGNED_SHORT_5_6_5_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_4_4_4_4"), GetGL_UNSIGNED_SHORT_4_4_4_4);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_4_4_4_4_REV"), GetGL_UNSIGNED_SHORT_4_4_4_4_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_5_5_5_1"), GetGL_UNSIGNED_SHORT_5_5_5_1);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_1_5_5_5_REV"), GetGL_UNSIGNED_SHORT_1_5_5_5_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_8_8_8_8"), GetGL_UNSIGNED_INT_8_8_8_8);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_8_8_8_8_REV"), GetGL_UNSIGNED_INT_8_8_8_8_REV);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_10_10_10_2"), GetGL_UNSIGNED_INT_10_10_10_2);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_2_10_10_10_REV"), GetGL_UNSIGNED_INT_2_10_10_10_REV);

     Gl->SetAccessor(String::NewSymbol("LIGHT_MODEL_COLOR_CONTROL"), GetGL_LIGHT_MODEL_COLOR_CONTROL);

     Gl->SetAccessor(String::NewSymbol("SINGLE_COLOR"), GetGL_SINGLE_COLOR);

     Gl->SetAccessor(String::NewSymbol("SEPARATE_SPECULAR_COLOR"), GetGL_SEPARATE_SPECULAR_COLOR);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MIN_LOD"), GetGL_TEXTURE_MIN_LOD);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MAX_LOD"), GetGL_TEXTURE_MAX_LOD);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BASE_LEVEL"), GetGL_TEXTURE_BASE_LEVEL);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_MAX_LEVEL"), GetGL_TEXTURE_MAX_LEVEL);

     Gl->SetAccessor(String::NewSymbol("SMOOTH_POINT_SIZE_RANGE"), GetGL_SMOOTH_POINT_SIZE_RANGE);

     Gl->SetAccessor(String::NewSymbol("SMOOTH_POINT_SIZE_GRANULARITY"), GetGL_SMOOTH_POINT_SIZE_GRANULARITY);

     Gl->SetAccessor(String::NewSymbol("SMOOTH_LINE_WIDTH_RANGE"), GetGL_SMOOTH_LINE_WIDTH_RANGE);

     Gl->SetAccessor(String::NewSymbol("SMOOTH_LINE_WIDTH_GRANULARITY"), GetGL_SMOOTH_LINE_WIDTH_GRANULARITY);

     Gl->SetAccessor(String::NewSymbol("ALIASED_POINT_SIZE_RANGE"), GetGL_ALIASED_POINT_SIZE_RANGE);

     Gl->SetAccessor(String::NewSymbol("ALIASED_LINE_WIDTH_RANGE"), GetGL_ALIASED_LINE_WIDTH_RANGE);

     Gl->SetAccessor(String::NewSymbol("PACK_SKIP_IMAGES"), GetGL_PACK_SKIP_IMAGES);

     Gl->SetAccessor(String::NewSymbol("PACK_IMAGE_HEIGHT"), GetGL_PACK_IMAGE_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("UNPACK_SKIP_IMAGES"), GetGL_UNPACK_SKIP_IMAGES);

     Gl->SetAccessor(String::NewSymbol("UNPACK_IMAGE_HEIGHT"), GetGL_UNPACK_IMAGE_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_3D"), GetGL_TEXTURE_3D);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_3D"), GetGL_PROXY_TEXTURE_3D);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_DEPTH"), GetGL_TEXTURE_DEPTH);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_WRAP_R"), GetGL_TEXTURE_WRAP_R);

     Gl->SetAccessor(String::NewSymbol("MAX_3D_TEXTURE_SIZE"), GetGL_MAX_3D_TEXTURE_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_3D"), GetGL_TEXTURE_BINDING_3D);

     Gl->SetAccessor(String::NewSymbol("CONSTANT_COLOR"), GetGL_CONSTANT_COLOR);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_CONSTANT_COLOR"), GetGL_ONE_MINUS_CONSTANT_COLOR);

     Gl->SetAccessor(String::NewSymbol("CONSTANT_ALPHA"), GetGL_CONSTANT_ALPHA);

     Gl->SetAccessor(String::NewSymbol("ONE_MINUS_CONSTANT_ALPHA"), GetGL_ONE_MINUS_CONSTANT_ALPHA);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE"), GetGL_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_COLOR_TABLE"), GetGL_POST_CONVOLUTION_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_COLOR_TABLE"), GetGL_POST_COLOR_MATRIX_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("PROXY_COLOR_TABLE"), GetGL_PROXY_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("PROXY_POST_CONVOLUTION_COLOR_TABLE"), GetGL_PROXY_POST_CONVOLUTION_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("PROXY_POST_COLOR_MATRIX_COLOR_TABLE"), GetGL_PROXY_POST_COLOR_MATRIX_COLOR_TABLE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_SCALE"), GetGL_COLOR_TABLE_SCALE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_BIAS"), GetGL_COLOR_TABLE_BIAS);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_FORMAT"), GetGL_COLOR_TABLE_FORMAT);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_WIDTH"), GetGL_COLOR_TABLE_WIDTH);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_RED_SIZE"), GetGL_COLOR_TABLE_RED_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_GREEN_SIZE"), GetGL_COLOR_TABLE_GREEN_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_BLUE_SIZE"), GetGL_COLOR_TABLE_BLUE_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_ALPHA_SIZE"), GetGL_COLOR_TABLE_ALPHA_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_LUMINANCE_SIZE"), GetGL_COLOR_TABLE_LUMINANCE_SIZE);

     Gl->SetAccessor(String::NewSymbol("COLOR_TABLE_INTENSITY_SIZE"), GetGL_COLOR_TABLE_INTENSITY_SIZE);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_1D"), GetGL_CONVOLUTION_1D);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_2D"), GetGL_CONVOLUTION_2D);

     Gl->SetAccessor(String::NewSymbol("SEPARABLE_2D"), GetGL_SEPARABLE_2D);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_BORDER_MODE"), GetGL_CONVOLUTION_BORDER_MODE);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_FILTER_SCALE"), GetGL_CONVOLUTION_FILTER_SCALE);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_FILTER_BIAS"), GetGL_CONVOLUTION_FILTER_BIAS);

     Gl->SetAccessor(String::NewSymbol("REDUCE"), GetGL_REDUCE);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_FORMAT"), GetGL_CONVOLUTION_FORMAT);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_WIDTH"), GetGL_CONVOLUTION_WIDTH);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_HEIGHT"), GetGL_CONVOLUTION_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("MAX_CONVOLUTION_WIDTH"), GetGL_MAX_CONVOLUTION_WIDTH);

     Gl->SetAccessor(String::NewSymbol("MAX_CONVOLUTION_HEIGHT"), GetGL_MAX_CONVOLUTION_HEIGHT);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_RED_SCALE"), GetGL_POST_CONVOLUTION_RED_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_GREEN_SCALE"), GetGL_POST_CONVOLUTION_GREEN_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_BLUE_SCALE"), GetGL_POST_CONVOLUTION_BLUE_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_ALPHA_SCALE"), GetGL_POST_CONVOLUTION_ALPHA_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_RED_BIAS"), GetGL_POST_CONVOLUTION_RED_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_GREEN_BIAS"), GetGL_POST_CONVOLUTION_GREEN_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_BLUE_BIAS"), GetGL_POST_CONVOLUTION_BLUE_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_CONVOLUTION_ALPHA_BIAS"), GetGL_POST_CONVOLUTION_ALPHA_BIAS);

     Gl->SetAccessor(String::NewSymbol("CONSTANT_BORDER"), GetGL_CONSTANT_BORDER);

     Gl->SetAccessor(String::NewSymbol("REPLICATE_BORDER"), GetGL_REPLICATE_BORDER);

     Gl->SetAccessor(String::NewSymbol("CONVOLUTION_BORDER_COLOR"), GetGL_CONVOLUTION_BORDER_COLOR);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATRIX"), GetGL_COLOR_MATRIX);

     Gl->SetAccessor(String::NewSymbol("COLOR_MATRIX_STACK_DEPTH"), GetGL_COLOR_MATRIX_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("MAX_COLOR_MATRIX_STACK_DEPTH"), GetGL_MAX_COLOR_MATRIX_STACK_DEPTH);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_RED_SCALE"), GetGL_POST_COLOR_MATRIX_RED_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_GREEN_SCALE"), GetGL_POST_COLOR_MATRIX_GREEN_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_BLUE_SCALE"), GetGL_POST_COLOR_MATRIX_BLUE_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_ALPHA_SCALE"), GetGL_POST_COLOR_MATRIX_ALPHA_SCALE);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_RED_BIAS"), GetGL_POST_COLOR_MATRIX_RED_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_GREEN_BIAS"), GetGL_POST_COLOR_MATRIX_GREEN_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_BLUE_BIAS"), GetGL_POST_COLOR_MATRIX_BLUE_BIAS);

     Gl->SetAccessor(String::NewSymbol("POST_COLOR_MATRIX_ALPHA_BIAS"), GetGL_POST_COLOR_MATRIX_ALPHA_BIAS);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM"), GetGL_HISTOGRAM);

     Gl->SetAccessor(String::NewSymbol("PROXY_HISTOGRAM"), GetGL_PROXY_HISTOGRAM);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_WIDTH"), GetGL_HISTOGRAM_WIDTH);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_FORMAT"), GetGL_HISTOGRAM_FORMAT);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_RED_SIZE"), GetGL_HISTOGRAM_RED_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_GREEN_SIZE"), GetGL_HISTOGRAM_GREEN_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_BLUE_SIZE"), GetGL_HISTOGRAM_BLUE_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_ALPHA_SIZE"), GetGL_HISTOGRAM_ALPHA_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_LUMINANCE_SIZE"), GetGL_HISTOGRAM_LUMINANCE_SIZE);

     Gl->SetAccessor(String::NewSymbol("HISTOGRAM_SINK"), GetGL_HISTOGRAM_SINK);

     Gl->SetAccessor(String::NewSymbol("MINMAX"), GetGL_MINMAX);

     Gl->SetAccessor(String::NewSymbol("MINMAX_FORMAT"), GetGL_MINMAX_FORMAT);

     Gl->SetAccessor(String::NewSymbol("MINMAX_SINK"), GetGL_MINMAX_SINK);

     Gl->SetAccessor(String::NewSymbol("TABLE_TOO_LARGE"), GetGL_TABLE_TOO_LARGE);

     Gl->SetAccessor(String::NewSymbol("BLEND_EQUATION"), GetGL_BLEND_EQUATION);

     Gl->SetAccessor(String::NewSymbol("MIN"), GetGL_MIN);

     Gl->SetAccessor(String::NewSymbol("MAX"), GetGL_MAX);

     Gl->SetAccessor(String::NewSymbol("FUNC_ADD"), GetGL_FUNC_ADD);

     Gl->SetAccessor(String::NewSymbol("FUNC_SUBTRACT"), GetGL_FUNC_SUBTRACT);

     Gl->SetAccessor(String::NewSymbol("FUNC_REVERSE_SUBTRACT"), GetGL_FUNC_REVERSE_SUBTRACT);

     Gl->SetAccessor(String::NewSymbol("BLEND_COLOR"), GetGL_BLEND_COLOR);

     Gl->SetAccessor(String::NewSymbol("TEXTURE0"), GetGL_TEXTURE0);

     Gl->SetAccessor(String::NewSymbol("TEXTURE1"), GetGL_TEXTURE1);

     Gl->SetAccessor(String::NewSymbol("TEXTURE2"), GetGL_TEXTURE2);

     Gl->SetAccessor(String::NewSymbol("TEXTURE3"), GetGL_TEXTURE3);

     Gl->SetAccessor(String::NewSymbol("TEXTURE4"), GetGL_TEXTURE4);

     Gl->SetAccessor(String::NewSymbol("TEXTURE5"), GetGL_TEXTURE5);

     Gl->SetAccessor(String::NewSymbol("TEXTURE6"), GetGL_TEXTURE6);

     Gl->SetAccessor(String::NewSymbol("TEXTURE7"), GetGL_TEXTURE7);

     Gl->SetAccessor(String::NewSymbol("TEXTURE8"), GetGL_TEXTURE8);

     Gl->SetAccessor(String::NewSymbol("TEXTURE9"), GetGL_TEXTURE9);

     Gl->SetAccessor(String::NewSymbol("TEXTURE10"), GetGL_TEXTURE10);

     Gl->SetAccessor(String::NewSymbol("TEXTURE11"), GetGL_TEXTURE11);

     Gl->SetAccessor(String::NewSymbol("TEXTURE12"), GetGL_TEXTURE12);

     Gl->SetAccessor(String::NewSymbol("TEXTURE13"), GetGL_TEXTURE13);

     Gl->SetAccessor(String::NewSymbol("TEXTURE14"), GetGL_TEXTURE14);

     Gl->SetAccessor(String::NewSymbol("TEXTURE15"), GetGL_TEXTURE15);

     Gl->SetAccessor(String::NewSymbol("TEXTURE16"), GetGL_TEXTURE16);

     Gl->SetAccessor(String::NewSymbol("TEXTURE17"), GetGL_TEXTURE17);

     Gl->SetAccessor(String::NewSymbol("TEXTURE18"), GetGL_TEXTURE18);

     Gl->SetAccessor(String::NewSymbol("TEXTURE19"), GetGL_TEXTURE19);

     Gl->SetAccessor(String::NewSymbol("TEXTURE20"), GetGL_TEXTURE20);

     Gl->SetAccessor(String::NewSymbol("TEXTURE21"), GetGL_TEXTURE21);

     Gl->SetAccessor(String::NewSymbol("TEXTURE22"), GetGL_TEXTURE22);

     Gl->SetAccessor(String::NewSymbol("TEXTURE23"), GetGL_TEXTURE23);

     Gl->SetAccessor(String::NewSymbol("TEXTURE24"), GetGL_TEXTURE24);

     Gl->SetAccessor(String::NewSymbol("TEXTURE25"), GetGL_TEXTURE25);

     Gl->SetAccessor(String::NewSymbol("TEXTURE26"), GetGL_TEXTURE26);

     Gl->SetAccessor(String::NewSymbol("TEXTURE27"), GetGL_TEXTURE27);

     Gl->SetAccessor(String::NewSymbol("TEXTURE28"), GetGL_TEXTURE28);

     Gl->SetAccessor(String::NewSymbol("TEXTURE29"), GetGL_TEXTURE29);

     Gl->SetAccessor(String::NewSymbol("TEXTURE30"), GetGL_TEXTURE30);

     Gl->SetAccessor(String::NewSymbol("TEXTURE31"), GetGL_TEXTURE31);

     Gl->SetAccessor(String::NewSymbol("ACTIVE_TEXTURE"), GetGL_ACTIVE_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("CLIENT_ACTIVE_TEXTURE"), GetGL_CLIENT_ACTIVE_TEXTURE);

     Gl->SetAccessor(String::NewSymbol("MAX_TEXTURE_UNITS"), GetGL_MAX_TEXTURE_UNITS);

     Gl->SetAccessor(String::NewSymbol("NORMAL_MAP"), GetGL_NORMAL_MAP);

     Gl->SetAccessor(String::NewSymbol("REFLECTION_MAP"), GetGL_REFLECTION_MAP);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP"), GetGL_TEXTURE_CUBE_MAP);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_BINDING_CUBE_MAP"), GetGL_TEXTURE_BINDING_CUBE_MAP);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_POSITIVE_X"), GetGL_TEXTURE_CUBE_MAP_POSITIVE_X);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_NEGATIVE_X"), GetGL_TEXTURE_CUBE_MAP_NEGATIVE_X);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_POSITIVE_Y"), GetGL_TEXTURE_CUBE_MAP_POSITIVE_Y);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_NEGATIVE_Y"), GetGL_TEXTURE_CUBE_MAP_NEGATIVE_Y);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_POSITIVE_Z"), GetGL_TEXTURE_CUBE_MAP_POSITIVE_Z);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_CUBE_MAP_NEGATIVE_Z"), GetGL_TEXTURE_CUBE_MAP_NEGATIVE_Z);

     Gl->SetAccessor(String::NewSymbol("PROXY_TEXTURE_CUBE_MAP"), GetGL_PROXY_TEXTURE_CUBE_MAP);

     Gl->SetAccessor(String::NewSymbol("MAX_CUBE_MAP_TEXTURE_SIZE"), GetGL_MAX_CUBE_MAP_TEXTURE_SIZE);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_ALPHA"), GetGL_COMPRESSED_ALPHA);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_LUMINANCE"), GetGL_COMPRESSED_LUMINANCE);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_LUMINANCE_ALPHA"), GetGL_COMPRESSED_LUMINANCE_ALPHA);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_INTENSITY"), GetGL_COMPRESSED_INTENSITY);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_RGB"), GetGL_COMPRESSED_RGB);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_RGBA"), GetGL_COMPRESSED_RGBA);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COMPRESSION_HINT"), GetGL_TEXTURE_COMPRESSION_HINT);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COMPRESSED_IMAGE_SIZE"), GetGL_TEXTURE_COMPRESSED_IMAGE_SIZE);

     Gl->SetAccessor(String::NewSymbol("TEXTURE_COMPRESSED"), GetGL_TEXTURE_COMPRESSED);

     Gl->SetAccessor(String::NewSymbol("NUM_COMPRESSED_TEXTURE_FORMATS"), GetGL_NUM_COMPRESSED_TEXTURE_FORMATS);

     Gl->SetAccessor(String::NewSymbol("COMPRESSED_TEXTURE_FORMATS"), GetGL_COMPRESSED_TEXTURE_FORMATS);

     Gl->SetAccessor(String::NewSymbol("MULTISAMPLE"), GetGL_MULTISAMPLE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_ALPHA_TO_COVERAGE"), GetGL_SAMPLE_ALPHA_TO_COVERAGE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_ALPHA_TO_ONE"), GetGL_SAMPLE_ALPHA_TO_ONE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_COVERAGE"), GetGL_SAMPLE_COVERAGE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_BUFFERS"), GetGL_SAMPLE_BUFFERS);

     Gl->SetAccessor(String::NewSymbol("SAMPLES"), GetGL_SAMPLES);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_COVERAGE_VALUE"), GetGL_SAMPLE_COVERAGE_VALUE);

     Gl->SetAccessor(String::NewSymbol("SAMPLE_COVERAGE_INVERT"), GetGL_SAMPLE_COVERAGE_INVERT);

     Gl->SetAccessor(String::NewSymbol("MULTISAMPLE_BIT"), GetGL_MULTISAMPLE_BIT);

     Gl->SetAccessor(String::NewSymbol("TRANSPOSE_MODELVIEW_MATRIX"), GetGL_TRANSPOSE_MODELVIEW_MATRIX);

     Gl->SetAccessor(String::NewSymbol("TRANSPOSE_PROJECTION_MATRIX"), GetGL_TRANSPOSE_PROJECTION_MATRIX);

     Gl->SetAccessor(String::NewSymbol("TRANSPOSE_TEXTURE_MATRIX"), GetGL_TRANSPOSE_TEXTURE_MATRIX);

     Gl->SetAccessor(String::NewSymbol("TRANSPOSE_COLOR_MATRIX"), GetGL_TRANSPOSE_COLOR_MATRIX);

     Gl->SetAccessor(String::NewSymbol("COMBINE"), GetGL_COMBINE);

     Gl->SetAccessor(String::NewSymbol("COMBINE_RGB"), GetGL_COMBINE_RGB);

     Gl->SetAccessor(String::NewSymbol("COMBINE_ALPHA"), GetGL_COMBINE_ALPHA);

     Gl->SetAccessor(String::NewSymbol("SOURCE0_RGB"), GetGL_SOURCE0_RGB);

     Gl->SetAccessor(String::NewSymbol("SOURCE1_RGB"), GetGL_SOURCE1_RGB);

     Gl->SetAccessor(String::NewSymbol("SOURCE2_RGB"), GetGL_SOURCE2_RGB);

     Gl->SetAccessor(String::NewSymbol("SOURCE0_ALPHA"), GetGL_SOURCE0_ALPHA);

     Gl->SetAccessor(String::NewSymbol("SOURCE1_ALPHA"), GetGL_SOURCE1_ALPHA);

     Gl->SetAccessor(String::NewSymbol("SOURCE2_ALPHA"), GetGL_SOURCE2_ALPHA);

     Gl->SetAccessor(String::NewSymbol("OPERAND0_RGB"), GetGL_OPERAND0_RGB);

     Gl->SetAccessor(String::NewSymbol("OPERAND1_RGB"), GetGL_OPERAND1_RGB);

     Gl->SetAccessor(String::NewSymbol("OPERAND2_RGB"), GetGL_OPERAND2_RGB);

     Gl->SetAccessor(String::NewSymbol("OPERAND0_ALPHA"), GetGL_OPERAND0_ALPHA);

     Gl->SetAccessor(String::NewSymbol("OPERAND1_ALPHA"), GetGL_OPERAND1_ALPHA);

     Gl->SetAccessor(String::NewSymbol("OPERAND2_ALPHA"), GetGL_OPERAND2_ALPHA);

     Gl->SetAccessor(String::NewSymbol("RGB_SCALE"), GetGL_RGB_SCALE);

     Gl->SetAccessor(String::NewSymbol("ADD_SIGNED"), GetGL_ADD_SIGNED);

     Gl->SetAccessor(String::NewSymbol("INTERPOLATE"), GetGL_INTERPOLATE);

     Gl->SetAccessor(String::NewSymbol("SUBTRACT"), GetGL_SUBTRACT);

     Gl->SetAccessor(String::NewSymbol("CONSTANT"), GetGL_CONSTANT);

     Gl->SetAccessor(String::NewSymbol("PRIMARY_COLOR"), GetGL_PRIMARY_COLOR);

     Gl->SetAccessor(String::NewSymbol("PREVIOUS"), GetGL_PREVIOUS);

     Gl->SetAccessor(String::NewSymbol("DOT3_RGB"), GetGL_DOT3_RGB);

     Gl->SetAccessor(String::NewSymbol("DOT3_RGBA"), GetGL_DOT3_RGBA);

     Gl->SetAccessor(String::NewSymbol("CLAMP_TO_BORDER"), GetGL_CLAMP_TO_BORDER);

     Gl->SetAccessor(String::NewSymbol("ARB_multitexture"), GetGL_ARB_multitexture);

     Gl->SetAccessor(String::NewSymbol("TEXTURE0_ARB"), GetGL_TEXTURE0_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE1_ARB"), GetGL_TEXTURE1_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE2_ARB"), GetGL_TEXTURE2_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE3_ARB"), GetGL_TEXTURE3_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE4_ARB"), GetGL_TEXTURE4_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE5_ARB"), GetGL_TEXTURE5_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE6_ARB"), GetGL_TEXTURE6_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE7_ARB"), GetGL_TEXTURE7_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE8_ARB"), GetGL_TEXTURE8_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE9_ARB"), GetGL_TEXTURE9_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE10_ARB"), GetGL_TEXTURE10_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE11_ARB"), GetGL_TEXTURE11_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE12_ARB"), GetGL_TEXTURE12_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE13_ARB"), GetGL_TEXTURE13_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE14_ARB"), GetGL_TEXTURE14_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE15_ARB"), GetGL_TEXTURE15_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE16_ARB"), GetGL_TEXTURE16_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE17_ARB"), GetGL_TEXTURE17_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE18_ARB"), GetGL_TEXTURE18_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE19_ARB"), GetGL_TEXTURE19_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE20_ARB"), GetGL_TEXTURE20_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE21_ARB"), GetGL_TEXTURE21_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE22_ARB"), GetGL_TEXTURE22_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE23_ARB"), GetGL_TEXTURE23_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE24_ARB"), GetGL_TEXTURE24_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE25_ARB"), GetGL_TEXTURE25_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE26_ARB"), GetGL_TEXTURE26_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE27_ARB"), GetGL_TEXTURE27_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE28_ARB"), GetGL_TEXTURE28_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE29_ARB"), GetGL_TEXTURE29_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE30_ARB"), GetGL_TEXTURE30_ARB);

     Gl->SetAccessor(String::NewSymbol("TEXTURE31_ARB"), GetGL_TEXTURE31_ARB);

     Gl->SetAccessor(String::NewSymbol("ACTIVE_TEXTURE_ARB"), GetGL_ACTIVE_TEXTURE_ARB);

     Gl->SetAccessor(String::NewSymbol("CLIENT_ACTIVE_TEXTURE_ARB"), GetGL_CLIENT_ACTIVE_TEXTURE_ARB);

     Gl->SetAccessor(String::NewSymbol("MAX_TEXTURE_UNITS_ARB"), GetGL_MAX_TEXTURE_UNITS_ARB);

     Gl->SetAccessor(String::NewSymbol("MESA_shader_debug"), GetGL_MESA_shader_debug);

     Gl->SetAccessor(String::NewSymbol("DEBUG_OBJECT_MESA"), GetGL_DEBUG_OBJECT_MESA);

     Gl->SetAccessor(String::NewSymbol("DEBUG_PRINT_MESA"), GetGL_DEBUG_PRINT_MESA);

     Gl->SetAccessor(String::NewSymbol("DEBUG_ASSERT_MESA"), GetGL_DEBUG_ASSERT_MESA);

     Gl->SetAccessor(String::NewSymbol("MESA_packed_depth_stencil"), GetGL_MESA_packed_depth_stencil);

     Gl->SetAccessor(String::NewSymbol("DEPTH_STENCIL_MESA"), GetGL_DEPTH_STENCIL_MESA);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_24_8_MESA"), GetGL_UNSIGNED_INT_24_8_MESA);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_INT_8_24_REV_MESA"), GetGL_UNSIGNED_INT_8_24_REV_MESA);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_15_1_MESA"), GetGL_UNSIGNED_SHORT_15_1_MESA);

     Gl->SetAccessor(String::NewSymbol("UNSIGNED_SHORT_1_15_REV_MESA"), GetGL_UNSIGNED_SHORT_1_15_REV_MESA);

     Gl->SetAccessor(String::NewSymbol("MESA_program_debug"), GetGL_MESA_program_debug);

     Gl->SetAccessor(String::NewSymbol("FRAGMENT_PROGRAM_POSITION_MESA"), GetGL_FRAGMENT_PROGRAM_POSITION_MESA);

     Gl->SetAccessor(String::NewSymbol("FRAGMENT_PROGRAM_CALLBACK_MESA"), GetGL_FRAGMENT_PROGRAM_CALLBACK_MESA);

     Gl->SetAccessor(String::NewSymbol("FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA"), GetGL_FRAGMENT_PROGRAM_CALLBACK_FUNC_MESA);

     Gl->SetAccessor(String::NewSymbol("FRAGMENT_PROGRAM_CALLBACK_DATA_MESA"), GetGL_FRAGMENT_PROGRAM_CALLBACK_DATA_MESA);

     Gl->SetAccessor(String::NewSymbol("VERTEX_PROGRAM_POSITION_MESA"), GetGL_VERTEX_PROGRAM_POSITION_MESA);

     Gl->SetAccessor(String::NewSymbol("VERTEX_PROGRAM_CALLBACK_MESA"), GetGL_VERTEX_PROGRAM_CALLBACK_MESA);

     Gl->SetAccessor(String::NewSymbol("VERTEX_PROGRAM_CALLBACK_FUNC_MESA"), GetGL_VERTEX_PROGRAM_CALLBACK_FUNC_MESA);

     Gl->SetAccessor(String::NewSymbol("VERTEX_PROGRAM_CALLBACK_DATA_MESA"), GetGL_VERTEX_PROGRAM_CALLBACK_DATA_MESA);

     Gl->SetAccessor(String::NewSymbol("ATI_blend_equation_separate"), GetGL_ATI_blend_equation_separate);

     Gl->SetAccessor(String::NewSymbol("ALPHA_BLEND_EQUATION_ATI"), GetGL_ALPHA_BLEND_EQUATION_ATI);
     Gl->Set(String::NewSymbol("ClearIndex"), FunctionTemplate::New(GLClearIndexCallback));

     Gl->Set(String::NewSymbol("ClearColor"), FunctionTemplate::New(GLClearColorCallback));

     Gl->Set(String::NewSymbol("Clear"), FunctionTemplate::New(GLClearCallback));

     Gl->Set(String::NewSymbol("IndexMask"), FunctionTemplate::New(GLIndexMaskCallback));

     Gl->Set(String::NewSymbol("ColorMask"), FunctionTemplate::New(GLColorMaskCallback));

     Gl->Set(String::NewSymbol("AlphaFunc"), FunctionTemplate::New(GLAlphaFuncCallback));

     Gl->Set(String::NewSymbol("BlendFunc"), FunctionTemplate::New(GLBlendFuncCallback));

     Gl->Set(String::NewSymbol("LogicOp"), FunctionTemplate::New(GLLogicOpCallback));

     Gl->Set(String::NewSymbol("CullFace"), FunctionTemplate::New(GLCullFaceCallback));

     Gl->Set(String::NewSymbol("FrontFace"), FunctionTemplate::New(GLFrontFaceCallback));

     Gl->Set(String::NewSymbol("PointSize"), FunctionTemplate::New(GLPointSizeCallback));

     Gl->Set(String::NewSymbol("LineWidth"), FunctionTemplate::New(GLLineWidthCallback));

     Gl->Set(String::NewSymbol("LineStipple"), FunctionTemplate::New(GLLineStippleCallback));

     Gl->Set(String::NewSymbol("PolygonMode"), FunctionTemplate::New(GLPolygonModeCallback));

     Gl->Set(String::NewSymbol("PolygonOffset"), FunctionTemplate::New(GLPolygonOffsetCallback));

     Gl->Set(String::NewSymbol("PolygonStipple"), FunctionTemplate::New(GLPolygonStippleCallback));

     Gl->Set(String::NewSymbol("GetPolygonStipple"), FunctionTemplate::New(GLGetPolygonStippleCallback));

     Gl->Set(String::NewSymbol("EdgeFlag"), FunctionTemplate::New(GLEdgeFlagCallback));

     Gl->Set(String::NewSymbol("EdgeFlagv"), FunctionTemplate::New(GLEdgeFlagvCallback));

     Gl->Set(String::NewSymbol("Scissor"), FunctionTemplate::New(GLScissorCallback));

     Gl->Set(String::NewSymbol("ClipPlane"), FunctionTemplate::New(GLClipPlaneCallback));

     Gl->Set(String::NewSymbol("GetClipPlane"), FunctionTemplate::New(GLGetClipPlaneCallback));

     Gl->Set(String::NewSymbol("DrawBuffer"), FunctionTemplate::New(GLDrawBufferCallback));

     Gl->Set(String::NewSymbol("ReadBuffer"), FunctionTemplate::New(GLReadBufferCallback));

     Gl->Set(String::NewSymbol("Enable"), FunctionTemplate::New(GLEnableCallback));

     Gl->Set(String::NewSymbol("Disable"), FunctionTemplate::New(GLDisableCallback));

     Gl->Set(String::NewSymbol("IsEnabled"), FunctionTemplate::New(GLIsEnabledCallback));

     Gl->Set(String::NewSymbol("EnableClientState"), FunctionTemplate::New(GLEnableClientStateCallback));

     Gl->Set(String::NewSymbol("DisableClientState"), FunctionTemplate::New(GLDisableClientStateCallback));

     Gl->Set(String::NewSymbol("GetBooleanv"), FunctionTemplate::New(GLGetBooleanvCallback));

     Gl->Set(String::NewSymbol("GetDoublev"), FunctionTemplate::New(GLGetDoublevCallback));

     Gl->Set(String::NewSymbol("GetFloatv"), FunctionTemplate::New(GLGetFloatvCallback));

     Gl->Set(String::NewSymbol("GetIntegerv"), FunctionTemplate::New(GLGetIntegervCallback));

     Gl->Set(String::NewSymbol("PushAttrib"), FunctionTemplate::New(GLPushAttribCallback));

     Gl->Set(String::NewSymbol("PopAttrib"), FunctionTemplate::New(GLPopAttribCallback));

     Gl->Set(String::NewSymbol("PushClientAttrib"), FunctionTemplate::New(GLPushClientAttribCallback));

     Gl->Set(String::NewSymbol("PopClientAttrib"), FunctionTemplate::New(GLPopClientAttribCallback));

     Gl->Set(String::NewSymbol("RenderMode"), FunctionTemplate::New(GLRenderModeCallback));

     Gl->Set(String::NewSymbol("GetError"), FunctionTemplate::New(GLGetErrorCallback));

     Gl->Set(String::NewSymbol("Finish"), FunctionTemplate::New(GLFinishCallback));

     Gl->Set(String::NewSymbol("Flush"), FunctionTemplate::New(GLFlushCallback));

     Gl->Set(String::NewSymbol("Hint"), FunctionTemplate::New(GLHintCallback));

     Gl->Set(String::NewSymbol("ClearDepth"), FunctionTemplate::New(GLClearDepthCallback));

     Gl->Set(String::NewSymbol("DepthFunc"), FunctionTemplate::New(GLDepthFuncCallback));

     Gl->Set(String::NewSymbol("DepthMask"), FunctionTemplate::New(GLDepthMaskCallback));

     Gl->Set(String::NewSymbol("DepthRange"), FunctionTemplate::New(GLDepthRangeCallback));

     Gl->Set(String::NewSymbol("ClearAccum"), FunctionTemplate::New(GLClearAccumCallback));

     Gl->Set(String::NewSymbol("Accum"), FunctionTemplate::New(GLAccumCallback));

     Gl->Set(String::NewSymbol("MatrixMode"), FunctionTemplate::New(GLMatrixModeCallback));

     Gl->Set(String::NewSymbol("Ortho"), FunctionTemplate::New(GLOrthoCallback));

     Gl->Set(String::NewSymbol("Frustum"), FunctionTemplate::New(GLFrustumCallback));

     Gl->Set(String::NewSymbol("Viewport"), FunctionTemplate::New(GLViewportCallback));

     Gl->Set(String::NewSymbol("PushMatrix"), FunctionTemplate::New(GLPushMatrixCallback));

     Gl->Set(String::NewSymbol("PopMatrix"), FunctionTemplate::New(GLPopMatrixCallback));

     Gl->Set(String::NewSymbol("LoadIdentity"), FunctionTemplate::New(GLLoadIdentityCallback));

     Gl->Set(String::NewSymbol("LoadMatrixd"), FunctionTemplate::New(GLLoadMatrixdCallback));

     Gl->Set(String::NewSymbol("LoadMatrixf"), FunctionTemplate::New(GLLoadMatrixfCallback));

     Gl->Set(String::NewSymbol("MultMatrixd"), FunctionTemplate::New(GLMultMatrixdCallback));

     Gl->Set(String::NewSymbol("MultMatrixf"), FunctionTemplate::New(GLMultMatrixfCallback));

     Gl->Set(String::NewSymbol("Rotated"), FunctionTemplate::New(GLRotatedCallback));

     Gl->Set(String::NewSymbol("Rotatef"), FunctionTemplate::New(GLRotatefCallback));

     Gl->Set(String::NewSymbol("Scaled"), FunctionTemplate::New(GLScaledCallback));

     Gl->Set(String::NewSymbol("Scalef"), FunctionTemplate::New(GLScalefCallback));

     Gl->Set(String::NewSymbol("Translated"), FunctionTemplate::New(GLTranslatedCallback));

     Gl->Set(String::NewSymbol("Translatef"), FunctionTemplate::New(GLTranslatefCallback));

     Gl->Set(String::NewSymbol("IsList"), FunctionTemplate::New(GLIsListCallback));

     Gl->Set(String::NewSymbol("DeleteLists"), FunctionTemplate::New(GLDeleteListsCallback));

     Gl->Set(String::NewSymbol("GenLists"), FunctionTemplate::New(GLGenListsCallback));

     Gl->Set(String::NewSymbol("NewList"), FunctionTemplate::New(GLNewListCallback));

     Gl->Set(String::NewSymbol("EndList"), FunctionTemplate::New(GLEndListCallback));

     Gl->Set(String::NewSymbol("CallList"), FunctionTemplate::New(GLCallListCallback));

     Gl->Set(String::NewSymbol("ListBase"), FunctionTemplate::New(GLListBaseCallback));

     Gl->Set(String::NewSymbol("Begin"), FunctionTemplate::New(GLBeginCallback));

     Gl->Set(String::NewSymbol("End"), FunctionTemplate::New(GLEndCallback));

     Gl->Set(String::NewSymbol("Vertex2d"), FunctionTemplate::New(GLVertex2dCallback));

     Gl->Set(String::NewSymbol("Vertex2f"), FunctionTemplate::New(GLVertex2fCallback));

     Gl->Set(String::NewSymbol("Vertex2i"), FunctionTemplate::New(GLVertex2iCallback));

     Gl->Set(String::NewSymbol("Vertex2s"), FunctionTemplate::New(GLVertex2sCallback));

     Gl->Set(String::NewSymbol("Vertex3d"), FunctionTemplate::New(GLVertex3dCallback));

     Gl->Set(String::NewSymbol("Vertex3f"), FunctionTemplate::New(GLVertex3fCallback));

     Gl->Set(String::NewSymbol("Vertex3i"), FunctionTemplate::New(GLVertex3iCallback));

     Gl->Set(String::NewSymbol("Vertex3s"), FunctionTemplate::New(GLVertex3sCallback));

     Gl->Set(String::NewSymbol("Vertex4d"), FunctionTemplate::New(GLVertex4dCallback));

     Gl->Set(String::NewSymbol("Vertex4f"), FunctionTemplate::New(GLVertex4fCallback));

     Gl->Set(String::NewSymbol("Vertex4i"), FunctionTemplate::New(GLVertex4iCallback));

     Gl->Set(String::NewSymbol("Vertex4s"), FunctionTemplate::New(GLVertex4sCallback));

     Gl->Set(String::NewSymbol("Vertex2dv"), FunctionTemplate::New(GLVertex2dvCallback));

     Gl->Set(String::NewSymbol("Vertex2fv"), FunctionTemplate::New(GLVertex2fvCallback));

     Gl->Set(String::NewSymbol("Vertex2iv"), FunctionTemplate::New(GLVertex2ivCallback));

     Gl->Set(String::NewSymbol("Vertex2sv"), FunctionTemplate::New(GLVertex2svCallback));

     Gl->Set(String::NewSymbol("Vertex3dv"), FunctionTemplate::New(GLVertex3dvCallback));

     Gl->Set(String::NewSymbol("Vertex3fv"), FunctionTemplate::New(GLVertex3fvCallback));

     Gl->Set(String::NewSymbol("Vertex3iv"), FunctionTemplate::New(GLVertex3ivCallback));

     Gl->Set(String::NewSymbol("Vertex3sv"), FunctionTemplate::New(GLVertex3svCallback));

     Gl->Set(String::NewSymbol("Vertex4dv"), FunctionTemplate::New(GLVertex4dvCallback));

     Gl->Set(String::NewSymbol("Vertex4fv"), FunctionTemplate::New(GLVertex4fvCallback));

     Gl->Set(String::NewSymbol("Vertex4iv"), FunctionTemplate::New(GLVertex4ivCallback));

     Gl->Set(String::NewSymbol("Vertex4sv"), FunctionTemplate::New(GLVertex4svCallback));

     Gl->Set(String::NewSymbol("Normal3b"), FunctionTemplate::New(GLNormal3bCallback));

     Gl->Set(String::NewSymbol("Normal3d"), FunctionTemplate::New(GLNormal3dCallback));

     Gl->Set(String::NewSymbol("Normal3f"), FunctionTemplate::New(GLNormal3fCallback));

     Gl->Set(String::NewSymbol("Normal3i"), FunctionTemplate::New(GLNormal3iCallback));

     Gl->Set(String::NewSymbol("Normal3s"), FunctionTemplate::New(GLNormal3sCallback));

     Gl->Set(String::NewSymbol("Normal3bv"), FunctionTemplate::New(GLNormal3bvCallback));

     Gl->Set(String::NewSymbol("Normal3dv"), FunctionTemplate::New(GLNormal3dvCallback));

     Gl->Set(String::NewSymbol("Normal3fv"), FunctionTemplate::New(GLNormal3fvCallback));

     Gl->Set(String::NewSymbol("Normal3iv"), FunctionTemplate::New(GLNormal3ivCallback));

     Gl->Set(String::NewSymbol("Normal3sv"), FunctionTemplate::New(GLNormal3svCallback));

     Gl->Set(String::NewSymbol("Indexd"), FunctionTemplate::New(GLIndexdCallback));

     Gl->Set(String::NewSymbol("Indexf"), FunctionTemplate::New(GLIndexfCallback));

     Gl->Set(String::NewSymbol("Indexi"), FunctionTemplate::New(GLIndexiCallback));

     Gl->Set(String::NewSymbol("Indexs"), FunctionTemplate::New(GLIndexsCallback));

     Gl->Set(String::NewSymbol("Indexub"), FunctionTemplate::New(GLIndexubCallback));

     Gl->Set(String::NewSymbol("Indexdv"), FunctionTemplate::New(GLIndexdvCallback));

     Gl->Set(String::NewSymbol("Indexfv"), FunctionTemplate::New(GLIndexfvCallback));

     Gl->Set(String::NewSymbol("Indexiv"), FunctionTemplate::New(GLIndexivCallback));

     Gl->Set(String::NewSymbol("Indexsv"), FunctionTemplate::New(GLIndexsvCallback));

     Gl->Set(String::NewSymbol("Indexubv"), FunctionTemplate::New(GLIndexubvCallback));

     Gl->Set(String::NewSymbol("Color3b"), FunctionTemplate::New(GLColor3bCallback));

     Gl->Set(String::NewSymbol("Color3d"), FunctionTemplate::New(GLColor3dCallback));

     Gl->Set(String::NewSymbol("Color3f"), FunctionTemplate::New(GLColor3fCallback));

     Gl->Set(String::NewSymbol("Color3i"), FunctionTemplate::New(GLColor3iCallback));

     Gl->Set(String::NewSymbol("Color3s"), FunctionTemplate::New(GLColor3sCallback));

     Gl->Set(String::NewSymbol("Color3ub"), FunctionTemplate::New(GLColor3ubCallback));

     Gl->Set(String::NewSymbol("Color3ui"), FunctionTemplate::New(GLColor3uiCallback));

     Gl->Set(String::NewSymbol("Color3us"), FunctionTemplate::New(GLColor3usCallback));

     Gl->Set(String::NewSymbol("Color4b"), FunctionTemplate::New(GLColor4bCallback));

     Gl->Set(String::NewSymbol("Color4d"), FunctionTemplate::New(GLColor4dCallback));

     Gl->Set(String::NewSymbol("Color4f"), FunctionTemplate::New(GLColor4fCallback));

     Gl->Set(String::NewSymbol("Color4i"), FunctionTemplate::New(GLColor4iCallback));

     Gl->Set(String::NewSymbol("Color4s"), FunctionTemplate::New(GLColor4sCallback));

     Gl->Set(String::NewSymbol("Color4ub"), FunctionTemplate::New(GLColor4ubCallback));

     Gl->Set(String::NewSymbol("Color4ui"), FunctionTemplate::New(GLColor4uiCallback));

     Gl->Set(String::NewSymbol("Color4us"), FunctionTemplate::New(GLColor4usCallback));

     Gl->Set(String::NewSymbol("Color3bv"), FunctionTemplate::New(GLColor3bvCallback));

     Gl->Set(String::NewSymbol("Color3dv"), FunctionTemplate::New(GLColor3dvCallback));

     Gl->Set(String::NewSymbol("Color3fv"), FunctionTemplate::New(GLColor3fvCallback));

     Gl->Set(String::NewSymbol("Color3iv"), FunctionTemplate::New(GLColor3ivCallback));

     Gl->Set(String::NewSymbol("Color3sv"), FunctionTemplate::New(GLColor3svCallback));

     Gl->Set(String::NewSymbol("Color3ubv"), FunctionTemplate::New(GLColor3ubvCallback));

     Gl->Set(String::NewSymbol("Color3uiv"), FunctionTemplate::New(GLColor3uivCallback));

     Gl->Set(String::NewSymbol("Color3usv"), FunctionTemplate::New(GLColor3usvCallback));

     Gl->Set(String::NewSymbol("Color4bv"), FunctionTemplate::New(GLColor4bvCallback));

     Gl->Set(String::NewSymbol("Color4dv"), FunctionTemplate::New(GLColor4dvCallback));

     Gl->Set(String::NewSymbol("Color4fv"), FunctionTemplate::New(GLColor4fvCallback));

     Gl->Set(String::NewSymbol("Color4iv"), FunctionTemplate::New(GLColor4ivCallback));

     Gl->Set(String::NewSymbol("Color4sv"), FunctionTemplate::New(GLColor4svCallback));

     Gl->Set(String::NewSymbol("Color4ubv"), FunctionTemplate::New(GLColor4ubvCallback));

     Gl->Set(String::NewSymbol("Color4uiv"), FunctionTemplate::New(GLColor4uivCallback));

     Gl->Set(String::NewSymbol("Color4usv"), FunctionTemplate::New(GLColor4usvCallback));

     Gl->Set(String::NewSymbol("TexCoord1d"), FunctionTemplate::New(GLTexCoord1dCallback));

     Gl->Set(String::NewSymbol("TexCoord1f"), FunctionTemplate::New(GLTexCoord1fCallback));

     Gl->Set(String::NewSymbol("TexCoord1i"), FunctionTemplate::New(GLTexCoord1iCallback));

     Gl->Set(String::NewSymbol("TexCoord1s"), FunctionTemplate::New(GLTexCoord1sCallback));

     Gl->Set(String::NewSymbol("TexCoord2d"), FunctionTemplate::New(GLTexCoord2dCallback));

     Gl->Set(String::NewSymbol("TexCoord2f"), FunctionTemplate::New(GLTexCoord2fCallback));

     Gl->Set(String::NewSymbol("TexCoord2i"), FunctionTemplate::New(GLTexCoord2iCallback));

     Gl->Set(String::NewSymbol("TexCoord2s"), FunctionTemplate::New(GLTexCoord2sCallback));

     Gl->Set(String::NewSymbol("TexCoord3d"), FunctionTemplate::New(GLTexCoord3dCallback));

     Gl->Set(String::NewSymbol("TexCoord3f"), FunctionTemplate::New(GLTexCoord3fCallback));

     Gl->Set(String::NewSymbol("TexCoord3i"), FunctionTemplate::New(GLTexCoord3iCallback));

     Gl->Set(String::NewSymbol("TexCoord3s"), FunctionTemplate::New(GLTexCoord3sCallback));

     Gl->Set(String::NewSymbol("TexCoord4d"), FunctionTemplate::New(GLTexCoord4dCallback));

     Gl->Set(String::NewSymbol("TexCoord4f"), FunctionTemplate::New(GLTexCoord4fCallback));

     Gl->Set(String::NewSymbol("TexCoord4i"), FunctionTemplate::New(GLTexCoord4iCallback));

     Gl->Set(String::NewSymbol("TexCoord4s"), FunctionTemplate::New(GLTexCoord4sCallback));

     Gl->Set(String::NewSymbol("TexCoord1dv"), FunctionTemplate::New(GLTexCoord1dvCallback));

     Gl->Set(String::NewSymbol("TexCoord1fv"), FunctionTemplate::New(GLTexCoord1fvCallback));

     Gl->Set(String::NewSymbol("TexCoord1iv"), FunctionTemplate::New(GLTexCoord1ivCallback));

     Gl->Set(String::NewSymbol("TexCoord1sv"), FunctionTemplate::New(GLTexCoord1svCallback));

     Gl->Set(String::NewSymbol("TexCoord2dv"), FunctionTemplate::New(GLTexCoord2dvCallback));

     Gl->Set(String::NewSymbol("TexCoord2fv"), FunctionTemplate::New(GLTexCoord2fvCallback));

     Gl->Set(String::NewSymbol("TexCoord2iv"), FunctionTemplate::New(GLTexCoord2ivCallback));

     Gl->Set(String::NewSymbol("TexCoord2sv"), FunctionTemplate::New(GLTexCoord2svCallback));

     Gl->Set(String::NewSymbol("TexCoord3dv"), FunctionTemplate::New(GLTexCoord3dvCallback));

     Gl->Set(String::NewSymbol("TexCoord3fv"), FunctionTemplate::New(GLTexCoord3fvCallback));

     Gl->Set(String::NewSymbol("TexCoord3iv"), FunctionTemplate::New(GLTexCoord3ivCallback));

     Gl->Set(String::NewSymbol("TexCoord3sv"), FunctionTemplate::New(GLTexCoord3svCallback));

     Gl->Set(String::NewSymbol("TexCoord4dv"), FunctionTemplate::New(GLTexCoord4dvCallback));

     Gl->Set(String::NewSymbol("TexCoord4fv"), FunctionTemplate::New(GLTexCoord4fvCallback));

     Gl->Set(String::NewSymbol("TexCoord4iv"), FunctionTemplate::New(GLTexCoord4ivCallback));

     Gl->Set(String::NewSymbol("TexCoord4sv"), FunctionTemplate::New(GLTexCoord4svCallback));

     Gl->Set(String::NewSymbol("RasterPos2d"), FunctionTemplate::New(GLRasterPos2dCallback));

     Gl->Set(String::NewSymbol("RasterPos2f"), FunctionTemplate::New(GLRasterPos2fCallback));

     Gl->Set(String::NewSymbol("RasterPos2i"), FunctionTemplate::New(GLRasterPos2iCallback));

     Gl->Set(String::NewSymbol("RasterPos2s"), FunctionTemplate::New(GLRasterPos2sCallback));

     Gl->Set(String::NewSymbol("RasterPos3d"), FunctionTemplate::New(GLRasterPos3dCallback));

     Gl->Set(String::NewSymbol("RasterPos3f"), FunctionTemplate::New(GLRasterPos3fCallback));

     Gl->Set(String::NewSymbol("RasterPos3i"), FunctionTemplate::New(GLRasterPos3iCallback));

     Gl->Set(String::NewSymbol("RasterPos3s"), FunctionTemplate::New(GLRasterPos3sCallback));

     Gl->Set(String::NewSymbol("RasterPos4d"), FunctionTemplate::New(GLRasterPos4dCallback));

     Gl->Set(String::NewSymbol("RasterPos4f"), FunctionTemplate::New(GLRasterPos4fCallback));

     Gl->Set(String::NewSymbol("RasterPos4i"), FunctionTemplate::New(GLRasterPos4iCallback));

     Gl->Set(String::NewSymbol("RasterPos4s"), FunctionTemplate::New(GLRasterPos4sCallback));

     Gl->Set(String::NewSymbol("RasterPos2dv"), FunctionTemplate::New(GLRasterPos2dvCallback));

     Gl->Set(String::NewSymbol("RasterPos2fv"), FunctionTemplate::New(GLRasterPos2fvCallback));

     Gl->Set(String::NewSymbol("RasterPos2iv"), FunctionTemplate::New(GLRasterPos2ivCallback));

     Gl->Set(String::NewSymbol("RasterPos2sv"), FunctionTemplate::New(GLRasterPos2svCallback));

     Gl->Set(String::NewSymbol("RasterPos3dv"), FunctionTemplate::New(GLRasterPos3dvCallback));

     Gl->Set(String::NewSymbol("RasterPos3fv"), FunctionTemplate::New(GLRasterPos3fvCallback));

     Gl->Set(String::NewSymbol("RasterPos3iv"), FunctionTemplate::New(GLRasterPos3ivCallback));

     Gl->Set(String::NewSymbol("RasterPos3sv"), FunctionTemplate::New(GLRasterPos3svCallback));

     Gl->Set(String::NewSymbol("RasterPos4dv"), FunctionTemplate::New(GLRasterPos4dvCallback));

     Gl->Set(String::NewSymbol("RasterPos4fv"), FunctionTemplate::New(GLRasterPos4fvCallback));

     Gl->Set(String::NewSymbol("RasterPos4iv"), FunctionTemplate::New(GLRasterPos4ivCallback));

     Gl->Set(String::NewSymbol("RasterPos4sv"), FunctionTemplate::New(GLRasterPos4svCallback));

     Gl->Set(String::NewSymbol("Rectd"), FunctionTemplate::New(GLRectdCallback));

     Gl->Set(String::NewSymbol("Rectf"), FunctionTemplate::New(GLRectfCallback));

     Gl->Set(String::NewSymbol("Recti"), FunctionTemplate::New(GLRectiCallback));

     Gl->Set(String::NewSymbol("Rects"), FunctionTemplate::New(GLRectsCallback));

     Gl->Set(String::NewSymbol("Rectdv"), FunctionTemplate::New(GLRectdvCallback));

     Gl->Set(String::NewSymbol("Rectfv"), FunctionTemplate::New(GLRectfvCallback));

     Gl->Set(String::NewSymbol("Rectiv"), FunctionTemplate::New(GLRectivCallback));

     Gl->Set(String::NewSymbol("Rectsv"), FunctionTemplate::New(GLRectsvCallback));

     Gl->Set(String::NewSymbol("ArrayElement"), FunctionTemplate::New(GLArrayElementCallback));

     Gl->Set(String::NewSymbol("DrawArrays"), FunctionTemplate::New(GLDrawArraysCallback));

     Gl->Set(String::NewSymbol("ShadeModel"), FunctionTemplate::New(GLShadeModelCallback));

     Gl->Set(String::NewSymbol("Lightf"), FunctionTemplate::New(GLLightfCallback));

     Gl->Set(String::NewSymbol("Lighti"), FunctionTemplate::New(GLLightiCallback));

     Gl->Set(String::NewSymbol("Lightfv"), FunctionTemplate::New(GLLightfvCallback));

     Gl->Set(String::NewSymbol("Lightiv"), FunctionTemplate::New(GLLightivCallback));

     Gl->Set(String::NewSymbol("GetLightfv"), FunctionTemplate::New(GLGetLightfvCallback));

     Gl->Set(String::NewSymbol("GetLightiv"), FunctionTemplate::New(GLGetLightivCallback));

     Gl->Set(String::NewSymbol("LightModelf"), FunctionTemplate::New(GLLightModelfCallback));

     Gl->Set(String::NewSymbol("LightModeli"), FunctionTemplate::New(GLLightModeliCallback));

     Gl->Set(String::NewSymbol("LightModelfv"), FunctionTemplate::New(GLLightModelfvCallback));

     Gl->Set(String::NewSymbol("LightModeliv"), FunctionTemplate::New(GLLightModelivCallback));

     Gl->Set(String::NewSymbol("Materialf"), FunctionTemplate::New(GLMaterialfCallback));

     Gl->Set(String::NewSymbol("Materiali"), FunctionTemplate::New(GLMaterialiCallback));

     Gl->Set(String::NewSymbol("Materialfv"), FunctionTemplate::New(GLMaterialfvCallback));

     Gl->Set(String::NewSymbol("Materialiv"), FunctionTemplate::New(GLMaterialivCallback));

     Gl->Set(String::NewSymbol("GetMaterialfv"), FunctionTemplate::New(GLGetMaterialfvCallback));

     Gl->Set(String::NewSymbol("GetMaterialiv"), FunctionTemplate::New(GLGetMaterialivCallback));

     Gl->Set(String::NewSymbol("ColorMaterial"), FunctionTemplate::New(GLColorMaterialCallback));

     Gl->Set(String::NewSymbol("PixelZoom"), FunctionTemplate::New(GLPixelZoomCallback));

     Gl->Set(String::NewSymbol("PixelStoref"), FunctionTemplate::New(GLPixelStorefCallback));

     Gl->Set(String::NewSymbol("PixelStorei"), FunctionTemplate::New(GLPixelStoreiCallback));

     Gl->Set(String::NewSymbol("PixelTransferf"), FunctionTemplate::New(GLPixelTransferfCallback));

     Gl->Set(String::NewSymbol("PixelTransferi"), FunctionTemplate::New(GLPixelTransferiCallback));

     Gl->Set(String::NewSymbol("PixelMapfv"), FunctionTemplate::New(GLPixelMapfvCallback));

     Gl->Set(String::NewSymbol("PixelMapuiv"), FunctionTemplate::New(GLPixelMapuivCallback));

     Gl->Set(String::NewSymbol("PixelMapusv"), FunctionTemplate::New(GLPixelMapusvCallback));

     Gl->Set(String::NewSymbol("GetPixelMapfv"), FunctionTemplate::New(GLGetPixelMapfvCallback));

     Gl->Set(String::NewSymbol("GetPixelMapuiv"), FunctionTemplate::New(GLGetPixelMapuivCallback));

     Gl->Set(String::NewSymbol("GetPixelMapusv"), FunctionTemplate::New(GLGetPixelMapusvCallback));

     Gl->Set(String::NewSymbol("Bitmap"), FunctionTemplate::New(GLBitmapCallback));

     Gl->Set(String::NewSymbol("CopyPixels"), FunctionTemplate::New(GLCopyPixelsCallback));

     Gl->Set(String::NewSymbol("StencilFunc"), FunctionTemplate::New(GLStencilFuncCallback));

     Gl->Set(String::NewSymbol("StencilMask"), FunctionTemplate::New(GLStencilMaskCallback));

     Gl->Set(String::NewSymbol("StencilOp"), FunctionTemplate::New(GLStencilOpCallback));

     Gl->Set(String::NewSymbol("ClearStencil"), FunctionTemplate::New(GLClearStencilCallback));

     Gl->Set(String::NewSymbol("TexGend"), FunctionTemplate::New(GLTexGendCallback));

     Gl->Set(String::NewSymbol("TexGenf"), FunctionTemplate::New(GLTexGenfCallback));

     Gl->Set(String::NewSymbol("TexGeni"), FunctionTemplate::New(GLTexGeniCallback));

     Gl->Set(String::NewSymbol("TexGendv"), FunctionTemplate::New(GLTexGendvCallback));

     Gl->Set(String::NewSymbol("TexGenfv"), FunctionTemplate::New(GLTexGenfvCallback));

     Gl->Set(String::NewSymbol("TexGeniv"), FunctionTemplate::New(GLTexGenivCallback));

     Gl->Set(String::NewSymbol("GetTexGendv"), FunctionTemplate::New(GLGetTexGendvCallback));

     Gl->Set(String::NewSymbol("GetTexGenfv"), FunctionTemplate::New(GLGetTexGenfvCallback));

     Gl->Set(String::NewSymbol("GetTexGeniv"), FunctionTemplate::New(GLGetTexGenivCallback));

     Gl->Set(String::NewSymbol("TexEnvf"), FunctionTemplate::New(GLTexEnvfCallback));

     Gl->Set(String::NewSymbol("TexEnvi"), FunctionTemplate::New(GLTexEnviCallback));

     Gl->Set(String::NewSymbol("TexEnvfv"), FunctionTemplate::New(GLTexEnvfvCallback));

     Gl->Set(String::NewSymbol("TexEnviv"), FunctionTemplate::New(GLTexEnvivCallback));

     Gl->Set(String::NewSymbol("GetTexEnvfv"), FunctionTemplate::New(GLGetTexEnvfvCallback));

     Gl->Set(String::NewSymbol("GetTexEnviv"), FunctionTemplate::New(GLGetTexEnvivCallback));

     Gl->Set(String::NewSymbol("TexParameterf"), FunctionTemplate::New(GLTexParameterfCallback));

     Gl->Set(String::NewSymbol("TexParameteri"), FunctionTemplate::New(GLTexParameteriCallback));

     Gl->Set(String::NewSymbol("TexParameterfv"), FunctionTemplate::New(GLTexParameterfvCallback));

     Gl->Set(String::NewSymbol("TexParameteriv"), FunctionTemplate::New(GLTexParameterivCallback));

     Gl->Set(String::NewSymbol("GetTexParameterfv"), FunctionTemplate::New(GLGetTexParameterfvCallback));

     Gl->Set(String::NewSymbol("GetTexParameteriv"), FunctionTemplate::New(GLGetTexParameterivCallback));

     Gl->Set(String::NewSymbol("GetTexLevelParameterfv"), FunctionTemplate::New(GLGetTexLevelParameterfvCallback));

     Gl->Set(String::NewSymbol("GetTexLevelParameteriv"), FunctionTemplate::New(GLGetTexLevelParameterivCallback));

     Gl->Set(String::NewSymbol("GenTextures"), FunctionTemplate::New(GLGenTexturesCallback));

     Gl->Set(String::NewSymbol("DeleteTextures"), FunctionTemplate::New(GLDeleteTexturesCallback));

     Gl->Set(String::NewSymbol("BindTexture"), FunctionTemplate::New(GLBindTextureCallback));

     Gl->Set(String::NewSymbol("PrioritizeTextures"), FunctionTemplate::New(GLPrioritizeTexturesCallback));

     Gl->Set(String::NewSymbol("AreTexturesResident"), FunctionTemplate::New(GLAreTexturesResidentCallback));

     Gl->Set(String::NewSymbol("IsTexture"), FunctionTemplate::New(GLIsTextureCallback));

     Gl->Set(String::NewSymbol("CopyTexImage1D"), FunctionTemplate::New(GLCopyTexImage1DCallback));

     Gl->Set(String::NewSymbol("CopyTexImage2D"), FunctionTemplate::New(GLCopyTexImage2DCallback));

     Gl->Set(String::NewSymbol("CopyTexSubImage1D"), FunctionTemplate::New(GLCopyTexSubImage1DCallback));

     Gl->Set(String::NewSymbol("CopyTexSubImage2D"), FunctionTemplate::New(GLCopyTexSubImage2DCallback));

     Gl->Set(String::NewSymbol("Map1d"), FunctionTemplate::New(GLMap1dCallback));

     Gl->Set(String::NewSymbol("Map1f"), FunctionTemplate::New(GLMap1fCallback));

     Gl->Set(String::NewSymbol("Map2d"), FunctionTemplate::New(GLMap2dCallback));

     Gl->Set(String::NewSymbol("Map2f"), FunctionTemplate::New(GLMap2fCallback));

     Gl->Set(String::NewSymbol("GetMapdv"), FunctionTemplate::New(GLGetMapdvCallback));

     Gl->Set(String::NewSymbol("GetMapfv"), FunctionTemplate::New(GLGetMapfvCallback));

     Gl->Set(String::NewSymbol("GetMapiv"), FunctionTemplate::New(GLGetMapivCallback));

     Gl->Set(String::NewSymbol("EvalCoord1d"), FunctionTemplate::New(GLEvalCoord1dCallback));

     Gl->Set(String::NewSymbol("EvalCoord1f"), FunctionTemplate::New(GLEvalCoord1fCallback));

     Gl->Set(String::NewSymbol("EvalCoord1dv"), FunctionTemplate::New(GLEvalCoord1dvCallback));

     Gl->Set(String::NewSymbol("EvalCoord1fv"), FunctionTemplate::New(GLEvalCoord1fvCallback));

     Gl->Set(String::NewSymbol("EvalCoord2d"), FunctionTemplate::New(GLEvalCoord2dCallback));

     Gl->Set(String::NewSymbol("EvalCoord2f"), FunctionTemplate::New(GLEvalCoord2fCallback));

     Gl->Set(String::NewSymbol("EvalCoord2dv"), FunctionTemplate::New(GLEvalCoord2dvCallback));

     Gl->Set(String::NewSymbol("EvalCoord2fv"), FunctionTemplate::New(GLEvalCoord2fvCallback));

     Gl->Set(String::NewSymbol("MapGrid1d"), FunctionTemplate::New(GLMapGrid1dCallback));

     Gl->Set(String::NewSymbol("MapGrid1f"), FunctionTemplate::New(GLMapGrid1fCallback));

     Gl->Set(String::NewSymbol("MapGrid2d"), FunctionTemplate::New(GLMapGrid2dCallback));

     Gl->Set(String::NewSymbol("MapGrid2f"), FunctionTemplate::New(GLMapGrid2fCallback));

     Gl->Set(String::NewSymbol("EvalPoint1"), FunctionTemplate::New(GLEvalPoint1Callback));

     Gl->Set(String::NewSymbol("EvalPoint2"), FunctionTemplate::New(GLEvalPoint2Callback));

     Gl->Set(String::NewSymbol("EvalMesh1"), FunctionTemplate::New(GLEvalMesh1Callback));

     Gl->Set(String::NewSymbol("EvalMesh2"), FunctionTemplate::New(GLEvalMesh2Callback));

     Gl->Set(String::NewSymbol("Fogf"), FunctionTemplate::New(GLFogfCallback));

     Gl->Set(String::NewSymbol("Fogi"), FunctionTemplate::New(GLFogiCallback));

     Gl->Set(String::NewSymbol("Fogfv"), FunctionTemplate::New(GLFogfvCallback));

     Gl->Set(String::NewSymbol("Fogiv"), FunctionTemplate::New(GLFogivCallback));

     Gl->Set(String::NewSymbol("FeedbackBuffer"), FunctionTemplate::New(GLFeedbackBufferCallback));

     Gl->Set(String::NewSymbol("PassThrough"), FunctionTemplate::New(GLPassThroughCallback));

     Gl->Set(String::NewSymbol("SelectBuffer"), FunctionTemplate::New(GLSelectBufferCallback));

     Gl->Set(String::NewSymbol("InitNames"), FunctionTemplate::New(GLInitNamesCallback));

     Gl->Set(String::NewSymbol("LoadName"), FunctionTemplate::New(GLLoadNameCallback));

     Gl->Set(String::NewSymbol("PushName"), FunctionTemplate::New(GLPushNameCallback));

     Gl->Set(String::NewSymbol("PopName"), FunctionTemplate::New(GLPopNameCallback));

     Gl->Set(String::NewSymbol("CopyTexSubImage3D"), FunctionTemplate::New(GLCopyTexSubImage3DCallback));

     Gl->Set(String::NewSymbol("ColorTableParameteriv"), FunctionTemplate::New(GLColorTableParameterivCallback));

     Gl->Set(String::NewSymbol("ColorTableParameterfv"), FunctionTemplate::New(GLColorTableParameterfvCallback));

     Gl->Set(String::NewSymbol("CopyColorSubTable"), FunctionTemplate::New(GLCopyColorSubTableCallback));

     Gl->Set(String::NewSymbol("CopyColorTable"), FunctionTemplate::New(GLCopyColorTableCallback));

     Gl->Set(String::NewSymbol("GetColorTableParameterfv"), FunctionTemplate::New(GLGetColorTableParameterfvCallback));

     Gl->Set(String::NewSymbol("GetColorTableParameteriv"), FunctionTemplate::New(GLGetColorTableParameterivCallback));

     Gl->Set(String::NewSymbol("BlendEquation"), FunctionTemplate::New(GLBlendEquationCallback));

     Gl->Set(String::NewSymbol("BlendColor"), FunctionTemplate::New(GLBlendColorCallback));

     Gl->Set(String::NewSymbol("Histogram"), FunctionTemplate::New(GLHistogramCallback));

     Gl->Set(String::NewSymbol("ResetHistogram"), FunctionTemplate::New(GLResetHistogramCallback));

     Gl->Set(String::NewSymbol("GetHistogramParameterfv"), FunctionTemplate::New(GLGetHistogramParameterfvCallback));

     Gl->Set(String::NewSymbol("GetHistogramParameteriv"), FunctionTemplate::New(GLGetHistogramParameterivCallback));

     Gl->Set(String::NewSymbol("Minmax"), FunctionTemplate::New(GLMinmaxCallback));

     Gl->Set(String::NewSymbol("ResetMinmax"), FunctionTemplate::New(GLResetMinmaxCallback));

     Gl->Set(String::NewSymbol("GetMinmaxParameterfv"), FunctionTemplate::New(GLGetMinmaxParameterfvCallback));

     Gl->Set(String::NewSymbol("GetMinmaxParameteriv"), FunctionTemplate::New(GLGetMinmaxParameterivCallback));

     Gl->Set(String::NewSymbol("ConvolutionParameterf"), FunctionTemplate::New(GLConvolutionParameterfCallback));

     Gl->Set(String::NewSymbol("ConvolutionParameterfv"), FunctionTemplate::New(GLConvolutionParameterfvCallback));

     Gl->Set(String::NewSymbol("ConvolutionParameteri"), FunctionTemplate::New(GLConvolutionParameteriCallback));

     Gl->Set(String::NewSymbol("ConvolutionParameteriv"), FunctionTemplate::New(GLConvolutionParameterivCallback));

     Gl->Set(String::NewSymbol("CopyConvolutionFilter1D"), FunctionTemplate::New(GLCopyConvolutionFilter1DCallback));

     Gl->Set(String::NewSymbol("CopyConvolutionFilter2D"), FunctionTemplate::New(GLCopyConvolutionFilter2DCallback));

     Gl->Set(String::NewSymbol("GetConvolutionParameterfv"), FunctionTemplate::New(GLGetConvolutionParameterfvCallback));

     Gl->Set(String::NewSymbol("GetConvolutionParameteriv"), FunctionTemplate::New(GLGetConvolutionParameterivCallback));

     Gl->Set(String::NewSymbol("ActiveTexture"), FunctionTemplate::New(GLActiveTextureCallback));

     Gl->Set(String::NewSymbol("ClientActiveTexture"), FunctionTemplate::New(GLClientActiveTextureCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1d"), FunctionTemplate::New(GLMultiTexCoord1dCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1dv"), FunctionTemplate::New(GLMultiTexCoord1dvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1f"), FunctionTemplate::New(GLMultiTexCoord1fCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1fv"), FunctionTemplate::New(GLMultiTexCoord1fvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1i"), FunctionTemplate::New(GLMultiTexCoord1iCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1iv"), FunctionTemplate::New(GLMultiTexCoord1ivCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1s"), FunctionTemplate::New(GLMultiTexCoord1sCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1sv"), FunctionTemplate::New(GLMultiTexCoord1svCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2d"), FunctionTemplate::New(GLMultiTexCoord2dCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2dv"), FunctionTemplate::New(GLMultiTexCoord2dvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2f"), FunctionTemplate::New(GLMultiTexCoord2fCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2fv"), FunctionTemplate::New(GLMultiTexCoord2fvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2i"), FunctionTemplate::New(GLMultiTexCoord2iCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2iv"), FunctionTemplate::New(GLMultiTexCoord2ivCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2s"), FunctionTemplate::New(GLMultiTexCoord2sCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2sv"), FunctionTemplate::New(GLMultiTexCoord2svCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3d"), FunctionTemplate::New(GLMultiTexCoord3dCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3dv"), FunctionTemplate::New(GLMultiTexCoord3dvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3f"), FunctionTemplate::New(GLMultiTexCoord3fCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3fv"), FunctionTemplate::New(GLMultiTexCoord3fvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3i"), FunctionTemplate::New(GLMultiTexCoord3iCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3iv"), FunctionTemplate::New(GLMultiTexCoord3ivCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3s"), FunctionTemplate::New(GLMultiTexCoord3sCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3sv"), FunctionTemplate::New(GLMultiTexCoord3svCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4d"), FunctionTemplate::New(GLMultiTexCoord4dCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4dv"), FunctionTemplate::New(GLMultiTexCoord4dvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4f"), FunctionTemplate::New(GLMultiTexCoord4fCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4fv"), FunctionTemplate::New(GLMultiTexCoord4fvCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4i"), FunctionTemplate::New(GLMultiTexCoord4iCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4iv"), FunctionTemplate::New(GLMultiTexCoord4ivCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4s"), FunctionTemplate::New(GLMultiTexCoord4sCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4sv"), FunctionTemplate::New(GLMultiTexCoord4svCallback));

     Gl->Set(String::NewSymbol("LoadTransposeMatrixd"), FunctionTemplate::New(GLLoadTransposeMatrixdCallback));

     Gl->Set(String::NewSymbol("LoadTransposeMatrixf"), FunctionTemplate::New(GLLoadTransposeMatrixfCallback));

     Gl->Set(String::NewSymbol("MultTransposeMatrixd"), FunctionTemplate::New(GLMultTransposeMatrixdCallback));

     Gl->Set(String::NewSymbol("MultTransposeMatrixf"), FunctionTemplate::New(GLMultTransposeMatrixfCallback));

     Gl->Set(String::NewSymbol("SampleCoverage"), FunctionTemplate::New(GLSampleCoverageCallback));

     Gl->Set(String::NewSymbol("ActiveTextureARB"), FunctionTemplate::New(GLActiveTextureARBCallback));

     Gl->Set(String::NewSymbol("ClientActiveTextureARB"), FunctionTemplate::New(GLClientActiveTextureARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1dARB"), FunctionTemplate::New(GLMultiTexCoord1dARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1dvARB"), FunctionTemplate::New(GLMultiTexCoord1dvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1fARB"), FunctionTemplate::New(GLMultiTexCoord1fARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1fvARB"), FunctionTemplate::New(GLMultiTexCoord1fvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1iARB"), FunctionTemplate::New(GLMultiTexCoord1iARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1ivARB"), FunctionTemplate::New(GLMultiTexCoord1ivARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1sARB"), FunctionTemplate::New(GLMultiTexCoord1sARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord1svARB"), FunctionTemplate::New(GLMultiTexCoord1svARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2dARB"), FunctionTemplate::New(GLMultiTexCoord2dARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2dvARB"), FunctionTemplate::New(GLMultiTexCoord2dvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2fARB"), FunctionTemplate::New(GLMultiTexCoord2fARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2fvARB"), FunctionTemplate::New(GLMultiTexCoord2fvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2iARB"), FunctionTemplate::New(GLMultiTexCoord2iARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2ivARB"), FunctionTemplate::New(GLMultiTexCoord2ivARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2sARB"), FunctionTemplate::New(GLMultiTexCoord2sARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord2svARB"), FunctionTemplate::New(GLMultiTexCoord2svARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3dARB"), FunctionTemplate::New(GLMultiTexCoord3dARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3dvARB"), FunctionTemplate::New(GLMultiTexCoord3dvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3fARB"), FunctionTemplate::New(GLMultiTexCoord3fARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3fvARB"), FunctionTemplate::New(GLMultiTexCoord3fvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3iARB"), FunctionTemplate::New(GLMultiTexCoord3iARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3ivARB"), FunctionTemplate::New(GLMultiTexCoord3ivARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3sARB"), FunctionTemplate::New(GLMultiTexCoord3sARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord3svARB"), FunctionTemplate::New(GLMultiTexCoord3svARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4dARB"), FunctionTemplate::New(GLMultiTexCoord4dARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4dvARB"), FunctionTemplate::New(GLMultiTexCoord4dvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4fARB"), FunctionTemplate::New(GLMultiTexCoord4fARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4fvARB"), FunctionTemplate::New(GLMultiTexCoord4fvARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4iARB"), FunctionTemplate::New(GLMultiTexCoord4iARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4ivARB"), FunctionTemplate::New(GLMultiTexCoord4ivARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4sARB"), FunctionTemplate::New(GLMultiTexCoord4sARBCallback));

     Gl->Set(String::NewSymbol("MultiTexCoord4svARB"), FunctionTemplate::New(GLMultiTexCoord4svARBCallback));


      // Again, return the result through the current handle scope.
      return handle_scope.Close(Gl);
}    
